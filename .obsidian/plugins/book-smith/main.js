/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/i18n/locales/zh-CN.ts
var zh_CN_exports = {};
__export(zh_CN_exports, {
  default: () => zh_CN_default
});
var commonTranslation, bookSmithViewTranslation, toolViewTranslation, settingsTranslation, modalTranslation, managerTranslation, toolbarModalTranslation, componentTranslation, translation, zh_CN_default;
var init_zh_CN = __esm({
  "src/i18n/locales/zh-CN.ts"() {
    commonTranslation = {
      PLUGIN_NAME: "BookSmith \u4E66\u7C4D\u521B\u4F5C",
      SETTINGS: "\u8BBE\u7F6E",
      SAVE: "\u4FDD\u5B58",
      CANCEL: "\u53D6\u6D88",
      HIDE: "\u9690\u85CF",
      SHOW: "\u663E\u793A",
      OPEN_BOOK_PANEL: "\u6253\u5F00\u4E66\u7C4D\u7BA1\u7406\u9762\u677F",
      OPEN_TOOL_PANEL: "\u6253\u5F00\u5DE5\u5177\u9762\u677F",
      OPEN_ALL_PANELS: "\u6253\u5F00\u6240\u6709\u9762\u677F",
      PREFACE: "\u524D\u8A00",
      OUTLINE: "\u5927\u7EB2",
      VOLUME_1: "\u7B2C\u4E00\u5377",
      CHAPTER_1: "\u7B2C\u4E00\u7AE0",
      CHAPTER_2: "\u7B2C\u4E8C\u7AE0",
      AFTERWORD: "\u540E\u8BB0",
      TEMPLATE_OPTIONS_DESC: "\u5305\u542B\u524D\u8A00\u3001\u5927\u7EB2\u3001\u6B63\u6587\u5377\u7AE0\u548C\u540E\u8BB0\u7684\u6807\u51C6\u7ED3\u6784"
    };
    bookSmithViewTranslation = {
      // 主界面
      BOOK_MANAGER: "\u4E66\u7C4D\u7BA1\u7406",
      NEW_BOOK: "\u65B0\u5EFA",
      SWITCH_BOOK: "\u5207\u6362",
      MANAGE_BOOK: "\u7BA1\u7406",
      // 书籍相关
      BOOK_TITLE: "\u4E66\u540D",
      BOOK_AUTHOR: "\u4F5C\u8005",
      BOOK_DESCRIPTION: "\u7B80\u4ECB",
      BOOK_TAGS: "\u6807\u7B7E",
      BOOK_COVER: "\u5C01\u9762",
      // 章节相关
      CHAPTER: "\u7AE0\u8282",
      ADD_CHAPTER: "\u6DFB\u52A0\u7AE0\u8282",
      DELETE_CHAPTER: "\u5220\u9664\u7AE0\u8282",
      RENAME_CHAPTER: "\u91CD\u547D\u540D\u7AE0\u8282",
      // 统计相关
      STATS: "\u7EDF\u8BA1",
      WORD_COUNT: "\u5B57\u6570",
      CHAPTER_COUNT: "\u7AE0\u8282\u6570",
      // 帮助提示
      HELP_TOOLTIP: `\u{1F44B} \u6B22\u8FCE\u4F7F\u7528 BookSmith

\u{1F680} \u5F00\u59CB\u4F7F\u7528
\u2022 \u6253\u5F00\u53F3\u4FA7\u3010\u5199\u4F5C\u5DE5\u5177\u7BB1\u3011\uFF0C\u6FC0\u6D3B\u521B\u4F5C\u8F85\u52A9\u529F\u80FD
\u2022 \u4E13\u6CE8\u6A21\u5F0F\u3001\u7EDF\u8BA1\u5206\u6790\u3001\u5F15\u7528\u7BA1\u7406\u7B49\u5DE5\u5177\u4E00\u952E\u53EF\u5F97

\u{1F4DA} \u521B\u4F5C\u7BA1\u7406
\u2022 \u65B0\u5EFA\uFF1A\u9009\u62E9\u6A21\u677F\u521B\u5EFA\u4E66\u7C4D\u9879\u76EE
\u2022 \u5207\u6362\uFF1A\u5728\u4E0D\u540C\u4F5C\u54C1\u95F4\u81EA\u7531\u5207\u6362
\u2022 \u7BA1\u7406\uFF1A\u5BFC\u5165\u3001\u7F16\u8F91\u60A8\u7684\u4F5C\u54C1\u96C6
\u2022 \u6A21\u677F\uFF1A\u81EA\u5B9A\u4E49\u4E13\u5C5E\u5199\u4F5C\u6846\u67B6

\u{1F4D1} \u7AE0\u8282\u7F16\u6392
\u2022 \u6811\u5F62\u7ED3\u6784\uFF1A\u76F4\u89C2\u5C55\u73B0\u5C42\u6B21\u7ED3\u6784
\u2022 \u62D6\u62FD\u6392\u5E8F\uFF1A\u7075\u6D3B\u8C03\u6574\u7AE0\u8282\u987A\u5E8F
\u2022 \u72B6\u6001\u6807\u8BB0\uFF1A\u8FFD\u8E2A\u521B\u4F5C\u8FDB\u5EA6
\u2022 \u53F3\u952E\u83DC\u5355\uFF1A\u4FBF\u6377\u7684\u7AE0\u8282\u64CD\u4F5C

\u26A1\uFE0F \u521B\u4F5C\u52A9\u624B
\u2022 \u5B9E\u65F6\u7EDF\u8BA1\uFF1A\u5B57\u6570\u3001\u8FDB\u5EA6\u5B9E\u65F6\u66F4\u65B0
\u2022 \u6570\u636E\u5206\u6790\uFF1A\u5199\u4F5C\u4E60\u60EF\u6DF1\u5EA6\u7EDF\u8BA1
\u2022 \u4E13\u6CE8\u6A21\u5F0F\uFF1A\u63D0\u5347\u5199\u4F5C\u6548\u7387

\u{1F4A1} \u5C0F\u8D34\u58EB
\u2022 \u652F\u6301\u81EA\u5B9A\u4E49\u591A\u79CD\u5199\u4F5C\u6A21\u677F
\u2022 \u53EF\u901A\u8FC7\u62D6\u62FD\u5FEB\u901F\u8C03\u6574\u7AE0\u8282
\u2022 \u53F3\u952E\u70B9\u51FB\u53EF\u8FDB\u884C\u66F4\u591A\u64CD\u4F5C

\u2728 \u613F BookSmith \u80FD\u8BA9\u60A8\u4EAB\u53D7\u521B\u4F5C\u7684\u7F8E\u597D\u65F6\u5149\u3002

\u{1F49D} \u8D5E\u8D4F\u652F\u6301
\u5982\u679C BookSmith \u4E3A\u60A8\u5E26\u6765\u5E2E\u52A9\uFF0C\u8BF7\u524D\u5F80
\u53F3\u4FA7\u5199\u4F5C\u5DE5\u5177\u7BB1\u3010\u8D5E\u8D4F\u6350\u8D60\u3011\uFF0C\u652F\u6301\u6211\u7EE7\u7EED\u521B\u4F5C\u4F18\u96C5\u5DE5\u5177\u3002`,
      // 通知消息
      SWITCHED_TO_BOOK: "\u5DF2\u5207\u6362\u5230\u300A{title}\u300B",
      IMPORTED_AND_SWITCHED: "\u5DF2\u5BFC\u5165\u5E76\u5207\u6362\u5230\u65B0\u4E66\u7C4D",
      CURRENT_BOOK_DELETED: "\u5F53\u524D\u4E66\u7C4D\u5DF2\u88AB\u5220\u9664",
      NO_BOOKS_TO_SWITCH: "\u6682\u65E0\u53EF\u5207\u6362\u7684\u4E66\u7C4D",
      // 统计文本
      TODAY_WORDS: "\u4ECA\u65E5\u5B57\u6570",
      TOTAL_WORDS: "\u5B57\u6570\u7EDF\u8BA1",
      CHAPTER_COMPLETION: "\u7AE0\u8282\u5B8C\u6210",
      WRITING_DAYS: "\u5199\u4F5C\u5929\u6570",
      AVERAGE_DAILY_WORDS: "\u65E5\u5747\u5B57\u6570",
      WORD_UNIT: "\u5B57",
      DAY_UNIT: "\u5929",
      TEN_THOUSAND: "\u4E07",
      // 空状态提示
      WELCOME_MESSAGE: "\u{1F44B} \u6B22\u8FCE\u4F7F\u7528 BookSmith",
      EMPTY_STATE_HINT: '\u70B9\u51FB\u4E0A\u65B9\u7684"\u65B0\u5EFA"\u521B\u5EFA\u4F5C\u54C1\uFF0C\u6216\u4F7F\u7528"\u5207\u6362"\u6309\u94AE\u9009\u62E9\u5DF2\u6709\u4E66\u7C4D'
    };
    toolViewTranslation = {
      WRITING_TOOLBOX: "\u5199\u4F5C\u5DE5\u5177\u7BB1",
      // 写作助手
      WRITING_ASSISTANT: "\u5199\u4F5C\u52A9\u624B",
      FOCUS_MODE: "\u4E13\u6CE8\u6A21\u5F0F",
      CREATIVE_INSPIRATION: "\u521B\u4F5C\u7075\u611F",
      CHARACTER_PROFILES: "\u4EBA\u7269\u6863\u6848",
      WORLD_BUILDING: "\u4E16\u754C\u6784\u5EFA",
      // 导出发布
      EXPORT_PUBLISH: "\u5BFC\u51FA\u53D1\u5E03",
      DESIGN_TYPOGRAPHY: "\u751F\u6210\u7535\u5B50\u4E66",
      GENERATE_EBOOK: "\u751F\u6210\u7535\u5B50\u4E66",
      MORE_FEATURES: "\u66F4\u591A\u529F\u80FD...",
      MORE_FEATURES_MESSAGE: "\u66F4\u591A\u529F\u80FD\u7B49\u4F60\u4E00\u8D77\u5171\u521B",
      // 写作圈子
      WRITING_COMMUNITY: "\u5199\u4F5C\u5708\u5B50",
      CREATIVE_COMMUNITY: "\u521B\u4F5C\u793E\u533A",
      CONTACT_AUTHOR: "\u8054\u7CFB\u4F5C\u8005",
      DONATE_SUPPORT: "\u8D5E\u52A9\u6350\u8D60",
      // 面板设置
      PANEL_SETTINGS: "\u9762\u677F\u8BBE\u7F6E",
      FEATURE_COMING_SOON: "{feature}\u529F\u80FD\u5373\u5C06\u4E0A\u7EBF"
    };
    settingsTranslation = {
      PLUGIN_NAME: "Book Smith",
      BASIC_OPTIONS: "\u57FA\u672C\u9009\u9879",
      TEMPLATE_OPTIONS: "\u6A21\u677F\u9009\u9879",
      WRITING_TOOLS_OPTIONS: "\u5199\u4F5C\u5DE5\u5177\u7BB1\u9009\u9879",
      // 基本设置
      LANGUAGE_SETTING: "\u8BED\u8A00",
      LANGUAGE_DESC: "\u9009\u62E9\u63D2\u4EF6\u754C\u9762\u8BED\u8A00 / Choose plugin language",
      DEFAULT_AUTHOR: "\u9ED8\u8BA4\u4F5C\u8005",
      DEFAULT_AUTHOR_DESC: "\u521B\u5EFA\u65B0\u4E66\u7C4D\u65F6\u7684\u9ED8\u8BA4\u4F5C\u8005\u540D",
      DEFAULT_AUTHOR_PLACEHOLDER: "\u8F93\u5165\u9ED8\u8BA4\u4F5C\u8005\u540D",
      BOOK_STORAGE_PATH: "\u4E66\u7C4D\u5B58\u50A8\u8DEF\u5F84",
      BOOK_STORAGE_DESC: "\u65B0\u5EFA\u4E66\u7C4D\u7684\u9ED8\u8BA4\u5B58\u50A8\u8DEF\u5F84",
      STORAGE_PATH_CHANGED: "\u5B58\u50A8\u8DEF\u5F84\u5DF2\u66F4\u6539\uFF0C\u8BF7\u91CD\u542F Obsidian \u6216\u91CD\u65B0\u52A0\u8F7D\u4EE5\u4F7F\u66F4\u6539\u751F\u6548",
      // 模板设置
      DEFAULT_TEMPLATE: "\u9ED8\u8BA4\u6A21\u677F",
      DEFAULT_TEMPLATE_DESC: "\u521B\u5EFA\u65B0\u4E66\u7C4D\u65F6\u4F7F\u7528\u7684\u9ED8\u8BA4\u6A21\u677F",
      BOOK_TEMPLATES: "\u4E66\u7C4D\u6A21\u677F",
      ADD_NEW_TEMPLATE: "\u6DFB\u52A0\u65B0\u6A21\u677F",
      EDIT_TEMPLATE: "\u7F16\u8F91\u6A21\u677F",
      DELETE_TEMPLATE: "\u5220\u9664\u6A21\u677F",
      DELETE_TEMPLATE_TITLE: "\u5220\u9664\u6A21\u677F",
      DELETE_TEMPLATE_DESC: "\u786E\u5B9A\u8981\u5220\u9664\u6B64\u6A21\u677F\u5417\uFF1F\u5220\u9664\u540E\u65E0\u6CD5\u6062\u590D\u3002",
      // 写作工具箱设置
      FOCUS_MODE_OPTIONS: "\u4E13\u6CE8\u6A21\u5F0F\u9009\u9879",
      FOCUS_DURATION: "\u4E13\u6CE8\u65F6\u957F",
      FOCUS_DURATION_DESC: "\u6BCF\u4E2A\u4E13\u6CE8\u5468\u671F\u7684\u5DE5\u4F5C\u65F6\u957F\uFF08\u5206\u949F\uFF09",
      BREAK_DURATION: "\u95F4\u9694\u65F6\u957F",
      BREAK_DURATION_DESC: "\u6BCF\u4E2A\u4E13\u6CE8\u5468\u671F\u540E\u7684\u4F11\u606F\u65F6\u957F\uFF08\u5206\u949F\uFF09",
      WORD_GOAL: "\u5B57\u6570\u76EE\u6807",
      WORD_GOAL_DESC: "\u6BCF\u4E2A\u4E13\u6CE8\u5468\u671F\u7684\u76EE\u6807\u5B57\u6570"
    };
    modalTranslation = {
      // 通用
      COVER: "\u5C01\u9762",
      COVER_DESC: "\u9009\u62E9\u5C01\u9762\u56FE\u7247\uFF08\u53EF\u9009\uFF09",
      BOOK_TITLE: "\u4E66\u540D",
      BOOK_TITLE_DESC: "\u8BF7\u8F93\u5165\u4E66\u7C4D\u6807\u9898",
      BOOK_TITLE_PLACEHOLDER: "\u4E66\u540D",
      SUBTITLE: "\u526F\u6807\u9898",
      SUBTITLE_DESC: "\u53EF\u9009",
      SUBTITLE_PLACEHOLDER: "\u526F\u6807\u9898",
      TARGET_WORDS: "\u76EE\u6807\u5B57\u6570",
      TARGET_WORDS_DESC: "\u8BBE\u7F6E\u672C\u4E66\u9884\u8BA1\u603B\u5B57\u6570\uFF1A\u4E07\u5B57",
      TARGET_WORDS_PLACEHOLDER: "\u4F8B\u5982\uFF1A20\u621620.0\u4E07",
      AUTHOR: "\u4F5C\u8005",
      AUTHOR_DESC: "\u8BF7\u8F93\u5165\u4F5C\u8005\u540D\u79F0\uFF0C\u591A\u4E2A\u4F5C\u8005\u7528\u9017\u53F7\u5206\u9694",
      AUTHOR_PLACEHOLDER: "\u4F5C\u8005",
      DESCRIPTION: "\u7B80\u4ECB",
      DESCRIPTION_DESC: "\u8BF7\u8F93\u5165\u4E66\u7C4D\u7B80\u4ECB",
      DESCRIPTION_PLACEHOLDER: "\u4E66\u7C4D\u7B80\u4ECB",
      REQUIRED_FIELDS: "\u8BF7\u586B\u5199\u5FC5\u8981\u4FE1\u606F",
      // CreateBookModal
      CREATE_BOOK_TITLE: "\u521B\u5EFA\u65B0\u4E66\u7C4D",
      BOOK_TEMPLATE: "\u6A21\u677F",
      TEMPLATE_CHECK_DESC: "\u8BF7\u9009\u62E9\u4E66\u7C4D\u6A21\u677F",
      SELECT_IMAGE: "\u9009\u62E9\u56FE\u7247",
      COVER_UPLOAD_SUCCESS: "\u5C01\u9762\u4E0A\u4F20\u6210\u529F",
      COVER_UPLOAD_FAILED: "\u5C01\u9762\u4E0A\u4F20\u5931\u8D25\uFF1A",
      CREATE: "\u521B\u5EFA",
      CREATE_SUCCESS: "\u4E66\u7C4D\u521B\u5EFA\u6210\u529F",
      CREATE_FAILED: "\u521B\u5EFA\u5931\u8D25\uFF1A",
      // EditBookModal
      EDIT_BOOK_TITLE: "\u7F16\u8F91\u4E66\u7C4D",
      CHANGE_COVER: "\u66F4\u6362\u5C01\u9762",
      SELECT_COVER: "\u9009\u62E9\u5C01\u9762",
      COVER_UPDATE_SUCCESS: "\u5C01\u9762\u66F4\u65B0\u6210\u529F",
      COVER_UPDATE_FAILED: "\u5C01\u9762\u66F4\u65B0\u5931\u8D25\uFF1A",
      SAVE: "\u4FDD\u5B58",
      SAVE_SUCCESS: "\u4FDD\u5B58\u6210\u529F",
      SAVE_FAILED: "\u4FDD\u5B58\u5931\u8D25\uFF1A",
      // ManageBooksModal
      MANAGE_BOOKS_TITLE: "\u7BA1\u7406\u4E66\u7C4D",
      SEARCH_BOOKS_PLACEHOLDER: "\u641C\u7D22\u4E66\u7C4D...",
      IMPORT_BOOK: "\u5BFC\u5165\u4E66\u7C4D",
      BOOK_AUTHOR_PREFIX: "\u4F5C\u8005\uFF1A",
      BOOK_DESC_PREFIX: "\n\u7B80\u4ECB\uFF1A",
      BOOK_PROGRESS_PREFIX: "\n\u521B\u4F5C\u8F68\u8FF9\uFF1A",
      DELETE_BOOK: "\u5220\u9664",
      EDIT_BOOK: "\u7F16\u8F91",
      DELETE_BOOK_TITLE: "\u5220\u9664\u4E66\u7C4D",
      DELETE_BOOK_DESC: "\u786E\u5B9A\u8981\u5220\u9664\u300A{title}\u300B\u5417\uFF1F\n\u6B64\u64CD\u4F5C\u4E0D\u53EF\u6062\u590D\u3002",
      DELETE_SUCCESS: "\u5220\u9664\u6210\u529F",
      DELETE_FAILED: "\u5220\u9664\u5931\u8D25\uFF1A",
      BOOKS_ROOT_NOT_FOUND: "\u4E66\u7C4D\u6839\u76EE\u5F55\u4E0D\u5B58\u5728\u6216\u65E0\u6CD5\u8BBF\u95EE",
      NO_UNIMPORTED_BOOKS: "\u6CA1\u6709\u627E\u5230\u672A\u5BFC\u5165\u7684\u4E66\u7C4D\u76EE\u5F55",
      DETECT_UNIMPORTED_FAILED: "\u68C0\u6D4B\u672A\u5BFC\u5165\u4E66\u7C4D\u5931\u8D25\uFF1A",
      IMPORT_SUCCESS: "\u6210\u529F\u5BFC\u5165\u4E66\u7C4D\u300A{title}\u300B",
      IMPORT_FAILED: "\u521B\u5EFA\u4E66\u7C4D\u914D\u7F6E\u5931\u8D25\uFF1A",
      // SwitchBookModal
      SWITCH_BOOK_TITLE: "\u5207\u6362\u4E66\u7C4D",
      SEARCH_BOOK_PLACEHOLDER: "\u641C\u7D22\u4E66\u7C4D...",
      BOOK_AUTHOR_LABEL: "\u4F5C\u8005",
      BOOK_PROGRESS_LABEL: "\u8FDB\u5EA6",
      BOOK_WORDCOUNT_LABEL: "\u5B57\u6570",
      BOOK_LASTMOD_LABEL: "\u6700\u540E\u4FEE\u6539",
      SELECT_BOOK: "\u9009\u62E9",
      // UnimportedBooksModal
      UNIMPORTED_BOOKS_TITLE: "\u9009\u62E9\u8981\u5BFC\u5165\u7684\u4E66\u7C4D\u76EE\u5F55",
      NO_UNIMPORTED_FOLDERS: "\u6CA1\u6709\u627E\u5230\u672A\u5BFC\u5165\u7684\u4E66\u7C4D\u76EE\u5F55",
      CLOSE: "\u5173\u95ED",
      SEARCH_FOLDERS_PLACEHOLDER: "\u641C\u7D22\u76EE\u5F55...",
      NO_MATCHING_FOLDERS: "\u6CA1\u6709\u5339\u914D\u7684\u76EE\u5F55",
      IMPORT: "\u5BFC\u5165",
      SELECT_FOLDER_FIRST: "\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u76EE\u5F55",
      // ReferenceModal
      REFERENCE_MODAL_TITLE: "\u6DFB\u52A0\u5F15\u7528\u5185\u5BB9",
      REFERENCE_CONTENT: "\u5F15\u7528\u5185\u5BB9",
      REFERENCE_CONTENT_DESC: "\u8BF7\u8F93\u5165\u5F15\u7528\u5185\u5BB9\u7684\u8BE6\u7EC6\u4FE1\u606F",
      // ConfirmModal
      // NamePromptModal
      NAME_LABEL: "\u540D\u79F0",
      CONFIRM: "\u786E\u5B9A",
      CANCEL: "\u53D6\u6D88",
      // TemplateEditModal
      TEMPLATE_EDIT_TITLE: "\u7F16\u8F91\u6A21\u677F",
      TEMPLATE_CREATE_TITLE: "\u65B0\u5EFA\u6A21\u677F",
      TEMPLATE_NAME: "\u6A21\u677F\u540D\u79F0",
      TEMPLATE_NAME_PLACEHOLDER: "\u8BF7\u8F93\u5165\u6A21\u677F\u540D\u79F0",
      TEMPLATE_DESC: "\u6A21\u677F\u63CF\u8FF0",
      TEMPLATE_DESC_PLACEHOLDER: "\u53EF\u63CF\u8FF0\u6A21\u677F\u7684\u7B80\u8981\u7ED3\u6784",
      TEMPLATE_STRUCTURE: "\u7AE0\u8282\u6811",
      ADD_FILE: "\u6DFB\u52A0\u6587\u4EF6",
      ADD_FOLDER: "\u6DFB\u52A0\u6587\u4EF6\u5939",
      DELETE_FOLDER_CONFIRM: "\u786E\u5B9A\u8981\u5220\u9664\u6B64\u6587\u4EF6\u5939\u53CA\u5176\u6240\u6709\u5185\u5BB9\u5417\uFF1F",
      NEW_CHAPTER: "\u65B0\u7AE0\u8282",
      NEW_DIRECTORY: "\u65B0\u76EE\u5F55",
      ENTER_NAME_PLACEHOLDER: "\u8F93\u5165\u540D\u79F0",
      TEMPLATE_NAME_REQUIRED: "\u8BF7\u8F93\u5165\u6A21\u677F\u540D\u79F0",
      TEMPLATE_NODE_REQUIRED: "\u8BF7\u81F3\u5C11\u6DFB\u52A0\u4E00\u4E2A\u8282\u70B9",
      TEMPLATE_NAME_EXISTS: "\u5DF2\u5B58\u5728\u540C\u540D\u6A21\u677F\uFF0C\u8BF7\u4FEE\u6539\u6A21\u677F\u540D\u79F0",
      TEMPLATE_SAVE_SUCCESS: "\u6A21\u677F\u4FDD\u5B58\u6210\u529F",
      TEMPLATE_SAVE_FAILED: "\u4FDD\u5B58\u6A21\u677F\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u4E86\u89E3\u8BE6\u60C5"
    };
    managerTranslation = {
      // BookManager 相关
      BOOK_EXISTS: "\u4E66\u7C4D\u5DF2\u5B58\u5728",
      BOOK_NOT_FOUND: "\u4E66\u7C4D\u4E0D\u5B58\u5728",
      BOOK_FOLDER_NOT_FOUND: "\u4E66\u7C4D\u6587\u4EF6\u5939\u4E0D\u5B58\u5728",
      SAVE_CONFIG_FAILED: "\u4FDD\u5B58\u914D\u7F6E\u6587\u4EF6\u5931\u8D25",
      IMPORT_BOOK_FAILED: "\u5BFC\u5165\u4E66\u7C4D\u5931\u8D25",
      UNKNOWN_AUTHOR: "\u672A\u77E5\u4F5C\u8005",
      // TemplateManager 相关
      TEMPLATE_TYPE_NOT_FOUND: '\u6A21\u677F "{type}" \u4E0D\u5B58\u5728',
      TEMPLATE_EXISTS: "\u6A21\u677F\u5DF2\u5B58\u5728",
      TEMPLATE_SAVE_FAILED: "\u4FDD\u5B58\u6A21\u677F\u5931\u8D25",
      // FileManager 相关
      CREATE_FOLDER_FAILED: "\u521B\u5EFA\u6587\u4EF6\u5939\u5931\u8D25",
      CREATE_FILE_FAILED: "\u521B\u5EFA\u6587\u4EF6\u5931\u8D25",
      READ_FILE_FAILED: "\u8BFB\u53D6\u6587\u4EF6\u5931\u8D25",
      WRITE_FILE_FAILED: "\u5199\u5165\u6587\u4EF6\u5931\u8D25",
      // FocusManager 相关
      BREAK_TIME_START: "\u4F11\u606F\u65F6\u95F4\u5F00\u59CB",
      FOCUS_SUMMARY: "\u4E13\u6CE8\u7ED3\u675F\uFF01\n\u5B8C\u6210\u65F6\u95F4\uFF1A{duration}\u5206\u949F\n\u4E2D\u65AD\u6B21\u6570\uFF1A{interruptions}\u6B21\n\u672C\u6B21\u5B57\u6570\uFF1A{words}",
      // ReferenceManager 相关
      REFERENCE_FILE_NAME: "\u5F15\u7528\u4E66\u76EE.md",
      REFERENCE_FILE_NOT_FOUND: '\u8BF7\u5148\u5728\u4E66\u7C4D\u76EE\u5F55\u4E0B\u521B\u5EFA"\u5F15\u7528\u4E66\u76EE.md"\u6587\u4EF6',
      REFERENCE_FILE_ERROR: "\u5F15\u7528\u4E66\u76EE\u6587\u4EF6\u4E0D\u5B58\u5728\u6216\u7C7B\u578B\u9519\u8BEF",
      SELECT_TEXT_TO_REFERENCE: "\u8BF7\u9009\u62E9\u8981\u5F15\u7528\u7684\u6587\u672C",
      CHAPTER_INFO_ERROR: "\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u7AE0\u8282\u4FE1\u606F",
      // ReferenceManager 菜单项
      EDIT_REFERENCE: "\u7F16\u8F91\u5F53\u524D\u5F15\u7528",
      DELETE_REFERENCE: "\u5220\u9664\u5F53\u524D\u5F15\u7528",
      INSERT_REFERENCE: "\u63D2\u5165\u65B0\u5F15\u7528"
    };
    toolbarModalTranslation = {
      // CommunityModal
      COMMUNITY_TITLE: "\u521B\u4F5C\u793E\u533A",
      COMMUNITY_INTRO: "\u52A0\u5165\u4EBF\u4E07\u5199\u4F5C\u521B\u4F5C\u793E\u533A\uFF0C\u4E0E\u5176\u4ED6\u521B\u4F5C\u8005\u4EA4\u6D41\uFF0C\u83B7\u53D6\u5199\u4F5C\u7075\u611F\u548C\u53CD\u9988\u3002",
      FEATURE_SHARE_TITLE: "\u4F5C\u54C1\u5206\u4EAB",
      FEATURE_SHARE_DESC: "\u5206\u4EAB\u4F60\u7684\u521B\u4F5C\uFF0C\u83B7\u53D6\u8BFB\u8005\u53CD\u9988",
      FEATURE_DISCUSS_TITLE: "\u521B\u4F5C\u4EA4\u6D41",
      FEATURE_DISCUSS_DESC: "\u4E0E\u5176\u4ED6\u521B\u4F5C\u8005\u8BA8\u8BBA\u5199\u4F5C\u6280\u5DE7",
      FEATURE_CHALLENGE_TITLE: "\u5199\u4F5C\u6311\u6218",
      FEATURE_CHALLENGE_DESC: "\u53C2\u4E0E\u793E\u533A\u5199\u4F5C\u6311\u6218\uFF0C\u63D0\u5347\u521B\u4F5C\u80FD\u529B",
      JOIN_SECTION_TITLE: "\u52A0\u5165\u65B9\u5F0F",
      JOIN_SECTION_DESC: "\u590D\u5236\u4E0B\u65B9\u516C\u4F17\u53F7\uFF0C\u641C\u7D22\u5173\u6CE8",
      OFFICIAL_ACCOUNT: "\u516C\u4F17\u53F7\uFF1ABilionWrites",
      COPY_ACCOUNT: "\u590D\u5236\u516C\u4F17\u53F7",
      // ContactModal
      ABOUT_AUTHOR: "\u5173\u4E8E\u4F5C\u8005",
      AUTHOR_INTRO_1: "\u4F60\u597D\uFF0C\u6211\u662F\u3010\u591C\u534A\u3011\uFF0C\u4E00\u540D\u5168\u804C\u5199\u4F5C\u4E0E\u72EC\u7ACB\u5F00\u53D1\u8005\u3002",
      AUTHOR_INTRO_2_1: "\u8FD9\u6B3E\u63D2\u4EF6\u662F",
      AUTHOR_INTRO_2_2: "\u6211\u4E3A\u4E86\u5E2E\u52A9\u5728Obsidian\u4E2D\u8FDB\u884C\u957F\u7BC7\u521B\u4F5C\u7684\u4F5C\u8005\u800C\u5F00\u53D1\u7684\u5DE5\u5177",
      AUTHOR_INTRO_2_3: "\uFF0C\u5E0C\u671B\u80FD",
      AUTHOR_INTRO_2_4: "\u8BA9\u4F60\u7684\u5199\u4F5C\u8FC7\u7A0B\u66F4\u6D41\u7545\uFF0C\u521B\u4F5C\u4F53\u9A8C\u66F4\u6109\u60A6",
      AUTHOR_INTRO_2_5: "\u3002",
      AUTHOR_INTRO_3: "\u5982\u679C\u8FD9\u6B3E\u63D2\u4EF6\u5BF9\u4F60\u7684\u5199\u4F5C\u6709\u6240\u5E2E\u52A9\uFF0C\u6216\u8005\u4F60\u613F\u610F\u652F\u6301\u6211\u7684\u72EC\u7ACB\u5F00\u53D1\u4E0E\u521B\u4F5C\uFF0C\u6B22\u8FCE\u8BF7\u6211\u559D\u5496\u5561\u2615\u3002",
      AUTHOR_INTRO_4_1: "\u4F60\u7684\u652F\u6301\u610F\u4E49\u91CD\u5927",
      AUTHOR_INTRO_4_2: "\uFF0C\u5B83\u80FD\u8BA9\u6211\u66F4\u4E13\u6CE8\u5730\u5F00\u53D1\u66F4\u591A\u5B9E\u7528\u5DE5\u5177\uFF0C\u52A9\u529B\u4F60\u7684\u521B\u4F5C\u4E4B\u65C5\u3002",
      DONATE_TEXT: "\u5982\u9700\u652F\u6301\u4F5C\u8005\uFF1A",
      DONATE_BUTTON: "\u8D5E\u8D4F\u652F\u6301",
      MORE_INFO_TEXT: "\u5982\u679C\u4F60\u60F3\u4E86\u89E3\u66F4\u591A\u5173\u4E8E\u5199\u4F5C\u3001\u521B\u4F5C\u6280\u5DE7\u7684\u5185\u5BB9\uFF0C\u6216\u8005\u5173\u6CE8\u6211\u672A\u6765\u7684\u4F5C\u54C1\u52A8\u6001\uFF0C\u6B22\u8FCE\u5173\u6CE8\u6211\u7684\u793E\u4EA4\u5A92\u4F53\u3002",
      CONTACT_TITLE: "\u8054\u7CFB\u65B9\u5F0F\uFF1A",
      CONTACT_WECHAT_OFFICIAL: "\u516C\u4F17\u53F7",
      CONTACT_XIAOHONGSHU: "\u5C0F\u7EA2\u4E66",
      CONTACT_WECHAT: "\u5FAE\u4FE1",
      CONTACT_GITHUB: "GitHub",
      COPY_SUCCESS: "{type}\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
      COPY_FAILED: "\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u590D\u5236\uFF1A{value}",
      // DonateModal
      DONATE_MODAL_TITLE: "\u7B14\u58A8\u6709\u60C5",
      COMMUNITY_STATS_TITLE: "\u793E\u533A\u6570\u636E",
      COMMUNITY_STATS_USERS: "\u5DF2\u6709 1200+ \u7528\u6237\uFF0C32\u4F4D\u652F\u6301\u8005",
      COMMUNITY_STATS_WORDS: "\u5E73\u5747\u6BCF\u5929\u521B\u4F5C 5000+ \u5B57",
      DONATE_AMOUNT_COFFEE: "\u6696\u5FC3\u5496\u5561",
      DONATE_AMOUNT_CHAPTER: "\u7AE0\u8282\u8D5E\u52A9",
      DONATE_AMOUNT_FEATURE: "\u529F\u80FD\u5171\u5EFA",
      DONATE_FEEDBACK_COFFEE: "\u611F\u8C22\u60A8\u7684\u5496\u5561\u8D5E\u52A9\uFF01",
      DONATE_FEEDBACK_CHAPTER: "\u7ED9\u60A8\u4E00\u6B21\u65B0\u529F\u80FD\u6295\u7968\u6743",
      DONATE_FEEDBACK_FEATURE: "\u9080\u8BF7\u60A8\u52A0\u5165\u5185\u6D4B\u793E\u7FA4\uFF0C\u516C\u4F17\u53F7\u94FE\u63A5\u6211",
      PAYMENT_WECHAT: "\u5FAE\u4FE1\u8D5E\u8D4F",
      PAYMENT_ALIPAY: "\u652F\u4ED8\u5B9D\u8D5E\u8D4F",
      PAYMENT_KOFI: "Ko-fi \u8D5E\u8D4F",
      CURRENCY_UNIT: "\u5143",
      // TypographyModal
      PREVIEW: "\u9884\u89C8",
      NO_BOOKS_AVAILABLE: "\u65E0\u4E66\u7C4D",
      LOADING: "\u52A0\u8F7D\u4E2D...",
      DEFAULT_FONT: "\u9ED8\u8BA4\u5B57\u4F53",
      SERIF_FONT: "\u886C\u7EBF\u5B57\u4F53",
      SANS_SERIF_FONT: "\u65E0\u886C\u7EBF\u5B57\u4F53",
      MONOSPACE_FONT: "\u7B49\u5BBD\u5B57\u4F53",
      SONGTI_FONT: "\u5B8B\u4F53",
      HEITI_FONT: "\u9ED1\u4F53",
      KAITI_FONT: "\u6977\u4F53",
      FANGSONG_FONT: "\u4EFF\u5B8B",
      APPLY: "\u5E94\u7528",
      TYPOGRAPHY_APPLIED: "\u6392\u7248\u8BBE\u7F6E\u5DF2\u5E94\u7528",
      EXPORT: "\u5BFC\u51FA",
      SELECT_BOOK_FIRST: "\u8BF7\u5148\u9009\u62E9\u4E00\u672C\u4E66\u7C4D",
      EXPORT_SUCCESS: "\u5BFC\u51FA\u6210\u529F",
      EXPORT_FAILED: "\u5BFC\u51FA\u5931\u8D25: ",
      FORMAT: "\u683C\u5F0F",
      CUSTOM_SIZE: "\u81EA\u5B9A\u4E49\u5927\u5C0F",
      SELECT_EXPORT_FORMAT: "\u9009\u62E9\u5BFC\u51FA\u683C\u5F0F",
      // CoverModal
      DESIGN_COVER: "\u8BBE\u8BA1\u5C01\u9762",
      SHOW_COVER: "\u663E\u793A\u5C01\u9762",
      COVER_DESIGN: "\u5C01\u9762\u8BBE\u8BA1",
      COVER_IMAGE: "\u5C01\u9762\u56FE\u7247",
      CLEAR_IMAGE: "\u6E05\u9664\u56FE\u7247",
      BACKGROUND_COLOR: "\u80CC\u666F\u989C\u8272",
      OVERLAY: "\u8986\u76D6\u5C42",
      OVERLAY_DESC: "\u6DFB\u52A0\u534A\u900F\u660E\u8986\u76D6\u5C42\u4EE5\u589E\u5F3A\u6587\u5B57\u53EF\u8BFB\u6027",
      OVERLAY_OPACITY: "\u8986\u76D6\u5C42\u900F\u660E\u5EA6",
      SCALE: "\u7F29\u653E"
    };
    componentTranslation = {
      // ChapterTree
      NEW_FILE: "\u65B0\u5EFA\u6587\u4EF6",
      NEW_FOLDER: "\u65B0\u5EFA\u6587\u4EF6\u5939",
      ENTER_FILE_NAME: "\u8BF7\u8F93\u5165\u6587\u4EF6\u540D",
      ENTER_FOLDER_NAME: "\u8BF7\u8F93\u5165\u6587\u4EF6\u5939\u540D",
      OPEN_IN_NEW_TAB: "\u5728\u65B0\u6807\u7B7E\u9875\u4E2D\u6253\u5F00",
      OPEN_IN_NEW_PANE: "\u5728\u65B0\u6807\u7B7E\u7EC4\u4E2D\u6253\u5F00",
      MARK_AS_COMPLETE: "\u6807\u8BB0\u5B8C\u6210\u7AE0\u8282",
      MARK_AS_DRAFT: "\u6807\u8BB0\u91CD\u65B0\u521B\u4F5C",
      EXCLUDE_FROM_STATS: "\u6392\u9664\u5728\u7EDF\u8BA1\u4E0E\u5BFC\u51FA\u5916",
      INCLUDE_IN_STATS: "\u5305\u542B\u5728\u7EDF\u8BA1\u4E0E\u5BFC\u51FA\u4E2D",
      CREATE_COPY: "\u521B\u5EFA\u526F\u672C",
      COPY_NAME: "{name} \u526F\u672C",
      RENAME: "\u91CD\u547D\u540D",
      DELETE: "\u5220\u9664",
      DELETE_FILE_TITLE: "\u5220\u9664\u6587\u4EF6",
      DELETE_FILE_DESC: '\u786E\u5B9A\u8981\u5220\u9664\u6587\u4EF6 "{title}" \u5417\uFF1F\n\u5B83\u5C06\u88AB\u79FB\u52A8\u5230\u7CFB\u7EDF\u56DE\u6536\u7AD9\u3002',
      DELETE_FOLDER_TITLE: "\u5220\u9664\u6587\u4EF6\u5939",
      DELETE_FOLDER_DESC: '\u786E\u5B9A\u8981\u5220\u9664\u6587\u4EF6\u5939 "{title}" \u53CA\u5176\u6240\u6709\u5185\u5BB9\u5417\uFF1F\n\u5B83\u4EEC\u5C06\u88AB\u79FB\u52A8\u5230\u7CFB\u7EDF\u56DE\u6536\u7AD9\u3002',
      COPY_SUCCESS: "\u521B\u5EFA\u526F\u672C\u6210\u529F",
      COPY_FAILED: "\u521B\u5EFA\u526F\u672C\u5931\u8D25: {error}",
      RENAME_SUCCESS: "\u91CD\u547D\u540D\u6210\u529F",
      RENAME_FAILED: "\u91CD\u547D\u540D\u5931\u8D25: {error}",
      DELETE_SUCCESS: "\u5220\u9664\u6210\u529F",
      DELETE_FAILED: "\u5220\u9664\u5931\u8D25: {error}",
      MOVE_FAILED: "\u79FB\u52A8\u5931\u8D25",
      SOURCE_NOT_FOUND: "\u6E90\u6587\u4EF6\u4E0D\u5B58\u5728",
      TARGET_EXISTS: "\u76EE\u6807\u4F4D\u7F6E\u5DF2\u5B58\u5728\u540C\u540D\u6587\u4EF6",
      TARGET_FOLDER_NOT_FOUND: "\u76EE\u6807\u6587\u4EF6\u5939\u4E0D\u5B58\u5728",
      EXCLUDED_NOTICE: '\u5DF2\u5C06"{title}"\u6392\u9664',
      INCLUDED_NOTICE: '\u5DF2\u5C06"{title}"\u5305\u542B',
      ENTER_NEW_NAME: "\u8BF7\u8F93\u5165\u65B0\u540D\u79F0",
      // FocusToolView
      FOCUS_MODE: "\u4E13\u6CE8\u6A21\u5F0F",
      START_FOCUS: "\u5F00\u59CB\u4E13\u6CE8",
      EXIT: "\u9000\u51FA",
      FOCUS_SESSIONS: "\u4E13\u6CE8\u6B21\u6570",
      INTERRUPTIONS: "\u4E2D\u65AD\u6B21\u6570",
      CURRENT_WORDS: "\u5F53\u524D\u5B57\u6570",
      WORD_GOAL: "\u76EE\u6807\u5B57\u6570",
      TOTAL_FOCUS_WORDS: "\u4E13\u6CE8\u603B\u5B57\u6570",
      PAUSE: "\u6682\u505C",
      RESUME: "\u7EE7\u7EED",
      END: "\u7ED3\u675F",
      ENCOURAGEMENT_1: "\u{1F389} \u592A\u68D2\u4E86\uFF01\u5DF2\u8FBE\u5230\u76EE\u6807\u5B57\u6570\uFF01\u7EE7\u7EED\u4FDD\u6301\uFF5E",
      ENCOURAGEMENT_2: "\u2728 \u5389\u5BB3\uFF01\u76EE\u6807\u8FBE\u6210\uFF01\u8BA9\u6211\u4EEC\u7EE7\u7EED\u524D\u8FDB\uFF01",
      ENCOURAGEMENT_3: "\u{1F31F} \u5B8C\u7F8E\uFF01\u8FBE\u5230\u76EE\u6807\u4E86\uFF01\u4FDD\u6301\u8FD9\u4EFD\u70ED\u60C5\uFF01",
      ENCOURAGEMENT_4: "\u{1F3AF} \u76EE\u6807\u8FBE\u6210\uFF01\u4F60\u7684\u575A\u6301\u503C\u5F97\u8868\u626C\uFF01",
      ENCOURAGEMENT_5: "\u{1F4AA} \u51FA\u8272\u7684\u8868\u73B0\uFF01\u76EE\u6807\u5B8C\u6210\uFF01\u518D\u63A5\u518D\u5389\uFF01",
      EXIT_FOCUS: "\u9000\u51FA\u4E13\u6CE8",
      EXIT_FOCUS_DESC: "\u786E\u5B9A\u8981\u9000\u51FA\u4E13\u6CE8\u5417\uFF1F\u5F53\u524D\u4E13\u6CE8\u8FDB\u5EA6\u5C06\u4F1A\u4E22\u5931\u3002",
      END_FOCUS: "\u7ED3\u675F\u4E13\u6CE8",
      END_FOCUS_DESC: "\u786E\u5B9A\u8981\u7ED3\u675F\u4E13\u6CE8\u5417\uFF1F\u8FD9\u5C06\u8BA1\u5165\u4E2D\u65AD\u6B21\u6570\u3002",
      FOCUSING: "\u4E13\u6CE8\u4E2D",
      PAUSED: "\u5DF2\u6682\u505C",
      BREAK_TIME: "\u4F11\u606F\u65F6\u95F4",
      READY_TO_START: "\u51C6\u5907\u5F00\u59CB"
    };
    translation = {
      ...commonTranslation,
      ...bookSmithViewTranslation,
      ...toolViewTranslation,
      ...settingsTranslation,
      ...modalTranslation,
      ...managerTranslation,
      ...toolbarModalTranslation,
      ...componentTranslation
    };
    zh_CN_default = translation;
  }
});

// src/i18n/locales/en.ts
var en_exports = {};
__export(en_exports, {
  default: () => en_default
});
var commonTranslation2, bookSmithViewTranslation2, toolViewTranslation2, settingsTranslation2, modalTranslation2, managerTranslation2, toolbarModalTranslation2, componentTranslation2, translation2, en_default;
var init_en = __esm({
  "src/i18n/locales/en.ts"() {
    commonTranslation2 = {
      PLUGIN_NAME: "BookSmith",
      SETTINGS: "Settings",
      SAVE: "Save",
      CANCEL: "Cancel",
      HIDE: "Hide",
      SHOW: "Show",
      OPEN_BOOK_PANEL: "Open book panel",
      OPEN_TOOL_PANEL: "Open tool panel",
      OPEN_ALL_PANELS: "Open all panels",
      PREFACE: "Preface",
      OUTLINE: "Outline",
      VOLUME_1: "Volume 1",
      CHAPTER_1: "Chapter 1",
      CHAPTER_2: "Chapter 2",
      AFTERWORD: "Afterword",
      TEMPLATE_OPTIONS_DESC: "Standard structure with preface, outline, chapters and afterword"
    };
    bookSmithViewTranslation2 = {
      // 主界面
      BOOK_MANAGER: "Book manager",
      NEW_BOOK: "New",
      SWITCH_BOOK: "Switch",
      MANAGE_BOOK: "Manage",
      // 书籍相关
      BOOK_TITLE: "Title",
      BOOK_AUTHOR: "Author",
      BOOK_DESCRIPTION: "Description",
      BOOK_TAGS: "Tags",
      BOOK_COVER: "Cover",
      // 章节相关
      CHAPTER: "Chapter",
      ADD_CHAPTER: "Add chapter",
      DELETE_CHAPTER: "Delete chapter",
      RENAME_CHAPTER: "Rename chapter",
      // 统计相关
      STATS: "Statistics",
      WORD_COUNT: "Word count",
      CHAPTER_COUNT: "Chapter count",
      // 帮助提示
      HELP_TOOLTIP: `\u{1F44B} Welcome to BookSmith

\u{1F680} Getting Started
\u2022 Open the Writing Toolbox on the right to activate writing assistance
\u2022 Access Focus Mode, Statistics, Reference Management with one click

\u{1F4DA} Book Management
\u2022 Create: Choose templates to create book projects
\u2022 Switch: Freely switch between different works
\u2022 Manage: Import and edit your collection
\u2022 Templates: Customize your writing framework

\u{1F4D1} Chapter Organization
\u2022 Tree Structure: Visualize your book hierarchy
\u2022 Drag & Drop: Flexibly adjust chapter order
\u2022 Status Markers: Track writing progress
\u2022 Context Menu: Convenient chapter operations

\u26A1\uFE0F Writing Assistant
\u2022 Real-time Stats: Word count and progress updates
\u2022 Data Analysis: In-depth writing habit statistics
\u2022 Focus Mode: Improve writing efficiency

\u{1F4A1} Tips
\u2022 Support for custom writing templates
\u2022 Quickly adjust chapters via drag & drop
\u2022 Right-click for more operations

\u2728 May BookSmith bring joy to your creative journey.

\u{1F49D} Support
If BookSmith helps you, please consider supporting
the developer via the "Donate" button in the Writing Toolbox.`,
      // 通知消息
      SWITCHED_TO_BOOK: 'Switched to "{title}"',
      IMPORTED_AND_SWITCHED: "Imported and switched to new book",
      CURRENT_BOOK_DELETED: "Current book has been deleted",
      NO_BOOKS_TO_SWITCH: "No books available to switch",
      // 统计文本
      TODAY_WORDS: "Today",
      TOTAL_WORDS: "Total words",
      CHAPTER_COMPLETION: "Completion",
      WRITING_DAYS: "Writing days",
      AVERAGE_DAILY_WORDS: "Daily average",
      WORD_UNIT: " words",
      DAY_UNIT: " days",
      TEN_THOUSAND: "K",
      // 空状态提示
      WELCOME_MESSAGE: "\u{1F44B} Welcome to BookSmith",
      EMPTY_STATE_HINT: 'Click "New" above to create a work, or use the "Switch" button to select an existing book'
    };
    toolViewTranslation2 = {
      WRITING_TOOLBOX: "Writing toolbox",
      // 写作助手
      WRITING_ASSISTANT: "Writing assistant",
      FOCUS_MODE: "Focus mode",
      CREATIVE_INSPIRATION: "Creative inspiration",
      CHARACTER_PROFILES: "Character profiles",
      WORLD_BUILDING: "World building",
      // 导出发布
      EXPORT_PUBLISH: "Export & publish",
      DESIGN_TYPOGRAPHY: "Generate e-book",
      GENERATE_EBOOK: "Generate e-book",
      MORE_FEATURES: "More features...",
      MORE_FEATURES_MESSAGE: "More features coming with your participation",
      // 写作圈子
      WRITING_COMMUNITY: "Writing community",
      CREATIVE_COMMUNITY: "Creative community",
      CONTACT_AUTHOR: "Contact author",
      DONATE_SUPPORT: "Donate & support",
      // 面板设置
      PANEL_SETTINGS: "Panel settings",
      FEATURE_COMING_SOON: "{feature} feature coming soon"
    };
    settingsTranslation2 = {
      PLUGIN_NAME: "Book Smith",
      BASIC_OPTIONS: "Basic options",
      TEMPLATE_OPTIONS: "Template options",
      WRITING_TOOLS_OPTIONS: "Writing tools options",
      // Basic Settings
      LANGUAGE_SETTING: "Language",
      LANGUAGE_DESC: "Choose plugin language / \u9009\u62E9\u63D2\u4EF6\u754C\u9762\u8BED\u8A00",
      DEFAULT_AUTHOR: "Default author",
      DEFAULT_AUTHOR_DESC: "Default author name for new books",
      DEFAULT_AUTHOR_PLACEHOLDER: "Enter default author name",
      BOOK_STORAGE_PATH: "Book storage path",
      BOOK_STORAGE_DESC: "Default storage path for new books",
      STORAGE_PATH_CHANGED: "Storage path changed, please restart Obsidian or reload for changes to take effect",
      // Template Settings
      DEFAULT_TEMPLATE: "Default template",
      DEFAULT_TEMPLATE_DESC: "Default template used when creating new books",
      BOOK_TEMPLATES: "Book templates",
      ADD_NEW_TEMPLATE: "Add new template",
      EDIT_TEMPLATE: "Edit template",
      DELETE_TEMPLATE: "Delete template",
      DELETE_TEMPLATE_TITLE: "Delete template",
      DELETE_TEMPLATE_DESC: "Are you sure you want to delete this template? This action cannot be undone.",
      // Writing Tools Settings
      FOCUS_MODE_OPTIONS: "Focus mode options",
      FOCUS_DURATION: "Focus duration",
      FOCUS_DURATION_DESC: "Work duration for each focus session (minutes)",
      BREAK_DURATION: "Break duration",
      BREAK_DURATION_DESC: "Break duration after each focus session (minutes)",
      WORD_GOAL: "Word goal",
      WORD_GOAL_DESC: "Target word count for each focus session"
    };
    modalTranslation2 = {
      // Common
      COVER: "Cover",
      COVER_DESC: "Select cover image (optional)",
      BOOK_TITLE: "Title",
      BOOK_TITLE_DESC: "Please enter book title",
      BOOK_TITLE_PLACEHOLDER: "Book title",
      SUBTITLE: "Subtitle",
      SUBTITLE_DESC: "Optional",
      SUBTITLE_PLACEHOLDER: "Subtitle",
      TARGET_WORDS: "Target word count",
      TARGET_WORDS_DESC: "Set estimated total word count (in 10k)",
      TARGET_WORDS_PLACEHOLDER: "e.g., 20 or 20.0",
      AUTHOR: "Author",
      AUTHOR_DESC: "Enter author names, separate multiple authors with commas",
      AUTHOR_PLACEHOLDER: "Author",
      DESCRIPTION: "Description",
      DESCRIPTION_DESC: "Please enter book description",
      DESCRIPTION_PLACEHOLDER: "Book description",
      REQUIRED_FIELDS: "Please fill in required fields",
      // CreateBookModal
      CREATE_BOOK_TITLE: "Create new book",
      BOOK_TEMPLATE: "Template",
      TEMPLATE_CHECK_DESC: "Please select a book template",
      SELECT_IMAGE: "Select image",
      COVER_UPLOAD_SUCCESS: "Cover uploaded successfully",
      COVER_UPLOAD_FAILED: "Cover upload failed: ",
      CREATE: "Create",
      CREATE_SUCCESS: "Book created successfully",
      CREATE_FAILED: "Creation failed: ",
      // EditBookModal
      EDIT_BOOK_TITLE: "Edit book",
      CHANGE_COVER: "Change cover",
      SELECT_COVER: "Select cover",
      COVER_UPDATE_SUCCESS: "Cover updated successfully",
      COVER_UPDATE_FAILED: "Failed to update cover: ",
      SAVE: "Save",
      SAVE_SUCCESS: "Saved successfully",
      SAVE_FAILED: "Save failed: ",
      // ManageBooksModal
      MANAGE_BOOKS_TITLE: "Manage books",
      SEARCH_BOOKS_PLACEHOLDER: "Search books...",
      IMPORT_BOOK: "Import book",
      BOOK_AUTHOR_PREFIX: "Author: ",
      BOOK_DESC_PREFIX: "\nDescription: ",
      BOOK_PROGRESS_PREFIX: "\nProgress: ",
      DELETE_BOOK: "Delete",
      EDIT_BOOK: "Edit",
      DELETE_BOOK_TITLE: "Delete book",
      DELETE_BOOK_DESC: 'Are you sure you want to delete "{title}"?\nThis action cannot be undone.',
      DELETE_SUCCESS: "Deleted successfully",
      DELETE_FAILED: "Delete failed: ",
      BOOKS_ROOT_NOT_FOUND: "Books root directory does not exist or is inaccessible",
      NO_UNIMPORTED_BOOKS: "No unimported book directories found",
      DETECT_UNIMPORTED_FAILED: "Failed to detect unimported books: ",
      IMPORT_SUCCESS: 'Successfully imported book "{title}"',
      IMPORT_FAILED: "Failed to create book configuration: ",
      // SwitchBookModal
      SWITCH_BOOK_TITLE: "Switch book",
      SEARCH_BOOK_PLACEHOLDER: "Search books...",
      BOOK_AUTHOR_LABEL: "Author",
      BOOK_PROGRESS_LABEL: "Progress",
      BOOK_WORDCOUNT_LABEL: "Words",
      BOOK_LASTMOD_LABEL: "Last modified",
      SELECT_BOOK: "Select",
      // UnimportedBooksModal
      UNIMPORTED_BOOKS_TITLE: "Select book directory to import",
      NO_UNIMPORTED_FOLDERS: "No unimported book directories found",
      CLOSE: "Close",
      SEARCH_FOLDERS_PLACEHOLDER: "Search directories...",
      NO_MATCHING_FOLDERS: "No matching directories",
      IMPORT: "Import",
      SELECT_FOLDER_FIRST: "Please select a directory first",
      // ReferenceModal
      REFERENCE_MODAL_TITLE: "Add reference",
      REFERENCE_CONTENT: "Reference content",
      REFERENCE_CONTENT_DESC: "Please enter the details of the reference",
      // NamePromptModal
      NAME_LABEL: "Name",
      CONFIRM: "Confirm",
      CANCEL: "Cancel",
      // TemplateEditModal
      TEMPLATE_EDIT_TITLE: "Edit template",
      TEMPLATE_CREATE_TITLE: "Create template",
      TEMPLATE_NAME: "Template name",
      TEMPLATE_NAME_PLACEHOLDER: "Enter template name",
      TEMPLATE_DESC: "Template description",
      TEMPLATE_DESC_PLACEHOLDER: "Describe the template structure",
      TEMPLATE_STRUCTURE: "Chapter tree",
      ADD_FILE: "Add file",
      ADD_FOLDER: "Add folder",
      DELETE_FOLDER_CONFIRM: "Are you sure you want to delete this folder and all its contents?",
      NEW_CHAPTER: "New chapter",
      NEW_DIRECTORY: "New directory",
      ENTER_NAME_PLACEHOLDER: "Enter name",
      TEMPLATE_NAME_REQUIRED: "Please enter template name",
      TEMPLATE_NODE_REQUIRED: "Please add at least one node",
      TEMPLATE_NAME_EXISTS: "Template with this name already exists",
      TEMPLATE_SAVE_SUCCESS: "Template saved successfully",
      TEMPLATE_SAVE_FAILED: "Failed to save template, check console for details"
    };
    managerTranslation2 = {
      // BookManager related
      BOOK_EXISTS: "Book already exists",
      BOOK_NOT_FOUND: "Book not found",
      BOOK_FOLDER_NOT_FOUND: "Book folder not found",
      SAVE_CONFIG_FAILED: "Failed to save configuration file",
      IMPORT_BOOK_FAILED: "Failed to import book",
      UNKNOWN_AUTHOR: "Unknown author",
      // TemplateManager related
      TEMPLATE_TYPE_NOT_FOUND: 'Template "{type}" does not exist',
      TEMPLATE_EXISTS: "Template already exists",
      TEMPLATE_SAVE_FAILED: "Failed to save template",
      // FileManager related
      CREATE_FOLDER_FAILED: "Failed to create folder",
      CREATE_FILE_FAILED: "Failed to create file",
      READ_FILE_FAILED: "Failed to read file",
      WRITE_FILE_FAILED: "Failed to write file",
      // FocusManager related
      BREAK_TIME_START: "Break time started",
      FOCUS_SUMMARY: "Focus completed!\nDuration: {duration} minutes\nInterruptions: {interruptions}\nWords written: {words}",
      // ReferenceManager 相关
      REFERENCE_FILE_NAME: "references.md",
      REFERENCE_FILE_NOT_FOUND: 'Please create "references.md" file in the book directory first',
      REFERENCE_FILE_ERROR: "Reference file does not exist or type error",
      SELECT_TEXT_TO_REFERENCE: "Please select text to reference",
      CHAPTER_INFO_ERROR: "Unable to get current chapter information",
      // ReferenceManager 菜单项
      EDIT_REFERENCE: "Edit reference",
      DELETE_REFERENCE: "Delete reference",
      INSERT_REFERENCE: "Insert reference"
    };
    toolbarModalTranslation2 = {
      // CommunityModal
      COMMUNITY_TITLE: "Writing community",
      COMMUNITY_INTRO: "Join the Billion Writes community to connect with other writers, get inspiration and feedback.",
      FEATURE_SHARE_TITLE: "Share works",
      FEATURE_SHARE_DESC: "Share your creations and get reader feedback",
      FEATURE_DISCUSS_TITLE: "Writing exchange",
      FEATURE_DISCUSS_DESC: "Discuss writing techniques with other creators",
      FEATURE_CHALLENGE_TITLE: "Writing challenges",
      FEATURE_CHALLENGE_DESC: "Participate in community writing challenges to improve your skills",
      JOIN_SECTION_TITLE: "How to join",
      JOIN_SECTION_DESC: "Copy and search the official account below",
      OFFICIAL_ACCOUNT: "Official account: BilionWrites",
      COPY_ACCOUNT: "Copy account",
      // ContactModal
      ABOUT_AUTHOR: "About author",
      AUTHOR_INTRO_1: "Hello, I'm Yeban, a full-time writer and independent developer.",
      AUTHOR_INTRO_2_1: "This plugin is ",
      AUTHOR_INTRO_2_2: "a tool I developed to help authors write long-form content in Obsidian",
      AUTHOR_INTRO_2_3: ", hoping to ",
      AUTHOR_INTRO_2_4: "make your writing process smoother and more enjoyable",
      AUTHOR_INTRO_2_5: ".",
      AUTHOR_INTRO_3: "If this plugin helps with your writing, or if you'd like to support my independent development and creation, feel free to buy me a coffee \u2615.",
      AUTHOR_INTRO_4_1: "Your support means a lot",
      AUTHOR_INTRO_4_2: ", it allows me to focus on developing more useful tools to aid your creative journey.",
      DONATE_TEXT: "Support the author:",
      DONATE_BUTTON: "Support",
      MORE_INFO_TEXT: "If you want to learn more about writing, creative techniques, or follow my future work updates, welcome to follow my social media.",
      CONTACT_TITLE: "Contact:",
      CONTACT_WECHAT_OFFICIAL: "WeChat official",
      CONTACT_XIAOHONGSHU: "Xiaohongshu",
      CONTACT_WECHAT: "WeChat",
      CONTACT_GITHUB: "GitHub",
      COPY_SUCCESS: "{type} copied to clipboard",
      COPY_FAILED: "Copy failed, please copy manually: {value}",
      // DonateModal
      DONATE_MODAL_TITLE: "Support me",
      COMMUNITY_STATS_TITLE: "Community stats",
      COMMUNITY_STATS_USERS: "1200+ users, 32 supporters",
      COMMUNITY_STATS_WORDS: "5000+ words written daily",
      DONATE_AMOUNT_COFFEE: "Buy me a coffee",
      DONATE_AMOUNT_CHAPTER: "Chapter sponsor",
      DONATE_AMOUNT_FEATURE: "Feature builder",
      DONATE_FEEDBACK_COFFEE: "Thanks for your coffee support!",
      DONATE_FEEDBACK_CHAPTER: "You get one vote for new features",
      DONATE_FEEDBACK_FEATURE: "Join our beta testing group, contact via WeChat official account",
      PAYMENT_WECHAT: "WeChat pay",
      PAYMENT_ALIPAY: "Alipay",
      PAYMENT_KOFI: "Ko-fi",
      CURRENCY_UNIT: "CNY",
      // TypographyModal
      PREVIEW: "Preview",
      NO_BOOKS_AVAILABLE: "No books available",
      LOADING: "Loading...",
      DEFAULT_FONT: "Default font",
      SERIF_FONT: "Serif font",
      SANS_SERIF_FONT: "Sans-serif font",
      MONOSPACE_FONT: "Monospace font",
      SONGTI_FONT: "Songti font",
      HEITI_FONT: "Heiti font",
      KAITI_FONT: "Kaiti font",
      FANGSONG_FONT: "Fangsong font",
      APPLY: "Apply",
      TYPOGRAPHY_APPLIED: "Typography applied",
      EXPORT: "Export",
      SELECT_BOOK_FIRST: "Please select a book first",
      EXPORT_SUCCESS: "Export successful",
      EXPORT_FAILED: "Export failed: ",
      FORMAT: "Format",
      CUSTOM_SIZE: "Custom size",
      SELECT_EXPORT_FORMAT: "Select export format",
      // CoverModal
      DESIGN_COVER: "Design cover",
      SHOW_COVER: "Show cover",
      COVER_DESIGN: "Cover design",
      COVER_IMAGE: "Cover image",
      CLEAR_IMAGE: "Clear image",
      BACKGROUND_COLOR: "Background color",
      OVERLAY: "Overlay",
      OVERLAY_DESC: "Add an overlay to the cover",
      OVERLAY_OPACITY: "Overlay opacity",
      SCALE: "Scale"
    };
    componentTranslation2 = {
      // ChapterTree
      NEW_FILE: "New file",
      NEW_FOLDER: "New folder",
      ENTER_FILE_NAME: "Enter file name",
      ENTER_FOLDER_NAME: "Enter folder name",
      OPEN_IN_NEW_TAB: "Open in new tab",
      OPEN_IN_NEW_PANE: "Open in new pane",
      MARK_AS_COMPLETE: "Mark as complete",
      MARK_AS_DRAFT: "Mark as draft",
      EXCLUDE_FROM_STATS: "Exclude from stats",
      INCLUDE_IN_STATS: "Include in stats",
      CREATE_COPY: "Create copy",
      COPY_NAME: "{name} copy",
      RENAME: "Rename",
      DELETE: "Delete",
      DELETE_FILE_TITLE: "Delete file",
      DELETE_FILE_DESC: 'Are you sure you want to delete "{title}"?\nIt will be moved to system trash.',
      DELETE_FOLDER_TITLE: "Delete folder",
      DELETE_FOLDER_DESC: 'Are you sure you want to delete folder "{title}" and all its contents?\nThey will be moved to system trash.',
      COPY_SUCCESS: "Copy created successfully",
      COPY_FAILED: "Failed to create copy: {error}",
      RENAME_SUCCESS: "Renamed successfully",
      RENAME_FAILED: "Failed to rename: {error}",
      DELETE_SUCCESS: "Deleted successfully",
      DELETE_FAILED: "Failed to delete: {error}",
      MOVE_FAILED: "Failed to move",
      SOURCE_NOT_FOUND: "Source file not found",
      TARGET_EXISTS: "File with same name exists at target location",
      TARGET_FOLDER_NOT_FOUND: "Target folder not found",
      EXCLUDED_NOTICE: '"{title}" has been excluded',
      INCLUDED_NOTICE: '"{title}" has been included',
      ENTER_NEW_NAME: "Enter new name",
      // FocusToolView
      FOCUS_MODE: "Focus mode",
      START_FOCUS: "Start focus",
      EXIT: "Exit",
      FOCUS_SESSIONS: "Focus sessions",
      INTERRUPTIONS: "Interruptions",
      CURRENT_WORDS: "Current words",
      WORD_GOAL: "Word goal",
      TOTAL_FOCUS_WORDS: "Total focus words",
      PAUSE: "Pause",
      RESUME: "Resume",
      END: "End",
      ENCOURAGEMENT_1: "\u{1F389} Amazing! You've reached your word goal! Keep it up~",
      ENCOURAGEMENT_2: "\u2728 Excellent! Goal achieved! Let's keep moving forward!",
      ENCOURAGEMENT_3: "\u{1F31F} Perfect! Goal reached! Maintain this enthusiasm!",
      ENCOURAGEMENT_4: "\u{1F3AF} Goal achieved! Your persistence is admirable!",
      ENCOURAGEMENT_5: "\u{1F4AA} Outstanding performance! Goal completed! Keep going!",
      EXIT_FOCUS: "Exit focus",
      EXIT_FOCUS_DESC: "Are you sure you want to exit? Current focus progress will be lost.",
      END_FOCUS: "End focus",
      END_FOCUS_DESC: "Are you sure you want to end focus? This will count as an interruption.",
      FOCUSING: "Focusing",
      PAUSED: "Paused",
      BREAK_TIME: "Break time",
      READY_TO_START: "Ready to start"
    };
    translation2 = {
      ...commonTranslation2,
      ...bookSmithViewTranslation2,
      ...toolViewTranslation2,
      ...settingsTranslation2,
      ...modalTranslation2,
      ...managerTranslation2,
      ...toolbarModalTranslation2,
      ...componentTranslation2
    };
    en_default = translation2;
  }
});

// node_modules/pdf-lib/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/pdf-lib/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/pdf-lib/cjs/utils/base64.js
var require_base64 = __commonJS({
  "node_modules/pdf-lib/cjs/utils/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFromBase64DataUri = exports.decodeFromBase64 = exports.encodeToBase64 = void 0;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var i;
    exports.encodeToBase64 = function(bytes) {
      var base64 = "";
      var len = bytes.length;
      for (var i2 = 0; i2 < len; i2 += 3) {
        base64 += chars[bytes[i2] >> 2];
        base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
        base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
        base64 += chars[bytes[i2 + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports.decodeFromBase64 = function(base64) {
      var bufferLength = base64.length * 0.75;
      var len = base64.length;
      var i2;
      var p = 0;
      var encoded1;
      var encoded2;
      var encoded3;
      var encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var bytes = new Uint8Array(bufferLength);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup[base64.charCodeAt(i2)];
        encoded2 = lookup[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return bytes;
    };
    var DATA_URI_PREFIX_REGEX = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i;
    exports.decodeFromBase64DataUri = function(dataUri) {
      var trimmedUri = dataUri.trim();
      var prefix = trimmedUri.substring(0, 100);
      var res = prefix.match(DATA_URI_PREFIX_REGEX);
      if (!res)
        return exports.decodeFromBase64(trimmedUri);
      var fullMatch = res[0];
      var data = trimmedUri.substring(fullMatch.length);
      return exports.decodeFromBase64(data);
    };
  }
});

// node_modules/pdf-lib/cjs/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pdf-lib/cjs/utils/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findLastMatch = exports.parseDate = exports.breakTextIntoLines = exports.charSplit = exports.charAtIndex = exports.mergeLines = exports.lineSplit = exports.isNewlineChar = exports.newlineChars = exports.escapedNewlineChars = exports.cleanText = exports.escapeRegExp = exports.addRandomSuffix = exports.copyStringIntoBuffer = exports.padStart = exports.charFromHexCode = exports.charFromCode = exports.toHexString = exports.toHexStringOfMinLength = exports.toCodePoint = exports.toCharCode = void 0;
    exports.toCharCode = function(character) {
      return character.charCodeAt(0);
    };
    exports.toCodePoint = function(character) {
      return character.codePointAt(0);
    };
    exports.toHexStringOfMinLength = function(num, minLength) {
      return exports.padStart(num.toString(16), minLength, "0").toUpperCase();
    };
    exports.toHexString = function(num) {
      return exports.toHexStringOfMinLength(num, 2);
    };
    exports.charFromCode = function(code) {
      return String.fromCharCode(code);
    };
    exports.charFromHexCode = function(hex) {
      return exports.charFromCode(parseInt(hex, 16));
    };
    exports.padStart = function(value, length, padChar) {
      var padding = "";
      for (var idx = 0, len = length - value.length; idx < len; idx++) {
        padding += padChar;
      }
      return padding + value;
    };
    exports.copyStringIntoBuffer = function(str, buffer, offset2) {
      var length = str.length;
      for (var idx = 0; idx < length; idx++) {
        buffer[offset2++] = str.charCodeAt(idx);
      }
      return length;
    };
    exports.addRandomSuffix = function(prefix, suffixLength) {
      if (suffixLength === void 0) {
        suffixLength = 4;
      }
      return prefix + "-" + Math.floor(Math.random() * Math.pow(10, suffixLength));
    };
    exports.escapeRegExp = function(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    exports.cleanText = function(text) {
      return text.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "");
    };
    exports.escapedNewlineChars = ["\\n", "\\f", "\\r", "\\u000B"];
    exports.newlineChars = ["\n", "\f", "\r", "\v"];
    exports.isNewlineChar = function(text) {
      return /^[\n\f\r\u000B]$/.test(text);
    };
    exports.lineSplit = function(text) {
      return text.split(/[\n\f\r\u000B]/);
    };
    exports.mergeLines = function(text) {
      return text.replace(/[\n\f\r\u000B]/g, " ");
    };
    exports.charAtIndex = function(text, index) {
      var cuFirst = text.charCodeAt(index);
      var cuSecond;
      var nextIndex = index + 1;
      var length = 1;
      if (
        // Check if it's the start of a surrogate pair.
        cuFirst >= 55296 && cuFirst <= 56319 && // high surrogate
        text.length > nextIndex
      ) {
        cuSecond = text.charCodeAt(nextIndex);
        if (cuSecond >= 56320 && cuSecond <= 57343)
          length = 2;
      }
      return [text.slice(index, index + length), length];
    };
    exports.charSplit = function(text) {
      var chars = [];
      for (var idx = 0, len = text.length; idx < len; ) {
        var _a = exports.charAtIndex(text, idx), c = _a[0], cLen = _a[1];
        chars.push(c);
        idx += cLen;
      }
      return chars;
    };
    var buildWordBreakRegex = function(wordBreaks) {
      var newlineCharUnion = exports.escapedNewlineChars.join("|");
      var escapedRules = ["$"];
      for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {
        var wordBreak = wordBreaks[idx];
        if (exports.isNewlineChar(wordBreak)) {
          throw new TypeError("`wordBreak` must not include " + newlineCharUnion);
        }
        escapedRules.push(wordBreak === "" ? "." : exports.escapeRegExp(wordBreak));
      }
      var breakRules = escapedRules.join("|");
      return new RegExp("(" + newlineCharUnion + ")|((.*?)(" + breakRules + "))", "gm");
    };
    exports.breakTextIntoLines = function(text, wordBreaks, maxWidth, computeWidthOfText) {
      var regex = buildWordBreakRegex(wordBreaks);
      var words = exports.cleanText(text).match(regex);
      var currLine = "";
      var currWidth = 0;
      var lines = [];
      var pushCurrLine = function() {
        if (currLine !== "")
          lines.push(currLine);
        currLine = "";
        currWidth = 0;
      };
      for (var idx = 0, len = words.length; idx < len; idx++) {
        var word = words[idx];
        if (exports.isNewlineChar(word)) {
          pushCurrLine();
        } else {
          var width = computeWidthOfText(word);
          if (currWidth + width > maxWidth)
            pushCurrLine();
          currLine += word;
          currWidth += width;
        }
      }
      pushCurrLine();
      return lines;
    };
    var dateRegex = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/;
    exports.parseDate = function(dateStr) {
      var match = dateStr.match(dateRegex);
      if (!match)
        return void 0;
      var year = match[1], _a = match[2], month = _a === void 0 ? "01" : _a, _b = match[3], day = _b === void 0 ? "01" : _b, _c = match[4], hours = _c === void 0 ? "00" : _c, _d = match[5], mins = _d === void 0 ? "00" : _d, _e = match[6], secs = _e === void 0 ? "00" : _e, _f = match[7], offsetSign = _f === void 0 ? "Z" : _f, _g = match[8], offsetHours = _g === void 0 ? "00" : _g, _h = match[9], offsetMins = _h === void 0 ? "00" : _h;
      var tzOffset = offsetSign === "Z" ? "Z" : "" + offsetSign + offsetHours + ":" + offsetMins;
      var date = new Date(year + "-" + month + "-" + day + "T" + hours + ":" + mins + ":" + secs + tzOffset);
      return date;
    };
    exports.findLastMatch = function(value, regex) {
      var _a;
      var position = 0;
      var lastMatch;
      while (position < value.length) {
        var match = value.substring(position).match(regex);
        if (!match)
          return { match: lastMatch, pos: position };
        lastMatch = match;
        position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;
      }
      return { match: lastMatch, pos: position };
    };
  }
});

// node_modules/pdf-lib/cjs/utils/arrays.js
var require_arrays = __commonJS({
  "node_modules/pdf-lib/cjs/utils/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUint8Array = exports.canBeConvertedToUint8Array = exports.pluckIndices = exports.range = exports.sum = exports.reverseArray = exports.sortedUniq = exports.byAscendingId = exports.arrayAsString = exports.mergeUint8Arrays = exports.mergeIntoTypedArray = exports.typedArrayFor = exports.last = void 0;
    var base64_1 = require_base64();
    var strings_1 = require_strings();
    exports.last = function(array) {
      return array[array.length - 1];
    };
    exports.typedArrayFor = function(value) {
      if (value instanceof Uint8Array)
        return value;
      var length = value.length;
      var typedArray = new Uint8Array(length);
      for (var idx = 0; idx < length; idx++) {
        typedArray[idx] = value.charCodeAt(idx);
      }
      return typedArray;
    };
    exports.mergeIntoTypedArray = function() {
      var arrays = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
      }
      var arrayCount = arrays.length;
      var typedArrays = [];
      for (var idx = 0; idx < arrayCount; idx++) {
        var element = arrays[idx];
        typedArrays[idx] = element instanceof Uint8Array ? element : exports.typedArrayFor(element);
      }
      var totalSize = 0;
      for (var idx = 0; idx < arrayCount; idx++) {
        totalSize += arrays[idx].length;
      }
      var merged = new Uint8Array(totalSize);
      var offset2 = 0;
      for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {
        var arr = typedArrays[arrIdx];
        for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {
          merged[offset2++] = arr[byteIdx];
        }
      }
      return merged;
    };
    exports.mergeUint8Arrays = function(arrays) {
      var totalSize = 0;
      for (var idx = 0, len = arrays.length; idx < len; idx++) {
        totalSize += arrays[idx].length;
      }
      var mergedBuffer = new Uint8Array(totalSize);
      var offset2 = 0;
      for (var idx = 0, len = arrays.length; idx < len; idx++) {
        var array = arrays[idx];
        mergedBuffer.set(array, offset2);
        offset2 += array.length;
      }
      return mergedBuffer;
    };
    exports.arrayAsString = function(array) {
      var str = "";
      for (var idx = 0, len = array.length; idx < len; idx++) {
        str += strings_1.charFromCode(array[idx]);
      }
      return str;
    };
    exports.byAscendingId = function(a, b) {
      return a.id - b.id;
    };
    exports.sortedUniq = function(array, indexer) {
      var uniq = [];
      for (var idx = 0, len = array.length; idx < len; idx++) {
        var curr = array[idx];
        var prev = array[idx - 1];
        if (idx === 0 || indexer(curr) !== indexer(prev)) {
          uniq.push(curr);
        }
      }
      return uniq;
    };
    exports.reverseArray = function(array) {
      var arrayLen = array.length;
      for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {
        var leftIdx = idx;
        var rightIdx = arrayLen - idx - 1;
        var temp = array[idx];
        array[leftIdx] = array[rightIdx];
        array[rightIdx] = temp;
      }
      return array;
    };
    exports.sum = function(array) {
      var total = 0;
      for (var idx = 0, len = array.length; idx < len; idx++) {
        total += array[idx];
      }
      return total;
    };
    exports.range = function(start2, end2) {
      var arr = new Array(end2 - start2);
      for (var idx = 0, len = arr.length; idx < len; idx++) {
        arr[idx] = start2 + idx;
      }
      return arr;
    };
    exports.pluckIndices = function(arr, indices) {
      var plucked = new Array(indices.length);
      for (var idx = 0, len = indices.length; idx < len; idx++) {
        plucked[idx] = arr[indices[idx]];
      }
      return plucked;
    };
    exports.canBeConvertedToUint8Array = function(input) {
      return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === "string";
    };
    exports.toUint8Array = function(input) {
      if (typeof input === "string") {
        return base64_1.decodeFromBase64DataUri(input);
      } else if (input instanceof ArrayBuffer) {
        return new Uint8Array(input);
      } else if (input instanceof Uint8Array) {
        return input;
      } else {
        throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`");
      }
    };
  }
});

// node_modules/pdf-lib/cjs/utils/async.js
var require_async = __commonJS({
  "node_modules/pdf-lib/cjs/utils/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.waitForTick = void 0;
    exports.waitForTick = function() {
      return new Promise(function(resolve) {
        setTimeout(function() {
          return resolve();
        }, 0);
      });
    };
  }
});

// node_modules/pdf-lib/cjs/utils/unicode.js
var require_unicode = __commonJS({
  "node_modules/pdf-lib/cjs/utils/unicode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasUtf16BOM = exports.utf16Decode = exports.lowSurrogate = exports.highSurrogate = exports.hasSurrogates = exports.isWithinBMP = exports.utf16Encode = exports.utf8Encode = void 0;
    var strings_1 = require_strings();
    exports.utf8Encode = function(input, byteOrderMark) {
      if (byteOrderMark === void 0) {
        byteOrderMark = true;
      }
      var encoded = [];
      if (byteOrderMark)
        encoded.push(239, 187, 191);
      for (var idx = 0, len = input.length; idx < len; ) {
        var codePoint = input.codePointAt(idx);
        if (codePoint < 128) {
          var byte1 = codePoint & 127;
          encoded.push(byte1);
          idx += 1;
        } else if (codePoint < 2048) {
          var byte1 = codePoint >> 6 & 31 | 192;
          var byte2 = codePoint & 63 | 128;
          encoded.push(byte1, byte2);
          idx += 1;
        } else if (codePoint < 65536) {
          var byte1 = codePoint >> 12 & 15 | 224;
          var byte2 = codePoint >> 6 & 63 | 128;
          var byte3 = codePoint & 63 | 128;
          encoded.push(byte1, byte2, byte3);
          idx += 1;
        } else if (codePoint < 1114112) {
          var byte1 = codePoint >> 18 & 7 | 240;
          var byte2 = codePoint >> 12 & 63 | 128;
          var byte3 = codePoint >> 6 & 63 | 128;
          var byte4 = codePoint >> 0 & 63 | 128;
          encoded.push(byte1, byte2, byte3, byte4);
          idx += 2;
        } else
          throw new Error("Invalid code point: 0x" + strings_1.toHexString(codePoint));
      }
      return new Uint8Array(encoded);
    };
    exports.utf16Encode = function(input, byteOrderMark) {
      if (byteOrderMark === void 0) {
        byteOrderMark = true;
      }
      var encoded = [];
      if (byteOrderMark)
        encoded.push(65279);
      for (var idx = 0, len = input.length; idx < len; ) {
        var codePoint = input.codePointAt(idx);
        if (codePoint < 65536) {
          encoded.push(codePoint);
          idx += 1;
        } else if (codePoint < 1114112) {
          encoded.push(exports.highSurrogate(codePoint), exports.lowSurrogate(codePoint));
          idx += 2;
        } else
          throw new Error("Invalid code point: 0x" + strings_1.toHexString(codePoint));
      }
      return new Uint16Array(encoded);
    };
    exports.isWithinBMP = function(codePoint) {
      return codePoint >= 0 && codePoint <= 65535;
    };
    exports.hasSurrogates = function(codePoint) {
      return codePoint >= 65536 && codePoint <= 1114111;
    };
    exports.highSurrogate = function(codePoint) {
      return Math.floor((codePoint - 65536) / 1024) + 55296;
    };
    exports.lowSurrogate = function(codePoint) {
      return (codePoint - 65536) % 1024 + 56320;
    };
    var ByteOrder;
    (function(ByteOrder2) {
      ByteOrder2["BigEndian"] = "BigEndian";
      ByteOrder2["LittleEndian"] = "LittleEndian";
    })(ByteOrder || (ByteOrder = {}));
    var REPLACEMENT = "\uFFFD".codePointAt(0);
    exports.utf16Decode = function(input, byteOrderMark) {
      if (byteOrderMark === void 0) {
        byteOrderMark = true;
      }
      if (input.length <= 1)
        return String.fromCodePoint(REPLACEMENT);
      var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;
      var idx = byteOrderMark ? 2 : 0;
      var codePoints = [];
      while (input.length - idx >= 2) {
        var first = decodeValues(input[idx++], input[idx++], byteOrder);
        if (isHighSurrogate(first)) {
          if (input.length - idx < 2) {
            codePoints.push(REPLACEMENT);
          } else {
            var second = decodeValues(input[idx++], input[idx++], byteOrder);
            if (isLowSurrogate(second)) {
              codePoints.push(first, second);
            } else {
              codePoints.push(REPLACEMENT);
            }
          }
        } else if (isLowSurrogate(first)) {
          idx += 2;
          codePoints.push(REPLACEMENT);
        } else {
          codePoints.push(first);
        }
      }
      if (idx < input.length)
        codePoints.push(REPLACEMENT);
      return String.fromCodePoint.apply(String, codePoints);
    };
    var isHighSurrogate = function(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    };
    var isLowSurrogate = function(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    };
    var decodeValues = function(first, second, byteOrder) {
      if (byteOrder === ByteOrder.LittleEndian)
        return second << 8 | first;
      if (byteOrder === ByteOrder.BigEndian)
        return first << 8 | second;
      throw new Error("Invalid byteOrder: " + byteOrder);
    };
    var readBOM = function(bytes) {
      return hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;
    };
    var hasUtf16BigEndianBOM = function(bytes) {
      return bytes[0] === 254 && bytes[1] === 255;
    };
    var hasUtf16LittleEndianBOM = function(bytes) {
      return bytes[0] === 255 && bytes[1] === 254;
    };
    exports.hasUtf16BOM = function(bytes) {
      return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);
    };
  }
});

// node_modules/pdf-lib/cjs/utils/numbers.js
var require_numbers = __commonJS({
  "node_modules/pdf-lib/cjs/utils/numbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesFor = exports.sizeInBytes = exports.numberToString = void 0;
    exports.numberToString = function(num) {
      var numStr = String(num);
      if (Math.abs(num) < 1) {
        var e = parseInt(num.toString().split("e-")[1]);
        if (e) {
          var negative = num < 0;
          if (negative)
            num *= -1;
          num *= Math.pow(10, e - 1);
          numStr = "0." + new Array(e).join("0") + num.toString().substring(2);
          if (negative)
            numStr = "-" + numStr;
        }
      } else {
        var e = parseInt(num.toString().split("+")[1]);
        if (e > 20) {
          e -= 20;
          num /= Math.pow(10, e);
          numStr = num.toString() + new Array(e + 1).join("0");
        }
      }
      return numStr;
    };
    exports.sizeInBytes = function(n) {
      return Math.ceil(n.toString(2).length / 8);
    };
    exports.bytesFor = function(n) {
      var bytes = new Uint8Array(exports.sizeInBytes(n));
      for (var i = 1; i <= bytes.length; i++) {
        bytes[i - 1] = n >> (bytes.length - i) * 8;
      }
      return bytes;
    };
  }
});

// node_modules/pdf-lib/cjs/utils/errors.js
var require_errors = __commonJS({
  "node_modules/pdf-lib/cjs/utils/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.error = void 0;
    exports.error = function(msg) {
      throw new Error(msg);
    };
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end2 = pos + len;
      crc ^= -1;
      for (var i = pos; i < end2; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start2, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings2 = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max2) {
      var i, out, c, c_len;
      var len = max2 || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings2();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start2) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end2;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end2 = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end2);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left2 = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end2;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left2 = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left2 <<= 1;
        left2 -= count[len];
        if (left2 < 0) {
          return -1;
        }
      }
      if (left2 > 0 && (type === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end2 = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end2 = 256;
      } else {
        base = dbase;
        extra = dext;
        end2 = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end2) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end2) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left2 = 1 << curr;
          while (curr + drop < max2) {
            left2 -= count[curr + drop];
            if (left2 <= 0) {
              break;
            }
            curr++;
            left2 <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end2, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end2 - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end2 - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end2 - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left2;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order2 = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left2 = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left2;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left2;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left2) {
                  copy = left2;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left2 -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order2[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order2[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left2 >= 258) {
                strm.next_out = put;
                strm.avail_out = left2;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left2 = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left2 === 0) {
                break inf_leave;
              }
              copy = _out - left2;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left2) {
                copy = left2;
              }
              left2 -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left2 === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left2--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left2;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left2;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left2;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings2();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/utils.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var pako_1 = __importDefault2(require_pako());
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var i;
    exports.decodeFromBase64 = function(base64) {
      var bufferLength = base64.length * 0.75;
      var len = base64.length;
      var i2;
      var p = 0;
      var encoded1;
      var encoded2;
      var encoded3;
      var encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var bytes = new Uint8Array(bufferLength);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup[base64.charCodeAt(i2)];
        encoded2 = lookup[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return bytes;
    };
    var arrayToString = function(array) {
      var str = "";
      for (var i2 = 0; i2 < array.length; i2++) {
        str += String.fromCharCode(array[i2]);
      }
      return str;
    };
    exports.decompressJson = function(compressedJson) {
      return arrayToString(pako_1.default.inflate(exports.decodeFromBase64(compressedJson)));
    };
    exports.padStart = function(value, length, padChar) {
      var padding = "";
      for (var idx = 0, len = length - value.length; idx < len; idx++) {
        padding += padChar;
      }
      return padding + value;
    };
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Courier-Bold.compressed.json
var require_Courier_Bold_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Courier-Bold.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Courier-BoldOblique.compressed.json
var require_Courier_BoldOblique_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Courier-BoldOblique.compressed.json"(exports, module2) {
    module2.exports = "eJyFWdtyGjkQ/RVqnnarcAo7vuE3jEnCxgEvGDtxKg9iRgxaa0ZEF9s4lX/fnrGdTVZ9lBcKTmvU96PW8C0bmqqStc9OsqsPwYlSdnaPDvb6naP+3v5+1s3emNpPRCVpwdAEq6TdOTW6mC61+hpksyBo/euCTrOg89MKUSm9/XUNwddSletGcbOcfo+90Cof1KWmdTu7e4S4N+pBFhfK5+vsxNsgu9lwLazIvbRz2Tw7evCyLmQxM5Won809PTUP2cnnnYOj7s7eQa97fNjvHvd2v3SzBS21WtXywjjllakbRb3eT4LLtcpva+lcdkJPZlfSunZZ1uu9ftXr9UjFxHiVP7my2drGh84f+Z+d3f5xv0uf/V77udt+vm4/jzqDwixlZ751XlauM65zYzfGCi+LV53OQOvOrNnHdWbSSXtHKOkZ0apC1eU8X8s2dO0mcy/qQtjiRUoLh2Lz7jmWB4cUto8vv/Zf97vZwOVNhGx2crhHP8/kj987uxShbO6Ld9fZyfF++/WKvu72Dp/i/EF6q3IKxedv2fVH2qAJ1YQscRtBEfje/R8sH3Itqhj/Ggx5utSxpA7VsglxWceywmgtbIxvpM2bio0EoiKRo/AAC9pcMfsJK2stV0gEHhOu2dHdMk/p4GI0p0YTMbzebtaS8Z5cUYbxxGnh1jH8KK2JUVMzWfL3zEq/tpJZu6JuZVB1x6x16oEB5R3nneRjWivO4Nxow+zhZKWASDcNHCv9GgRTg6WV1IiMm8ReriWJOPeM7YMYOo2hYQydxdAoht7E0NsYehdD4xj6K4bex9B5DH2IoUkMTWPoIob+jqFZDM1j6DKGFjF0FUPXMfQxhj7F0E0MLekQupWep40lyUCfPj8HOSVXKlc2DwyLhoa1HZ0cTIu0/MYbw3DOkukxhn+ZDmK4gGkohuViSMXQPzHE0CvTwky0mK5laG/DhDKGGG5g6IWJfYihuxi6jyGGSbcM6fP1BQphyR2m7fpUNXqlC3jUF+aeiTN/OjfHpW4GlriEmoGO5dktd3astLGKPQ/ALnmwdIznTADbtnGqHTnh1MJHswyKJJUBFNCI241/IwahXzHdsWIKnyY5lmYKUZbckfaEs6PY08DR5E5ayfQ+zUKitGLDkRpdASTjxX/hXQqXiHBaCkL0IwFALrVWG6eYRiVP/doENCk+Hfp8aVMAuNFH5MFzg0vL5CstmXYGfVWJ3HI1vLSSU1wYL3K+3wq6ZUnWf8t2YS4LCig3oYa6FDZUWgRGjSlpyGRYOhesH7LiC3bAjDzGFiua8fih8BwcsFOE8woqIrmgWQ2Cj3czWzLdqYFeg3Bmd2pNusVSyTNJG+N8SlB+AhRNSGdUgtR9whYU6k5x1fwJWDZIdYYADy1SD23BQ669dqEekaktF3yfLHAYBGqGBbAuoAdGWMkZEQR3/0g6mr+8qmBUIcrJQR0IPi6TpAEa1Shg1MvkbkO0G2DVUYInHXDTQUJUQLs2j7IuGcEMqHibdDIkmyQlHKCUWmBIDn29SUTucm0ss9kUaZ+BuM0BXgBrF0hB4CuzfbfhQjvgMDPRFJTgAOGAVqugvdpoZswMwMFL4CCNWl4JXagVc7vaYmqYAD0qVSyjZJklTh0syoEdNaJBlNAJCNAYbNS8eaOBgXv9trTmVtbsHcjKUjkw9b4FyR6nGCVQV/NXkRGoKQscMigyN+CBGxCx55dc4BXYyDMTyhCSgk7ylkejHzwdkWCAxodEVYIAP6LWQLqnKCPo6EGZckgzdmKaHEuAh2dSeyZXnidpf28SjIhNq5hXGgpYZNJz5giFvgATTsvjVMCWCpkxbZ6oV74i3yfr+BwkzltRyEpYxnKZYIUxiNIYFc45sJqCthaaORmamwlocJOqqBpMTYvf5A/ERyKHSsCl5NBzVrmk8kGYJ1M3TVteEEtw/3YYkKIhMCJANi9UzqXhDGxkk95MQH4MwGfpsk5KB2DPAeRofuaagn0eEx0yQqc90n2bdAUMAuNkKwATfPpyY8om37Xh3o9gLg1YRFuhf6vSF1ruIH8ETtXJrSjk+IRQqMdHofkf8ks3ey9tfSGUbf49/vL9XxrnGMA=";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Courier-Oblique.compressed.json
var require_Courier_Oblique_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Courier-Oblique.compressed.json"(exports, module2) {
    module2.exports = "eJyFWVtT2zgU/isZP+3OhE5Iy/UtDaHNFhI2IdDS4UGxFUeLbKW6AKHT/77Hhnbb1fnUFw98x9K5fzpyvmZDU1Wy9tlxdnUenChlZ3e//+awc7B32D/Kutmpqf1EVJJeGJpglbQ706VWX4JshEHrX4Wdn4SiUnr7q5jga6nKdaPvXBYqVISMvdAqH9Slpjd3dvuEuFP1KIsL5fN1duxtkN1suBZW5F7auWxWjx69rAtZzEwl6hc73741j9nx553+QXenv9frHr456h729m672YJetVrV8sI45ZWpG0W93k+Cy7XK72rpXHZMK7MraV37WtbrvX7V6/VIxcR4lT87s9naxovOH/mfnd2jw6MuPY967XO3ffbb5+v2edAZFGYpO/Ot87JynXGdG7sxVnhZvOp0Blp3Zs1urjOTTtp7QknbiN4qVF3O87VsQ9huMveiLoQtvkvpxaHYvH+J6d4+Be/j9//e9Pe72cDlTZxsdrzfP+pmJ/LH/zu7ewfdbO6L99e0crf98+rlzybY59JblVM8Pn/Nrj/S+iZeEzLEbQSF4Vv3f7B8zLWoYvxLMOToUseSOlTLJs5lHcsKo7WwMb6RNm/qNRKIikSOogMsaBPG7CesrLVcIRFYJlyzo7tjVungYjSnNhMxvN5u1pLxnlxRhvHEaeHWMfwkrYlRUzNZ8g/Mm35tJfPuipqWQdU9865Tjwwo7znvJB/TWnEG50YbZg8nKwVEuuniWOmXIJgaLK2kPmTcJBJzLVPEuWdsH8TQ2xgaxtBJDI1i6DSG3sXQ+xgax9BfMfQhhs5i6DyGJjE0jaGLGPo7hmYxNI+hyxhaxNBVDF3H0McY+hRDNzG0pJPoTnqeNpYkA336sg5ySq5UrmweGBYNDWk7OjiYFmn5jTeG4Zwl02MM/zIdxHAB01AMy8WQiqF/YoihV6aFmWgxXcvQ3oYJZQwx3MDQCxP7EEP3MfQQQwyTbhnS5+sLFMKSO0zb91PV6JUu4FFfmAcmzvzp3ByXuplX4hJqpjqWZ7fc2bHSxir2PAC75MHSMZ4zAWzbxql27oRTCx/NMiiSVAZQQCNuN/6NGIR+xXTHiil8GuRYmilEWXJH2jPOjmLPA0eTO2kl0/s0C4nSig1HanQJkIwX/4V3KVwiwmkpCNGPBAC51FptnGIalTz1axPQpPh86POlTQHgRh+RB88NLi2Tr7Rk2hn0VSVyy9Xw0kpOcWG8yPl+K+iyJVn/LduFOV3GaOBmuDvUpbCh0iIwakxJQybD0rlg/ZAVX7ADZuQxtljRjMcPhWfggJ0inFdQEckFzWoQfLyb2ZLpTg30GoQzu1Nr0lWWSp5J2hjnU4LyE6BoQjqjEqTuE7agUPeKq+ZPwLJBqjMEWLRILdqCRa69dqEekaktF3yfLHAYBGqGBbAuoAUjrOSECIK7fyQdzb9/r2BUIcrJQR0IPi6TpAEa1Shg1MvkbkO0G2DVUYInHXDTQUJUQLs2T7IuGcEMqHiXdDIkmyQlHKCUWmBIDn29SUTucm0ss9kUaZ+BuM0BXgBrF0hB4Cuz/bbhQjvgMDPRFJTgAOGAVqugvdpoZswMwMFL4CCNWl4JXagVc7vaYmqYAD0qVSyjZJklTh0syoEdNaJBlNAJCNAYbNR8eaOBgfv8trTmTtbsHcjKUjkw9b4DyR6nGCVQV/NXkRGoKQscMigyN2DBDYjYy0cu8Als5JkJZQhJQSd5y6PRD56OSDBA40OiKkGAn1BrIN1TlBF09KBMOaQZOzFNjiXAwxOpPZMrz5O0fzAJRsSmVcwnDQUsMuk5c4RCX4AJp+VxKmBLhcyYNk/UK1+RH5J1fAYS560oZCUsY7lMsMIYRGmMCucMWE1BWwvNnAzNzQQ0uElVVA2mpsVv8gfiI5FDJeBScuglq1xS+SDMk6mbpi0viCW4XzsMSNEQGBEgmxcq59JwAjaySW8mID8G4LN0WSelA7DnAHI0P3NNwT5PiQ4ZodMe6b5LugIGgXGyFYAJPn25MWWT79pw30cwlwYsoq3Qr1XpCy13kD8Bp+rkVhRyfEIo1OOj0PwOedvNPkhbXwhlm1+Pb7/9C/NFF2U=";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Courier.compressed.json
var require_Courier_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Courier.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Bold.compressed.json
var require_Helvetica_Bold_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Bold.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Helvetica-BoldOblique.compressed.json
var require_Helvetica_BoldOblique_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Helvetica-BoldOblique.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Oblique.compressed.json
var require_Helvetica_Oblique_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Oblique.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Helvetica.compressed.json
var require_Helvetica_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Helvetica.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Times-Bold.compressed.json
var require_Times_Bold_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Times-Bold.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Times-BoldItalic.compressed.json
var require_Times_BoldItalic_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Times-BoldItalic.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Times-Italic.compressed.json
var require_Times_Italic_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Times-Italic.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Times-Roman.compressed.json
var require_Times_Roman_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Times-Roman.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Symbol.compressed.json
var require_Symbol_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Symbol.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/ZapfDingbats.compressed.json
var require_ZapfDingbats_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/ZapfDingbats.compressed.json"(exports, module2) {
    module2.exports = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Font.js
var require_Font = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Font.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Courier_Bold_compressed_json_1 = __importDefault2(require_Courier_Bold_compressed());
    var Courier_BoldOblique_compressed_json_1 = __importDefault2(require_Courier_BoldOblique_compressed());
    var Courier_Oblique_compressed_json_1 = __importDefault2(require_Courier_Oblique_compressed());
    var Courier_compressed_json_1 = __importDefault2(require_Courier_compressed());
    var Helvetica_Bold_compressed_json_1 = __importDefault2(require_Helvetica_Bold_compressed());
    var Helvetica_BoldOblique_compressed_json_1 = __importDefault2(require_Helvetica_BoldOblique_compressed());
    var Helvetica_Oblique_compressed_json_1 = __importDefault2(require_Helvetica_Oblique_compressed());
    var Helvetica_compressed_json_1 = __importDefault2(require_Helvetica_compressed());
    var Times_Bold_compressed_json_1 = __importDefault2(require_Times_Bold_compressed());
    var Times_BoldItalic_compressed_json_1 = __importDefault2(require_Times_BoldItalic_compressed());
    var Times_Italic_compressed_json_1 = __importDefault2(require_Times_Italic_compressed());
    var Times_Roman_compressed_json_1 = __importDefault2(require_Times_Roman_compressed());
    var Symbol_compressed_json_1 = __importDefault2(require_Symbol_compressed());
    var ZapfDingbats_compressed_json_1 = __importDefault2(require_ZapfDingbats_compressed());
    var compressedJsonForFontName = {
      "Courier": Courier_compressed_json_1.default,
      "Courier-Bold": Courier_Bold_compressed_json_1.default,
      "Courier-Oblique": Courier_Oblique_compressed_json_1.default,
      "Courier-BoldOblique": Courier_BoldOblique_compressed_json_1.default,
      "Helvetica": Helvetica_compressed_json_1.default,
      "Helvetica-Bold": Helvetica_Bold_compressed_json_1.default,
      "Helvetica-Oblique": Helvetica_Oblique_compressed_json_1.default,
      "Helvetica-BoldOblique": Helvetica_BoldOblique_compressed_json_1.default,
      "Times-Roman": Times_Roman_compressed_json_1.default,
      "Times-Bold": Times_Bold_compressed_json_1.default,
      "Times-Italic": Times_Italic_compressed_json_1.default,
      "Times-BoldItalic": Times_BoldItalic_compressed_json_1.default,
      "Symbol": Symbol_compressed_json_1.default,
      "ZapfDingbats": ZapfDingbats_compressed_json_1.default
    };
    var FontNames;
    (function(FontNames2) {
      FontNames2["Courier"] = "Courier";
      FontNames2["CourierBold"] = "Courier-Bold";
      FontNames2["CourierOblique"] = "Courier-Oblique";
      FontNames2["CourierBoldOblique"] = "Courier-BoldOblique";
      FontNames2["Helvetica"] = "Helvetica";
      FontNames2["HelveticaBold"] = "Helvetica-Bold";
      FontNames2["HelveticaOblique"] = "Helvetica-Oblique";
      FontNames2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
      FontNames2["TimesRoman"] = "Times-Roman";
      FontNames2["TimesRomanBold"] = "Times-Bold";
      FontNames2["TimesRomanItalic"] = "Times-Italic";
      FontNames2["TimesRomanBoldItalic"] = "Times-BoldItalic";
      FontNames2["Symbol"] = "Symbol";
      FontNames2["ZapfDingbats"] = "ZapfDingbats";
    })(FontNames = exports.FontNames || (exports.FontNames = {}));
    var fontCache = {};
    var Font = (
      /** @class */
      function() {
        function Font2() {
          var _this = this;
          this.getWidthOfGlyph = function(glyphName) {
            return _this.CharWidths[glyphName];
          };
          this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {
            return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];
          };
        }
        Font2.load = function(fontName) {
          var cachedFont = fontCache[fontName];
          if (cachedFont)
            return cachedFont;
          var json = utils_1.decompressJson(compressedJsonForFontName[fontName]);
          var font = Object.assign(new Font2(), JSON.parse(json));
          font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {
            acc[metric.N] = metric.WX;
            return acc;
          }, {});
          font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a) {
            var name1 = _a[0], name2 = _a[1], width = _a[2];
            if (!acc[name1])
              acc[name1] = {};
            acc[name1][name2] = width;
            return acc;
          }, {});
          fontCache[fontName] = font;
          return font;
        };
        return Font2;
      }()
    );
    exports.Font = Font;
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/all-encodings.compressed.json
var require_all_encodings_compressed = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/all-encodings.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/Encoding.js
var require_Encoding = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/Encoding.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var all_encodings_compressed_json_1 = __importDefault2(require_all_encodings_compressed());
    var decompressedEncodings = utils_1.decompressJson(all_encodings_compressed_json_1.default);
    var allUnicodeMappings = JSON.parse(decompressedEncodings);
    var Encoding = (
      /** @class */
      function() {
        function Encoding2(name, unicodeMappings) {
          var _this = this;
          this.canEncodeUnicodeCodePoint = function(codePoint) {
            return codePoint in _this.unicodeMappings;
          };
          this.encodeUnicodeCodePoint = function(codePoint) {
            var mapped = _this.unicodeMappings[codePoint];
            if (!mapped) {
              var str = String.fromCharCode(codePoint);
              var hexCode = "0x" + utils_1.padStart(codePoint.toString(16), 4, "0");
              var msg = _this.name + ' cannot encode "' + str + '" (' + hexCode + ")";
              throw new Error(msg);
            }
            return { code: mapped[0], name: mapped[1] };
          };
          this.name = name;
          this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a, b) {
            return a - b;
          });
          this.unicodeMappings = unicodeMappings;
        }
        return Encoding2;
      }()
    );
    exports.Encodings = {
      Symbol: new Encoding("Symbol", allUnicodeMappings.symbol),
      ZapfDingbats: new Encoding("ZapfDingbats", allUnicodeMappings.zapfdingbats),
      WinAnsi: new Encoding("WinAnsi", allUnicodeMappings.win1252)
    };
  }
});

// node_modules/@pdf-lib/standard-fonts/lib/index.js
var require_lib = __commonJS({
  "node_modules/@pdf-lib/standard-fonts/lib/index.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_Font());
    __export2(require_Encoding());
  }
});

// node_modules/pdf-lib/cjs/utils/objects.js
var require_objects = __commonJS({
  "node_modules/pdf-lib/cjs/utils/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rectanglesAreEqual = exports.isStandardFont = exports.StandardFontValues = exports.values = void 0;
    var standard_fonts_1 = require_lib();
    exports.values = function(obj) {
      return Object.keys(obj).map(function(k) {
        return obj[k];
      });
    };
    exports.StandardFontValues = exports.values(standard_fonts_1.FontNames);
    exports.isStandardFont = function(input) {
      return exports.StandardFontValues.includes(input);
    };
    exports.rectanglesAreEqual = function(a, b) {
      return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    };
  }
});

// node_modules/pdf-lib/cjs/utils/validators.js
var require_validators = __commonJS({
  "node_modules/pdf-lib/cjs/utils/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertPositive = exports.assertInteger = exports.assertMultiple = exports.assertRangeOrUndefined = exports.assertRange = exports.assertEachIs = exports.assertOrUndefined = exports.assertIs = exports.createTypeErrorMsg = exports.isType = exports.getType = exports.assertIsSubset = exports.assertIsOneOfOrUndefined = exports.assertIsOneOf = exports.createValueErrorMsg = exports.singleQuote = exports.backtick = void 0;
    var objects_1 = require_objects();
    exports.backtick = function(val) {
      return "`" + val + "`";
    };
    exports.singleQuote = function(val) {
      return "'" + val + "'";
    };
    var formatValue = function(value) {
      var type = typeof value;
      if (type === "string")
        return exports.singleQuote(value);
      else if (type === "undefined")
        return exports.backtick(value);
      else
        return value;
    };
    exports.createValueErrorMsg = function(value, valueName, values) {
      var allowedValues = new Array(values.length);
      for (var idx = 0, len = values.length; idx < len; idx++) {
        var v = values[idx];
        allowedValues[idx] = formatValue(v);
      }
      var joinedValues = allowedValues.join(" or ");
      return exports.backtick(valueName) + " must be one of " + joinedValues + ", but was actually " + formatValue(value);
    };
    exports.assertIsOneOf = function(value, valueName, allowedValues) {
      if (!Array.isArray(allowedValues)) {
        allowedValues = objects_1.values(allowedValues);
      }
      for (var idx = 0, len = allowedValues.length; idx < len; idx++) {
        if (value === allowedValues[idx])
          return;
      }
      throw new TypeError(exports.createValueErrorMsg(value, valueName, allowedValues));
    };
    exports.assertIsOneOfOrUndefined = function(value, valueName, allowedValues) {
      if (!Array.isArray(allowedValues)) {
        allowedValues = objects_1.values(allowedValues);
      }
      exports.assertIsOneOf(value, valueName, allowedValues.concat(void 0));
    };
    exports.assertIsSubset = function(values, valueName, allowedValues) {
      if (!Array.isArray(allowedValues)) {
        allowedValues = objects_1.values(allowedValues);
      }
      for (var idx = 0, len = values.length; idx < len; idx++) {
        exports.assertIsOneOf(values[idx], valueName, allowedValues);
      }
    };
    exports.getType = function(val) {
      if (val === null)
        return "null";
      if (val === void 0)
        return "undefined";
      if (typeof val === "string")
        return "string";
      if (isNaN(val))
        return "NaN";
      if (typeof val === "number")
        return "number";
      if (typeof val === "boolean")
        return "boolean";
      if (typeof val === "symbol")
        return "symbol";
      if (typeof val === "bigint")
        return "bigint";
      if (val.constructor && val.constructor.name)
        return val.constructor.name;
      if (val.name)
        return val.name;
      if (val.constructor)
        return String(val.constructor);
      return String(val);
    };
    exports.isType = function(value, type) {
      if (type === "null")
        return value === null;
      if (type === "undefined")
        return value === void 0;
      if (type === "string")
        return typeof value === "string";
      if (type === "number")
        return typeof value === "number" && !isNaN(value);
      if (type === "boolean")
        return typeof value === "boolean";
      if (type === "symbol")
        return typeof value === "symbol";
      if (type === "bigint")
        return typeof value === "bigint";
      if (type === Date)
        return value instanceof Date;
      if (type === Array)
        return value instanceof Array;
      if (type === Uint8Array)
        return value instanceof Uint8Array;
      if (type === ArrayBuffer)
        return value instanceof ArrayBuffer;
      if (type === Function)
        return value instanceof Function;
      return value instanceof type[0];
    };
    exports.createTypeErrorMsg = function(value, valueName, types) {
      var allowedTypes = new Array(types.length);
      for (var idx = 0, len = types.length; idx < len; idx++) {
        var type = types[idx];
        if (type === "null")
          allowedTypes[idx] = exports.backtick("null");
        if (type === "undefined")
          allowedTypes[idx] = exports.backtick("undefined");
        if (type === "string")
          allowedTypes[idx] = exports.backtick("string");
        else if (type === "number")
          allowedTypes[idx] = exports.backtick("number");
        else if (type === "boolean")
          allowedTypes[idx] = exports.backtick("boolean");
        else if (type === "symbol")
          allowedTypes[idx] = exports.backtick("symbol");
        else if (type === "bigint")
          allowedTypes[idx] = exports.backtick("bigint");
        else if (type === Array)
          allowedTypes[idx] = exports.backtick("Array");
        else if (type === Uint8Array)
          allowedTypes[idx] = exports.backtick("Uint8Array");
        else if (type === ArrayBuffer)
          allowedTypes[idx] = exports.backtick("ArrayBuffer");
        else
          allowedTypes[idx] = exports.backtick(type[1]);
      }
      var joinedTypes = allowedTypes.join(" or ");
      return exports.backtick(valueName) + " must be of type " + joinedTypes + ", but was actually of type " + exports.backtick(exports.getType(value));
    };
    exports.assertIs = function(value, valueName, types) {
      for (var idx = 0, len = types.length; idx < len; idx++) {
        if (exports.isType(value, types[idx]))
          return;
      }
      throw new TypeError(exports.createTypeErrorMsg(value, valueName, types));
    };
    exports.assertOrUndefined = function(value, valueName, types) {
      exports.assertIs(value, valueName, types.concat("undefined"));
    };
    exports.assertEachIs = function(values, valueName, types) {
      for (var idx = 0, len = values.length; idx < len; idx++) {
        exports.assertIs(values[idx], valueName, types);
      }
    };
    exports.assertRange = function(value, valueName, min2, max2) {
      exports.assertIs(value, valueName, ["number"]);
      exports.assertIs(min2, "min", ["number"]);
      exports.assertIs(max2, "max", ["number"]);
      max2 = Math.max(min2, max2);
      if (value < min2 || value > max2) {
        throw new Error(exports.backtick(valueName) + " must be at least " + min2 + " and at most " + max2 + ", but was actually " + value);
      }
    };
    exports.assertRangeOrUndefined = function(value, valueName, min2, max2) {
      exports.assertIs(value, valueName, ["number", "undefined"]);
      if (typeof value === "number")
        exports.assertRange(value, valueName, min2, max2);
    };
    exports.assertMultiple = function(value, valueName, multiplier) {
      exports.assertIs(value, valueName, ["number"]);
      if (value % multiplier !== 0) {
        throw new Error(exports.backtick(valueName) + " must be a multiple of " + multiplier + ", but was actually " + value);
      }
    };
    exports.assertInteger = function(value, valueName) {
      if (!Number.isInteger(value)) {
        throw new Error(exports.backtick(valueName) + " must be an integer, but was actually " + value);
      }
    };
    exports.assertPositive = function(value, valueName) {
      if (![1, 0].includes(Math.sign(value))) {
        throw new Error(exports.backtick(valueName) + " must be a positive number or 0, but was actually " + value);
      }
    };
  }
});

// node_modules/pdf-lib/cjs/utils/pdfDocEncoding.js
var require_pdfDocEncoding = __commonJS({
  "node_modules/pdf-lib/cjs/utils/pdfDocEncoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pdfDocEncodingDecode = void 0;
    var strings_1 = require_strings();
    var pdfDocEncodingToUnicode = new Uint16Array(256);
    for (idx = 0; idx < 256; idx++) {
      pdfDocEncodingToUnicode[idx] = idx;
    }
    var idx;
    pdfDocEncodingToUnicode[22] = strings_1.toCharCode("");
    pdfDocEncodingToUnicode[24] = strings_1.toCharCode("\u02D8");
    pdfDocEncodingToUnicode[25] = strings_1.toCharCode("\u02C7");
    pdfDocEncodingToUnicode[26] = strings_1.toCharCode("\u02C6");
    pdfDocEncodingToUnicode[27] = strings_1.toCharCode("\u02D9");
    pdfDocEncodingToUnicode[28] = strings_1.toCharCode("\u02DD");
    pdfDocEncodingToUnicode[29] = strings_1.toCharCode("\u02DB");
    pdfDocEncodingToUnicode[30] = strings_1.toCharCode("\u02DA");
    pdfDocEncodingToUnicode[31] = strings_1.toCharCode("\u02DC");
    pdfDocEncodingToUnicode[127] = strings_1.toCharCode("\uFFFD");
    pdfDocEncodingToUnicode[128] = strings_1.toCharCode("\u2022");
    pdfDocEncodingToUnicode[129] = strings_1.toCharCode("\u2020");
    pdfDocEncodingToUnicode[130] = strings_1.toCharCode("\u2021");
    pdfDocEncodingToUnicode[131] = strings_1.toCharCode("\u2026");
    pdfDocEncodingToUnicode[132] = strings_1.toCharCode("\u2014");
    pdfDocEncodingToUnicode[133] = strings_1.toCharCode("\u2013");
    pdfDocEncodingToUnicode[134] = strings_1.toCharCode("\u0192");
    pdfDocEncodingToUnicode[135] = strings_1.toCharCode("\u2044");
    pdfDocEncodingToUnicode[136] = strings_1.toCharCode("\u2039");
    pdfDocEncodingToUnicode[137] = strings_1.toCharCode("\u203A");
    pdfDocEncodingToUnicode[138] = strings_1.toCharCode("\u2212");
    pdfDocEncodingToUnicode[139] = strings_1.toCharCode("\u2030");
    pdfDocEncodingToUnicode[140] = strings_1.toCharCode("\u201E");
    pdfDocEncodingToUnicode[141] = strings_1.toCharCode("\u201C");
    pdfDocEncodingToUnicode[142] = strings_1.toCharCode("\u201D");
    pdfDocEncodingToUnicode[143] = strings_1.toCharCode("\u2018");
    pdfDocEncodingToUnicode[144] = strings_1.toCharCode("\u2019");
    pdfDocEncodingToUnicode[145] = strings_1.toCharCode("\u201A");
    pdfDocEncodingToUnicode[146] = strings_1.toCharCode("\u2122");
    pdfDocEncodingToUnicode[147] = strings_1.toCharCode("\uFB01");
    pdfDocEncodingToUnicode[148] = strings_1.toCharCode("\uFB02");
    pdfDocEncodingToUnicode[149] = strings_1.toCharCode("\u0141");
    pdfDocEncodingToUnicode[150] = strings_1.toCharCode("\u0152");
    pdfDocEncodingToUnicode[151] = strings_1.toCharCode("\u0160");
    pdfDocEncodingToUnicode[152] = strings_1.toCharCode("\u0178");
    pdfDocEncodingToUnicode[153] = strings_1.toCharCode("\u017D");
    pdfDocEncodingToUnicode[154] = strings_1.toCharCode("\u0131");
    pdfDocEncodingToUnicode[155] = strings_1.toCharCode("\u0142");
    pdfDocEncodingToUnicode[156] = strings_1.toCharCode("\u0153");
    pdfDocEncodingToUnicode[157] = strings_1.toCharCode("\u0161");
    pdfDocEncodingToUnicode[158] = strings_1.toCharCode("\u017E");
    pdfDocEncodingToUnicode[159] = strings_1.toCharCode("\uFFFD");
    pdfDocEncodingToUnicode[160] = strings_1.toCharCode("\u20AC");
    pdfDocEncodingToUnicode[173] = strings_1.toCharCode("\uFFFD");
    exports.pdfDocEncodingDecode = function(bytes) {
      var codePoints = new Array(bytes.length);
      for (var idx2 = 0, len = bytes.length; idx2 < len; idx2++) {
        codePoints[idx2] = pdfDocEncodingToUnicode[bytes[idx2]];
      }
      return String.fromCodePoint.apply(String, codePoints);
    };
  }
});

// node_modules/pdf-lib/cjs/utils/Cache.js
var require_Cache = __commonJS({
  "node_modules/pdf-lib/cjs/utils/Cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Cache = (
      /** @class */
      function() {
        function Cache2(populate) {
          this.populate = populate;
          this.value = void 0;
        }
        Cache2.prototype.getValue = function() {
          return this.value;
        };
        Cache2.prototype.access = function() {
          if (!this.value)
            this.value = this.populate();
          return this.value;
        };
        Cache2.prototype.invalidate = function() {
          this.value = void 0;
        };
        Cache2.populatedBy = function(populate) {
          return new Cache2(populate);
        };
        return Cache2;
      }()
    );
    exports.default = Cache;
  }
});

// node_modules/pdf-lib/cjs/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/pdf-lib/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_arrays(), exports);
    tslib_1.__exportStar(require_async(), exports);
    tslib_1.__exportStar(require_strings(), exports);
    tslib_1.__exportStar(require_unicode(), exports);
    tslib_1.__exportStar(require_numbers(), exports);
    tslib_1.__exportStar(require_errors(), exports);
    tslib_1.__exportStar(require_base64(), exports);
    tslib_1.__exportStar(require_objects(), exports);
    tslib_1.__exportStar(require_validators(), exports);
    tslib_1.__exportStar(require_pdfDocEncoding(), exports);
    var Cache_1 = require_Cache();
    Object.defineProperty(exports, "Cache", { enumerable: true, get: function() {
      return Cache_1.default;
    } });
  }
});

// node_modules/pdf-lib/cjs/core/errors.js
var require_errors2 = __commonJS({
  "node_modules/pdf-lib/cjs/core/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingKeywordError = exports.MissingPDFHeaderError = exports.StalledParserError = exports.UnbalancedParenthesisError = exports.PDFStreamParsingError = exports.PDFInvalidObjectParsingError = exports.PDFObjectParsingError = exports.NextByteAssertionError = exports.PDFParsingError = exports.NumberParsingError = exports.MissingTfOperatorError = exports.MissingDAEntryError = exports.MultiSelectValueError = exports.InvalidAcroFieldValueError = exports.IndexOutOfBoundsError = exports.CorruptPageTreeError = exports.InvalidTargetIndexError = exports.InvalidPDFDateStringError = exports.PDFArrayIsNotRectangleError = exports.PageEmbeddingMismatchedContextError = exports.UnrecognizedStreamTypeError = exports.MissingPageContentsEmbeddingError = exports.MissingCatalogError = exports.ReparseError = exports.UnsupportedEncodingError = exports.UnexpectedObjectTypeError = exports.PrivateConstructorError = exports.MethodNotImplementedError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utils_1 = require_utils2();
    var MethodNotImplementedError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MethodNotImplementedError2, _super);
        function MethodNotImplementedError2(className, methodName) {
          var _this = this;
          var msg = "Method " + className + "." + methodName + "() not implemented";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MethodNotImplementedError2;
      }(Error)
    );
    exports.MethodNotImplementedError = MethodNotImplementedError;
    var PrivateConstructorError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PrivateConstructorError2, _super);
        function PrivateConstructorError2(className) {
          var _this = this;
          var msg = "Cannot construct " + className + " - it has a private constructor";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PrivateConstructorError2;
      }(Error)
    );
    exports.PrivateConstructorError = PrivateConstructorError;
    var UnexpectedObjectTypeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnexpectedObjectTypeError2, _super);
        function UnexpectedObjectTypeError2(expected, actual) {
          var _this = this;
          var name = function(t) {
            var _a, _b;
            return (_a = t === null || t === void 0 ? void 0 : t.name) !== null && _a !== void 0 ? _a : (_b = t === null || t === void 0 ? void 0 : t.constructor) === null || _b === void 0 ? void 0 : _b.name;
          };
          var expectedTypes = Array.isArray(expected) ? expected.map(name) : [name(expected)];
          var msg = "Expected instance of " + expectedTypes.join(" or ") + ", " + ("but got instance of " + (actual ? name(actual) : actual));
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnexpectedObjectTypeError2;
      }(Error)
    );
    exports.UnexpectedObjectTypeError = UnexpectedObjectTypeError;
    var UnsupportedEncodingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnsupportedEncodingError2, _super);
        function UnsupportedEncodingError2(encoding) {
          var _this = this;
          var msg = encoding + " stream encoding not supported";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnsupportedEncodingError2;
      }(Error)
    );
    exports.UnsupportedEncodingError = UnsupportedEncodingError;
    var ReparseError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ReparseError2, _super);
        function ReparseError2(className, methodName) {
          var _this = this;
          var msg = "Cannot call " + className + "." + methodName + "() more than once";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return ReparseError2;
      }(Error)
    );
    exports.ReparseError = ReparseError;
    var MissingCatalogError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingCatalogError2, _super);
        function MissingCatalogError2(ref) {
          var _this = this;
          var msg = "Missing catalog (ref=" + ref + ")";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingCatalogError2;
      }(Error)
    );
    exports.MissingCatalogError = MissingCatalogError;
    var MissingPageContentsEmbeddingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingPageContentsEmbeddingError2, _super);
        function MissingPageContentsEmbeddingError2() {
          var _this = this;
          var msg = "Can't embed page with missing Contents";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingPageContentsEmbeddingError2;
      }(Error)
    );
    exports.MissingPageContentsEmbeddingError = MissingPageContentsEmbeddingError;
    var UnrecognizedStreamTypeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnrecognizedStreamTypeError2, _super);
        function UnrecognizedStreamTypeError2(stream) {
          var _a, _b, _c;
          var _this = this;
          var streamType = (_c = (_b = (_a = stream === null || stream === void 0 ? void 0 : stream.contructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : stream === null || stream === void 0 ? void 0 : stream.name) !== null && _c !== void 0 ? _c : stream;
          var msg = "Unrecognized stream type: " + streamType;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnrecognizedStreamTypeError2;
      }(Error)
    );
    exports.UnrecognizedStreamTypeError = UnrecognizedStreamTypeError;
    var PageEmbeddingMismatchedContextError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PageEmbeddingMismatchedContextError2, _super);
        function PageEmbeddingMismatchedContextError2() {
          var _this = this;
          var msg = "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PageEmbeddingMismatchedContextError2;
      }(Error)
    );
    exports.PageEmbeddingMismatchedContextError = PageEmbeddingMismatchedContextError;
    var PDFArrayIsNotRectangleError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFArrayIsNotRectangleError2, _super);
        function PDFArrayIsNotRectangleError2(size) {
          var _this = this;
          var msg = "Attempted to convert PDFArray with " + size + " elements to rectangle, but must have exactly 4 elements.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PDFArrayIsNotRectangleError2;
      }(Error)
    );
    exports.PDFArrayIsNotRectangleError = PDFArrayIsNotRectangleError;
    var InvalidPDFDateStringError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidPDFDateStringError2, _super);
        function InvalidPDFDateStringError2(value) {
          var _this = this;
          var msg = 'Attempted to convert "' + value + '" to a date, but it does not match the PDF date string format.';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidPDFDateStringError2;
      }(Error)
    );
    exports.InvalidPDFDateStringError = InvalidPDFDateStringError;
    var InvalidTargetIndexError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidTargetIndexError2, _super);
        function InvalidTargetIndexError2(targetIndex, Count) {
          var _this = this;
          var msg = "Invalid targetIndex specified: targetIndex=" + targetIndex + " must be less than Count=" + Count;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidTargetIndexError2;
      }(Error)
    );
    exports.InvalidTargetIndexError = InvalidTargetIndexError;
    var CorruptPageTreeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(CorruptPageTreeError2, _super);
        function CorruptPageTreeError2(targetIndex, operation) {
          var _this = this;
          var msg = "Failed to " + operation + " at targetIndex=" + targetIndex + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return CorruptPageTreeError2;
      }(Error)
    );
    exports.CorruptPageTreeError = CorruptPageTreeError;
    var IndexOutOfBoundsError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(IndexOutOfBoundsError2, _super);
        function IndexOutOfBoundsError2(index, min2, max2) {
          var _this = this;
          var msg = "index should be at least " + min2 + " and at most " + max2 + ", but was actually " + index;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return IndexOutOfBoundsError2;
      }(Error)
    );
    exports.IndexOutOfBoundsError = IndexOutOfBoundsError;
    var InvalidAcroFieldValueError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidAcroFieldValueError2, _super);
        function InvalidAcroFieldValueError2() {
          var _this = this;
          var msg = "Attempted to set invalid field value";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidAcroFieldValueError2;
      }(Error)
    );
    exports.InvalidAcroFieldValueError = InvalidAcroFieldValueError;
    var MultiSelectValueError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MultiSelectValueError2, _super);
        function MultiSelectValueError2() {
          var _this = this;
          var msg = "Attempted to select multiple values for single-select field";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MultiSelectValueError2;
      }(Error)
    );
    exports.MultiSelectValueError = MultiSelectValueError;
    var MissingDAEntryError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingDAEntryError2, _super);
        function MissingDAEntryError2(fieldName) {
          var _this = this;
          var msg = "No /DA (default appearance) entry found for field: " + fieldName;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingDAEntryError2;
      }(Error)
    );
    exports.MissingDAEntryError = MissingDAEntryError;
    var MissingTfOperatorError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingTfOperatorError2, _super);
        function MissingTfOperatorError2(fieldName) {
          var _this = this;
          var msg = "No Tf operator found for DA of field: " + fieldName;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingTfOperatorError2;
      }(Error)
    );
    exports.MissingTfOperatorError = MissingTfOperatorError;
    var NumberParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(NumberParsingError2, _super);
        function NumberParsingError2(pos, value) {
          var _this = this;
          var msg = "Failed to parse number " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + '): "' + value + '"');
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return NumberParsingError2;
      }(Error)
    );
    exports.NumberParsingError = NumberParsingError;
    var PDFParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFParsingError2, _super);
        function PDFParsingError2(pos, details) {
          var _this = this;
          var msg = "Failed to parse PDF document " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + "): " + details);
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PDFParsingError2;
      }(Error)
    );
    exports.PDFParsingError = PDFParsingError;
    var NextByteAssertionError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(NextByteAssertionError2, _super);
        function NextByteAssertionError2(pos, expectedByte, actualByte) {
          var _this = this;
          var msg = "Expected next byte to be " + expectedByte + " but it was actually " + actualByte;
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return NextByteAssertionError2;
      }(PDFParsingError)
    );
    exports.NextByteAssertionError = NextByteAssertionError;
    var PDFObjectParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectParsingError2, _super);
        function PDFObjectParsingError2(pos, byte) {
          var _this = this;
          var msg = "Failed to parse PDF object starting with the following byte: " + byte;
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return PDFObjectParsingError2;
      }(PDFParsingError)
    );
    exports.PDFObjectParsingError = PDFObjectParsingError;
    var PDFInvalidObjectParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFInvalidObjectParsingError2, _super);
        function PDFInvalidObjectParsingError2(pos) {
          var _this = this;
          var msg = "Failed to parse invalid PDF object";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return PDFInvalidObjectParsingError2;
      }(PDFParsingError)
    );
    exports.PDFInvalidObjectParsingError = PDFInvalidObjectParsingError;
    var PDFStreamParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFStreamParsingError2, _super);
        function PDFStreamParsingError2(pos) {
          var _this = this;
          var msg = "Failed to parse PDF stream";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return PDFStreamParsingError2;
      }(PDFParsingError)
    );
    exports.PDFStreamParsingError = PDFStreamParsingError;
    var UnbalancedParenthesisError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnbalancedParenthesisError2, _super);
        function UnbalancedParenthesisError2(pos) {
          var _this = this;
          var msg = "Failed to parse PDF literal string due to unbalanced parenthesis";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return UnbalancedParenthesisError2;
      }(PDFParsingError)
    );
    exports.UnbalancedParenthesisError = UnbalancedParenthesisError;
    var StalledParserError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(StalledParserError2, _super);
        function StalledParserError2(pos) {
          var _this = this;
          var msg = "Parser stalled";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return StalledParserError2;
      }(PDFParsingError)
    );
    exports.StalledParserError = StalledParserError;
    var MissingPDFHeaderError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingPDFHeaderError2, _super);
        function MissingPDFHeaderError2(pos) {
          var _this = this;
          var msg = "No PDF header found";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return MissingPDFHeaderError2;
      }(PDFParsingError)
    );
    exports.MissingPDFHeaderError = MissingPDFHeaderError;
    var MissingKeywordError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingKeywordError2, _super);
        function MissingKeywordError2(pos, keyword) {
          var _this = this;
          var msg = "Did not find expected keyword '" + utils_1.arrayAsString(keyword) + "'";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return MissingKeywordError2;
      }(PDFParsingError)
    );
    exports.MissingKeywordError = MissingKeywordError;
  }
});

// node_modules/pdf-lib/cjs/core/syntax/CharCodes.js
var require_CharCodes = __commonJS({
  "node_modules/pdf-lib/cjs/core/syntax/CharCodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["Null"] = 0] = "Null";
      CharCodes2[CharCodes2["Backspace"] = 8] = "Backspace";
      CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
      CharCodes2[CharCodes2["Newline"] = 10] = "Newline";
      CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
      CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes2[CharCodes2["Space"] = 32] = "Space";
      CharCodes2[CharCodes2["ExclamationPoint"] = 33] = "ExclamationPoint";
      CharCodes2[CharCodes2["Hash"] = 35] = "Hash";
      CharCodes2[CharCodes2["Percent"] = 37] = "Percent";
      CharCodes2[CharCodes2["LeftParen"] = 40] = "LeftParen";
      CharCodes2[CharCodes2["RightParen"] = 41] = "RightParen";
      CharCodes2[CharCodes2["Plus"] = 43] = "Plus";
      CharCodes2[CharCodes2["Minus"] = 45] = "Minus";
      CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
      CharCodes2[CharCodes2["Period"] = 46] = "Period";
      CharCodes2[CharCodes2["ForwardSlash"] = 47] = "ForwardSlash";
      CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
      CharCodes2[CharCodes2["One"] = 49] = "One";
      CharCodes2[CharCodes2["Two"] = 50] = "Two";
      CharCodes2[CharCodes2["Three"] = 51] = "Three";
      CharCodes2[CharCodes2["Four"] = 52] = "Four";
      CharCodes2[CharCodes2["Five"] = 53] = "Five";
      CharCodes2[CharCodes2["Six"] = 54] = "Six";
      CharCodes2[CharCodes2["Seven"] = 55] = "Seven";
      CharCodes2[CharCodes2["Eight"] = 56] = "Eight";
      CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
      CharCodes2[CharCodes2["LessThan"] = 60] = "LessThan";
      CharCodes2[CharCodes2["GreaterThan"] = 62] = "GreaterThan";
      CharCodes2[CharCodes2["A"] = 65] = "A";
      CharCodes2[CharCodes2["D"] = 68] = "D";
      CharCodes2[CharCodes2["E"] = 69] = "E";
      CharCodes2[CharCodes2["F"] = 70] = "F";
      CharCodes2[CharCodes2["O"] = 79] = "O";
      CharCodes2[CharCodes2["P"] = 80] = "P";
      CharCodes2[CharCodes2["R"] = 82] = "R";
      CharCodes2[CharCodes2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
      CharCodes2[CharCodes2["BackSlash"] = 92] = "BackSlash";
      CharCodes2[CharCodes2["RightSquareBracket"] = 93] = "RightSquareBracket";
      CharCodes2[CharCodes2["a"] = 97] = "a";
      CharCodes2[CharCodes2["b"] = 98] = "b";
      CharCodes2[CharCodes2["d"] = 100] = "d";
      CharCodes2[CharCodes2["e"] = 101] = "e";
      CharCodes2[CharCodes2["f"] = 102] = "f";
      CharCodes2[CharCodes2["i"] = 105] = "i";
      CharCodes2[CharCodes2["j"] = 106] = "j";
      CharCodes2[CharCodes2["l"] = 108] = "l";
      CharCodes2[CharCodes2["m"] = 109] = "m";
      CharCodes2[CharCodes2["n"] = 110] = "n";
      CharCodes2[CharCodes2["o"] = 111] = "o";
      CharCodes2[CharCodes2["r"] = 114] = "r";
      CharCodes2[CharCodes2["s"] = 115] = "s";
      CharCodes2[CharCodes2["t"] = 116] = "t";
      CharCodes2[CharCodes2["u"] = 117] = "u";
      CharCodes2[CharCodes2["x"] = 120] = "x";
      CharCodes2[CharCodes2["LeftCurly"] = 123] = "LeftCurly";
      CharCodes2[CharCodes2["RightCurly"] = 125] = "RightCurly";
      CharCodes2[CharCodes2["Tilde"] = 126] = "Tilde";
    })(CharCodes || (CharCodes = {}));
    exports.default = CharCodes;
  }
});

// node_modules/pdf-lib/cjs/core/document/PDFHeader.js
var require_PDFHeader = __commonJS({
  "node_modules/pdf-lib/cjs/core/document/PDFHeader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFHeader = (
      /** @class */
      function() {
        function PDFHeader2(major, minor) {
          this.major = String(major);
          this.minor = String(minor);
        }
        PDFHeader2.prototype.toString = function() {
          var bc = utils_1.charFromCode(129);
          return "%PDF-" + this.major + "." + this.minor + "\n%" + bc + bc + bc + bc;
        };
        PDFHeader2.prototype.sizeInBytes = function() {
          return 12 + this.major.length + this.minor.length;
        };
        PDFHeader2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = CharCodes_1.default.P;
          buffer[offset2++] = CharCodes_1.default.D;
          buffer[offset2++] = CharCodes_1.default.F;
          buffer[offset2++] = CharCodes_1.default.Dash;
          offset2 += utils_1.copyStringIntoBuffer(this.major, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Period;
          offset2 += utils_1.copyStringIntoBuffer(this.minor, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = 129;
          buffer[offset2++] = 129;
          buffer[offset2++] = 129;
          buffer[offset2++] = 129;
          return offset2 - initialOffset;
        };
        PDFHeader2.forVersion = function(major, minor) {
          return new PDFHeader2(major, minor);
        };
        return PDFHeader2;
      }()
    );
    exports.default = PDFHeader;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFObject.js
var require_PDFObject = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors2();
    var PDFObject = (
      /** @class */
      function() {
        function PDFObject2() {
        }
        PDFObject2.prototype.clone = function(_context) {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "clone");
        };
        PDFObject2.prototype.toString = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "toString");
        };
        PDFObject2.prototype.sizeInBytes = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "sizeInBytes");
        };
        PDFObject2.prototype.copyBytesInto = function(_buffer, _offset) {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "copyBytesInto");
        };
        return PDFObject2;
      }()
    );
    exports.default = PDFObject;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFNumber.js
var require_PDFNumber = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var index_1 = require_utils2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var PDFNumber = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFNumber2, _super);
        function PDFNumber2(value) {
          var _this = _super.call(this) || this;
          _this.numberValue = value;
          _this.stringValue = index_1.numberToString(value);
          return _this;
        }
        PDFNumber2.prototype.asNumber = function() {
          return this.numberValue;
        };
        PDFNumber2.prototype.value = function() {
          return this.numberValue;
        };
        PDFNumber2.prototype.clone = function() {
          return PDFNumber2.of(this.numberValue);
        };
        PDFNumber2.prototype.toString = function() {
          return this.stringValue;
        };
        PDFNumber2.prototype.sizeInBytes = function() {
          return this.stringValue.length;
        };
        PDFNumber2.prototype.copyBytesInto = function(buffer, offset2) {
          offset2 += index_1.copyStringIntoBuffer(this.stringValue, buffer, offset2);
          return this.stringValue.length;
        };
        PDFNumber2.of = function(value) {
          return new PDFNumber2(value);
        };
        return PDFNumber2;
      }(PDFObject_1.default)
    );
    exports.default = PDFNumber;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFArray.js
var require_PDFArray = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var errors_1 = require_errors2();
    var PDFArray = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFArray2, _super);
        function PDFArray2(context) {
          var _this = _super.call(this) || this;
          _this.array = [];
          _this.context = context;
          return _this;
        }
        PDFArray2.prototype.size = function() {
          return this.array.length;
        };
        PDFArray2.prototype.push = function(object) {
          this.array.push(object);
        };
        PDFArray2.prototype.insert = function(index, object) {
          this.array.splice(index, 0, object);
        };
        PDFArray2.prototype.indexOf = function(object) {
          var index = this.array.indexOf(object);
          return index === -1 ? void 0 : index;
        };
        PDFArray2.prototype.remove = function(index) {
          this.array.splice(index, 1);
        };
        PDFArray2.prototype.set = function(idx, object) {
          this.array[idx] = object;
        };
        PDFArray2.prototype.get = function(index) {
          return this.array[index];
        };
        PDFArray2.prototype.lookupMaybe = function(index) {
          var _a;
          var types = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
          }
          return (_a = this.context).lookupMaybe.apply(_a, tslib_1.__spreadArrays([this.get(index)], types));
        };
        PDFArray2.prototype.lookup = function(index) {
          var _a;
          var types = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
          }
          return (_a = this.context).lookup.apply(_a, tslib_1.__spreadArrays([this.get(index)], types));
        };
        PDFArray2.prototype.asRectangle = function() {
          if (this.size() !== 4)
            throw new errors_1.PDFArrayIsNotRectangleError(this.size());
          var lowerLeftX = this.lookup(0, PDFNumber_1.default).asNumber();
          var lowerLeftY = this.lookup(1, PDFNumber_1.default).asNumber();
          var upperRightX = this.lookup(2, PDFNumber_1.default).asNumber();
          var upperRightY = this.lookup(3, PDFNumber_1.default).asNumber();
          var x = lowerLeftX;
          var y = lowerLeftY;
          var width = upperRightX - lowerLeftX;
          var height = upperRightY - lowerLeftY;
          return { x, y, width, height };
        };
        PDFArray2.prototype.asArray = function() {
          return this.array.slice();
        };
        PDFArray2.prototype.clone = function(context) {
          var clone = PDFArray2.withContext(context || this.context);
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            clone.push(this.array[idx]);
          }
          return clone;
        };
        PDFArray2.prototype.toString = function() {
          var arrayString = "[ ";
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            arrayString += this.get(idx).toString();
            arrayString += " ";
          }
          arrayString += "]";
          return arrayString;
        };
        PDFArray2.prototype.sizeInBytes = function() {
          var size = 3;
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            size += this.get(idx).sizeInBytes() + 1;
          }
          return size;
        };
        PDFArray2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.LeftSquareBracket;
          buffer[offset2++] = CharCodes_1.default.Space;
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            offset2 += this.get(idx).copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
          }
          buffer[offset2++] = CharCodes_1.default.RightSquareBracket;
          return offset2 - initialOffset;
        };
        PDFArray2.prototype.scalePDFNumbers = function(x, y) {
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            var el = this.lookup(idx);
            if (el instanceof PDFNumber_1.default) {
              var factor = idx % 2 === 0 ? x : y;
              this.set(idx, PDFNumber_1.default.of(el.asNumber() * factor));
            }
          }
        };
        PDFArray2.withContext = function(context) {
          return new PDFArray2(context);
        };
        return PDFArray2;
      }(PDFObject_1.default)
    );
    exports.default = PDFArray;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFBool.js
var require_PDFBool = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFBool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var ENFORCER = {};
    var PDFBool = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFBool2, _super);
        function PDFBool2(enforcer, value) {
          var _this = this;
          if (enforcer !== ENFORCER)
            throw new errors_1.PrivateConstructorError("PDFBool");
          _this = _super.call(this) || this;
          _this.value = value;
          return _this;
        }
        PDFBool2.prototype.asBoolean = function() {
          return this.value;
        };
        PDFBool2.prototype.clone = function() {
          return this;
        };
        PDFBool2.prototype.toString = function() {
          return String(this.value);
        };
        PDFBool2.prototype.sizeInBytes = function() {
          return this.value ? 4 : 5;
        };
        PDFBool2.prototype.copyBytesInto = function(buffer, offset2) {
          if (this.value) {
            buffer[offset2++] = CharCodes_1.default.t;
            buffer[offset2++] = CharCodes_1.default.r;
            buffer[offset2++] = CharCodes_1.default.u;
            buffer[offset2++] = CharCodes_1.default.e;
            return 4;
          } else {
            buffer[offset2++] = CharCodes_1.default.f;
            buffer[offset2++] = CharCodes_1.default.a;
            buffer[offset2++] = CharCodes_1.default.l;
            buffer[offset2++] = CharCodes_1.default.s;
            buffer[offset2++] = CharCodes_1.default.e;
            return 5;
          }
        };
        PDFBool2.True = new PDFBool2(ENFORCER, true);
        PDFBool2.False = new PDFBool2(ENFORCER, false);
        return PDFBool2;
      }(PDFObject_1.default)
    );
    exports.default = PDFBool;
  }
});

// node_modules/pdf-lib/cjs/core/syntax/Delimiters.js
var require_Delimiters = __commonJS({
  "node_modules/pdf-lib/cjs/core/syntax/Delimiters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsDelimiter = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    exports.IsDelimiter = new Uint8Array(256);
    exports.IsDelimiter[CharCodes_1.default.LeftParen] = 1;
    exports.IsDelimiter[CharCodes_1.default.RightParen] = 1;
    exports.IsDelimiter[CharCodes_1.default.LessThan] = 1;
    exports.IsDelimiter[CharCodes_1.default.GreaterThan] = 1;
    exports.IsDelimiter[CharCodes_1.default.LeftSquareBracket] = 1;
    exports.IsDelimiter[CharCodes_1.default.RightSquareBracket] = 1;
    exports.IsDelimiter[CharCodes_1.default.LeftCurly] = 1;
    exports.IsDelimiter[CharCodes_1.default.RightCurly] = 1;
    exports.IsDelimiter[CharCodes_1.default.ForwardSlash] = 1;
    exports.IsDelimiter[CharCodes_1.default.Percent] = 1;
  }
});

// node_modules/pdf-lib/cjs/core/syntax/Whitespace.js
var require_Whitespace = __commonJS({
  "node_modules/pdf-lib/cjs/core/syntax/Whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsWhitespace = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    exports.IsWhitespace = new Uint8Array(256);
    exports.IsWhitespace[CharCodes_1.default.Null] = 1;
    exports.IsWhitespace[CharCodes_1.default.Tab] = 1;
    exports.IsWhitespace[CharCodes_1.default.Newline] = 1;
    exports.IsWhitespace[CharCodes_1.default.FormFeed] = 1;
    exports.IsWhitespace[CharCodes_1.default.CarriageReturn] = 1;
    exports.IsWhitespace[CharCodes_1.default.Space] = 1;
  }
});

// node_modules/pdf-lib/cjs/core/syntax/Irregular.js
var require_Irregular = __commonJS({
  "node_modules/pdf-lib/cjs/core/syntax/Irregular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsIrregular = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Delimiters_1 = require_Delimiters();
    var Whitespace_1 = require_Whitespace();
    exports.IsIrregular = new Uint8Array(256);
    for (idx = 0, len = 256; idx < len; idx++) {
      exports.IsIrregular[idx] = Whitespace_1.IsWhitespace[idx] || Delimiters_1.IsDelimiter[idx] ? 1 : 0;
    }
    var idx;
    var len;
    exports.IsIrregular[CharCodes_1.default.Hash] = 1;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFName.js
var require_PDFName = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Irregular_1 = require_Irregular();
    var utils_1 = require_utils2();
    var decodeName = function(name) {
      return name.replace(/#([\dABCDEF]{2})/g, function(_, hex) {
        return utils_1.charFromHexCode(hex);
      });
    };
    var isRegularChar = function(charCode) {
      return charCode >= CharCodes_1.default.ExclamationPoint && charCode <= CharCodes_1.default.Tilde && !Irregular_1.IsIrregular[charCode];
    };
    var ENFORCER = {};
    var pool = /* @__PURE__ */ new Map();
    var PDFName = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFName2, _super);
        function PDFName2(enforcer, name) {
          var _this = this;
          if (enforcer !== ENFORCER)
            throw new errors_1.PrivateConstructorError("PDFName");
          _this = _super.call(this) || this;
          var encodedName = "/";
          for (var idx = 0, len = name.length; idx < len; idx++) {
            var character = name[idx];
            var code = utils_1.toCharCode(character);
            encodedName += isRegularChar(code) ? character : "#" + utils_1.toHexString(code);
          }
          _this.encodedName = encodedName;
          return _this;
        }
        PDFName2.prototype.asBytes = function() {
          var bytes = [];
          var hex = "";
          var escaped = false;
          var pushByte = function(byte2) {
            if (byte2 !== void 0)
              bytes.push(byte2);
            escaped = false;
          };
          for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {
            var char = this.encodedName[idx];
            var byte = utils_1.toCharCode(char);
            var nextChar = this.encodedName[idx + 1];
            if (!escaped) {
              if (byte === CharCodes_1.default.Hash)
                escaped = true;
              else
                pushByte(byte);
            } else {
              if (byte >= CharCodes_1.default.Zero && byte <= CharCodes_1.default.Nine || byte >= CharCodes_1.default.a && byte <= CharCodes_1.default.f || byte >= CharCodes_1.default.A && byte <= CharCodes_1.default.F) {
                hex += char;
                if (hex.length === 2 || !(nextChar >= "0" && nextChar <= "9" || nextChar >= "a" && nextChar <= "f" || nextChar >= "A" && nextChar <= "F")) {
                  pushByte(parseInt(hex, 16));
                  hex = "";
                }
              } else {
                pushByte(byte);
              }
            }
          }
          return new Uint8Array(bytes);
        };
        PDFName2.prototype.decodeText = function() {
          var bytes = this.asBytes();
          return String.fromCharCode.apply(String, Array.from(bytes));
        };
        PDFName2.prototype.asString = function() {
          return this.encodedName;
        };
        PDFName2.prototype.value = function() {
          return this.encodedName;
        };
        PDFName2.prototype.clone = function() {
          return this;
        };
        PDFName2.prototype.toString = function() {
          return this.encodedName;
        };
        PDFName2.prototype.sizeInBytes = function() {
          return this.encodedName.length;
        };
        PDFName2.prototype.copyBytesInto = function(buffer, offset2) {
          offset2 += utils_1.copyStringIntoBuffer(this.encodedName, buffer, offset2);
          return this.encodedName.length;
        };
        PDFName2.of = function(name) {
          var decodedValue = decodeName(name);
          var instance = pool.get(decodedValue);
          if (!instance) {
            instance = new PDFName2(ENFORCER, decodedValue);
            pool.set(decodedValue, instance);
          }
          return instance;
        };
        PDFName2.Length = PDFName2.of("Length");
        PDFName2.FlateDecode = PDFName2.of("FlateDecode");
        PDFName2.Resources = PDFName2.of("Resources");
        PDFName2.Font = PDFName2.of("Font");
        PDFName2.XObject = PDFName2.of("XObject");
        PDFName2.ExtGState = PDFName2.of("ExtGState");
        PDFName2.Contents = PDFName2.of("Contents");
        PDFName2.Type = PDFName2.of("Type");
        PDFName2.Parent = PDFName2.of("Parent");
        PDFName2.MediaBox = PDFName2.of("MediaBox");
        PDFName2.Page = PDFName2.of("Page");
        PDFName2.Annots = PDFName2.of("Annots");
        PDFName2.TrimBox = PDFName2.of("TrimBox");
        PDFName2.ArtBox = PDFName2.of("ArtBox");
        PDFName2.BleedBox = PDFName2.of("BleedBox");
        PDFName2.CropBox = PDFName2.of("CropBox");
        PDFName2.Rotate = PDFName2.of("Rotate");
        PDFName2.Title = PDFName2.of("Title");
        PDFName2.Author = PDFName2.of("Author");
        PDFName2.Subject = PDFName2.of("Subject");
        PDFName2.Creator = PDFName2.of("Creator");
        PDFName2.Keywords = PDFName2.of("Keywords");
        PDFName2.Producer = PDFName2.of("Producer");
        PDFName2.CreationDate = PDFName2.of("CreationDate");
        PDFName2.ModDate = PDFName2.of("ModDate");
        return PDFName2;
      }(PDFObject_1.default)
    );
    exports.default = PDFName;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFNull.js
var require_PDFNull = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFNull.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFNull = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFNull2, _super);
        function PDFNull2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFNull2.prototype.asNull = function() {
          return null;
        };
        PDFNull2.prototype.clone = function() {
          return this;
        };
        PDFNull2.prototype.toString = function() {
          return "null";
        };
        PDFNull2.prototype.sizeInBytes = function() {
          return 4;
        };
        PDFNull2.prototype.copyBytesInto = function(buffer, offset2) {
          buffer[offset2++] = CharCodes_1.default.n;
          buffer[offset2++] = CharCodes_1.default.u;
          buffer[offset2++] = CharCodes_1.default.l;
          buffer[offset2++] = CharCodes_1.default.l;
          return 4;
        };
        return PDFNull2;
      }(PDFObject_1.default)
    );
    exports.default = new PDFNull();
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFDict.js
var require_PDFDict = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNull_1 = tslib_1.__importDefault(require_PDFNull());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFDict = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFDict2, _super);
        function PDFDict2(map, context) {
          var _this = _super.call(this) || this;
          _this.dict = map;
          _this.context = context;
          return _this;
        }
        PDFDict2.prototype.keys = function() {
          return Array.from(this.dict.keys());
        };
        PDFDict2.prototype.values = function() {
          return Array.from(this.dict.values());
        };
        PDFDict2.prototype.entries = function() {
          return Array.from(this.dict.entries());
        };
        PDFDict2.prototype.set = function(key, value) {
          this.dict.set(key, value);
        };
        PDFDict2.prototype.get = function(key, preservePDFNull) {
          if (preservePDFNull === void 0) {
            preservePDFNull = false;
          }
          var value = this.dict.get(key);
          if (value === PDFNull_1.default && !preservePDFNull)
            return void 0;
          return value;
        };
        PDFDict2.prototype.has = function(key) {
          var value = this.dict.get(key);
          return value !== void 0 && value !== PDFNull_1.default;
        };
        PDFDict2.prototype.lookupMaybe = function(key) {
          var _a;
          var types = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
          }
          var preservePDFNull = types.includes(PDFNull_1.default);
          var value = (_a = this.context).lookupMaybe.apply(_a, tslib_1.__spreadArrays([this.get(key, preservePDFNull)], types));
          if (value === PDFNull_1.default && !preservePDFNull)
            return void 0;
          return value;
        };
        PDFDict2.prototype.lookup = function(key) {
          var _a;
          var types = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
          }
          var preservePDFNull = types.includes(PDFNull_1.default);
          var value = (_a = this.context).lookup.apply(_a, tslib_1.__spreadArrays([this.get(key, preservePDFNull)], types));
          if (value === PDFNull_1.default && !preservePDFNull)
            return void 0;
          return value;
        };
        PDFDict2.prototype.delete = function(key) {
          return this.dict.delete(key);
        };
        PDFDict2.prototype.asMap = function() {
          return new Map(this.dict);
        };
        PDFDict2.prototype.uniqueKey = function(tag) {
          if (tag === void 0) {
            tag = "";
          }
          var existingKeys = this.keys();
          var key = PDFName_1.default.of(this.context.addRandomSuffix(tag, 10));
          while (existingKeys.includes(key)) {
            key = PDFName_1.default.of(this.context.addRandomSuffix(tag, 10));
          }
          return key;
        };
        PDFDict2.prototype.clone = function(context) {
          var clone = PDFDict2.withContext(context || this.context);
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            clone.set(key, value);
          }
          return clone;
        };
        PDFDict2.prototype.toString = function() {
          var dictString = "<<\n";
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            dictString += key.toString() + " " + value.toString() + "\n";
          }
          dictString += ">>";
          return dictString;
        };
        PDFDict2.prototype.sizeInBytes = function() {
          var size = 5;
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            size += key.sizeInBytes() + value.sizeInBytes() + 2;
          }
          return size;
        };
        PDFDict2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.LessThan;
          buffer[offset2++] = CharCodes_1.default.LessThan;
          buffer[offset2++] = CharCodes_1.default.Newline;
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            offset2 += key.copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            offset2 += value.copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          buffer[offset2++] = CharCodes_1.default.GreaterThan;
          buffer[offset2++] = CharCodes_1.default.GreaterThan;
          return offset2 - initialOffset;
        };
        PDFDict2.withContext = function(context) {
          return new PDFDict2(/* @__PURE__ */ new Map(), context);
        };
        PDFDict2.fromMapWithContext = function(map, context) {
          return new PDFDict2(map, context);
        };
        return PDFDict2;
      }(PDFObject_1.default)
    );
    exports.default = PDFDict;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFStream.js
var require_PDFStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFStream2, _super);
        function PDFStream2(dict) {
          var _this = _super.call(this) || this;
          _this.dict = dict;
          return _this;
        }
        PDFStream2.prototype.clone = function(_context) {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "clone");
        };
        PDFStream2.prototype.getContentsString = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getContentsString");
        };
        PDFStream2.prototype.getContents = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getContents");
        };
        PDFStream2.prototype.getContentsSize = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getContentsSize");
        };
        PDFStream2.prototype.updateDict = function() {
          var contentsSize = this.getContentsSize();
          this.dict.set(PDFName_1.default.Length, PDFNumber_1.default.of(contentsSize));
        };
        PDFStream2.prototype.sizeInBytes = function() {
          this.updateDict();
          return this.dict.sizeInBytes() + this.getContentsSize() + 18;
        };
        PDFStream2.prototype.toString = function() {
          this.updateDict();
          var streamString = this.dict.toString();
          streamString += "\nstream\n";
          streamString += this.getContentsString();
          streamString += "\nendstream";
          return streamString;
        };
        PDFStream2.prototype.copyBytesInto = function(buffer, offset2) {
          this.updateDict();
          var initialOffset = offset2;
          offset2 += this.dict.copyBytesInto(buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.s;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.m;
          buffer[offset2++] = CharCodes_1.default.Newline;
          var contents = this.getContents();
          for (var idx = 0, len = contents.length; idx < len; idx++) {
            buffer[offset2++] = contents[idx];
          }
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.n;
          buffer[offset2++] = CharCodes_1.default.d;
          buffer[offset2++] = CharCodes_1.default.s;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.m;
          return offset2 - initialOffset;
        };
        return PDFStream2;
      }(PDFObject_1.default)
    );
    exports.default = PDFStream;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFRawStream.js
var require_PDFRawStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFRawStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var utils_1 = require_utils2();
    var PDFRawStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFRawStream2, _super);
        function PDFRawStream2(dict, contents) {
          var _this = _super.call(this, dict) || this;
          _this.contents = contents;
          return _this;
        }
        PDFRawStream2.prototype.asUint8Array = function() {
          return this.contents.slice();
        };
        PDFRawStream2.prototype.clone = function(context) {
          return PDFRawStream2.of(this.dict.clone(context), this.contents.slice());
        };
        PDFRawStream2.prototype.getContentsString = function() {
          return utils_1.arrayAsString(this.contents);
        };
        PDFRawStream2.prototype.getContents = function() {
          return this.contents;
        };
        PDFRawStream2.prototype.getContentsSize = function() {
          return this.contents.length;
        };
        PDFRawStream2.of = function(dict, contents) {
          return new PDFRawStream2(dict, contents);
        };
        return PDFRawStream2;
      }(PDFStream_1.default)
    );
    exports.default = PDFRawStream;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFRef.js
var require_PDFRef = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var utils_1 = require_utils2();
    var ENFORCER = {};
    var pool = /* @__PURE__ */ new Map();
    var PDFRef = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFRef2, _super);
        function PDFRef2(enforcer, objectNumber, generationNumber) {
          var _this = this;
          if (enforcer !== ENFORCER)
            throw new errors_1.PrivateConstructorError("PDFRef");
          _this = _super.call(this) || this;
          _this.objectNumber = objectNumber;
          _this.generationNumber = generationNumber;
          _this.tag = objectNumber + " " + generationNumber + " R";
          return _this;
        }
        PDFRef2.prototype.clone = function() {
          return this;
        };
        PDFRef2.prototype.toString = function() {
          return this.tag;
        };
        PDFRef2.prototype.sizeInBytes = function() {
          return this.tag.length;
        };
        PDFRef2.prototype.copyBytesInto = function(buffer, offset2) {
          offset2 += utils_1.copyStringIntoBuffer(this.tag, buffer, offset2);
          return this.tag.length;
        };
        PDFRef2.of = function(objectNumber, generationNumber) {
          if (generationNumber === void 0) {
            generationNumber = 0;
          }
          var tag = objectNumber + " " + generationNumber + " R";
          var instance = pool.get(tag);
          if (!instance) {
            instance = new PDFRef2(ENFORCER, objectNumber, generationNumber);
            pool.set(tag, instance);
          }
          return instance;
        };
        return PDFRef2;
      }(PDFObject_1.default)
    );
    exports.default = PDFRef;
  }
});

// node_modules/pdf-lib/cjs/core/operators/PDFOperator.js
var require_PDFOperator = __commonJS({
  "node_modules/pdf-lib/cjs/core/operators/PDFOperator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFOperator = (
      /** @class */
      function() {
        function PDFOperator2(name, args) {
          this.name = name;
          this.args = args || [];
        }
        PDFOperator2.prototype.clone = function(context) {
          var args = new Array(this.args.length);
          for (var idx = 0, len = args.length; idx < len; idx++) {
            var arg = this.args[idx];
            args[idx] = arg instanceof PDFObject_1.default ? arg.clone(context) : arg;
          }
          return PDFOperator2.of(this.name, args);
        };
        PDFOperator2.prototype.toString = function() {
          var value = "";
          for (var idx = 0, len = this.args.length; idx < len; idx++) {
            value += String(this.args[idx]) + " ";
          }
          value += this.name;
          return value;
        };
        PDFOperator2.prototype.sizeInBytes = function() {
          var size = 0;
          for (var idx = 0, len = this.args.length; idx < len; idx++) {
            var arg = this.args[idx];
            size += (arg instanceof PDFObject_1.default ? arg.sizeInBytes() : arg.length) + 1;
          }
          size += this.name.length;
          return size;
        };
        PDFOperator2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          for (var idx = 0, len = this.args.length; idx < len; idx++) {
            var arg = this.args[idx];
            if (arg instanceof PDFObject_1.default) {
              offset2 += arg.copyBytesInto(buffer, offset2);
            } else {
              offset2 += utils_1.copyStringIntoBuffer(arg, buffer, offset2);
            }
            buffer[offset2++] = CharCodes_1.default.Space;
          }
          offset2 += utils_1.copyStringIntoBuffer(this.name, buffer, offset2);
          return offset2 - initialOffset;
        };
        PDFOperator2.of = function(name, args) {
          return new PDFOperator2(name, args);
        };
        return PDFOperator2;
      }()
    );
    exports.default = PDFOperator;
  }
});

// node_modules/pdf-lib/cjs/core/operators/PDFOperatorNames.js
var require_PDFOperatorNames = __commonJS({
  "node_modules/pdf-lib/cjs/core/operators/PDFOperatorNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PDFOperatorNames;
    (function(PDFOperatorNames2) {
      PDFOperatorNames2["NonStrokingColor"] = "sc";
      PDFOperatorNames2["NonStrokingColorN"] = "scn";
      PDFOperatorNames2["NonStrokingColorRgb"] = "rg";
      PDFOperatorNames2["NonStrokingColorGray"] = "g";
      PDFOperatorNames2["NonStrokingColorCmyk"] = "k";
      PDFOperatorNames2["NonStrokingColorspace"] = "cs";
      PDFOperatorNames2["StrokingColor"] = "SC";
      PDFOperatorNames2["StrokingColorN"] = "SCN";
      PDFOperatorNames2["StrokingColorRgb"] = "RG";
      PDFOperatorNames2["StrokingColorGray"] = "G";
      PDFOperatorNames2["StrokingColorCmyk"] = "K";
      PDFOperatorNames2["StrokingColorspace"] = "CS";
      PDFOperatorNames2["BeginMarkedContentSequence"] = "BDC";
      PDFOperatorNames2["BeginMarkedContent"] = "BMC";
      PDFOperatorNames2["EndMarkedContent"] = "EMC";
      PDFOperatorNames2["MarkedContentPointWithProps"] = "DP";
      PDFOperatorNames2["MarkedContentPoint"] = "MP";
      PDFOperatorNames2["DrawObject"] = "Do";
      PDFOperatorNames2["ConcatTransformationMatrix"] = "cm";
      PDFOperatorNames2["PopGraphicsState"] = "Q";
      PDFOperatorNames2["PushGraphicsState"] = "q";
      PDFOperatorNames2["SetFlatness"] = "i";
      PDFOperatorNames2["SetGraphicsStateParams"] = "gs";
      PDFOperatorNames2["SetLineCapStyle"] = "J";
      PDFOperatorNames2["SetLineDashPattern"] = "d";
      PDFOperatorNames2["SetLineJoinStyle"] = "j";
      PDFOperatorNames2["SetLineMiterLimit"] = "M";
      PDFOperatorNames2["SetLineWidth"] = "w";
      PDFOperatorNames2["SetTextMatrix"] = "Tm";
      PDFOperatorNames2["SetRenderingIntent"] = "ri";
      PDFOperatorNames2["AppendRectangle"] = "re";
      PDFOperatorNames2["BeginInlineImage"] = "BI";
      PDFOperatorNames2["BeginInlineImageData"] = "ID";
      PDFOperatorNames2["EndInlineImage"] = "EI";
      PDFOperatorNames2["ClipEvenOdd"] = "W*";
      PDFOperatorNames2["ClipNonZero"] = "W";
      PDFOperatorNames2["CloseAndStroke"] = "s";
      PDFOperatorNames2["CloseFillEvenOddAndStroke"] = "b*";
      PDFOperatorNames2["CloseFillNonZeroAndStroke"] = "b";
      PDFOperatorNames2["ClosePath"] = "h";
      PDFOperatorNames2["AppendBezierCurve"] = "c";
      PDFOperatorNames2["CurveToReplicateFinalPoint"] = "y";
      PDFOperatorNames2["CurveToReplicateInitialPoint"] = "v";
      PDFOperatorNames2["EndPath"] = "n";
      PDFOperatorNames2["FillEvenOddAndStroke"] = "B*";
      PDFOperatorNames2["FillEvenOdd"] = "f*";
      PDFOperatorNames2["FillNonZeroAndStroke"] = "B";
      PDFOperatorNames2["FillNonZero"] = "f";
      PDFOperatorNames2["LegacyFillNonZero"] = "F";
      PDFOperatorNames2["LineTo"] = "l";
      PDFOperatorNames2["MoveTo"] = "m";
      PDFOperatorNames2["ShadingFill"] = "sh";
      PDFOperatorNames2["StrokePath"] = "S";
      PDFOperatorNames2["BeginText"] = "BT";
      PDFOperatorNames2["EndText"] = "ET";
      PDFOperatorNames2["MoveText"] = "Td";
      PDFOperatorNames2["MoveTextSetLeading"] = "TD";
      PDFOperatorNames2["NextLine"] = "T*";
      PDFOperatorNames2["SetCharacterSpacing"] = "Tc";
      PDFOperatorNames2["SetFontAndSize"] = "Tf";
      PDFOperatorNames2["SetTextHorizontalScaling"] = "Tz";
      PDFOperatorNames2["SetTextLineHeight"] = "TL";
      PDFOperatorNames2["SetTextRenderingMode"] = "Tr";
      PDFOperatorNames2["SetTextRise"] = "Ts";
      PDFOperatorNames2["SetWordSpacing"] = "Tw";
      PDFOperatorNames2["ShowText"] = "Tj";
      PDFOperatorNames2["ShowTextAdjusted"] = "TJ";
      PDFOperatorNames2["ShowTextLine"] = "'";
      PDFOperatorNames2["ShowTextLineAndSpace"] = '"';
      PDFOperatorNames2["Type3D0"] = "d0";
      PDFOperatorNames2["Type3D1"] = "d1";
      PDFOperatorNames2["BeginCompatibilitySection"] = "BX";
      PDFOperatorNames2["EndCompatibilitySection"] = "EX";
    })(PDFOperatorNames || (PDFOperatorNames = {}));
    exports.default = PDFOperatorNames;
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFFlateStream.js
var require_PDFFlateStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFFlateStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pako_1 = tslib_1.__importDefault(require_pako());
    var errors_1 = require_errors2();
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var utils_1 = require_utils2();
    var PDFFlateStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFFlateStream2, _super);
        function PDFFlateStream2(dict, encode) {
          var _this = _super.call(this, dict) || this;
          _this.computeContents = function() {
            var unencodedContents = _this.getUnencodedContents();
            return _this.encode ? pako_1.default.deflate(unencodedContents) : unencodedContents;
          };
          _this.encode = encode;
          if (encode)
            dict.set(PDFName_1.default.of("Filter"), PDFName_1.default.of("FlateDecode"));
          _this.contentsCache = utils_1.Cache.populatedBy(_this.computeContents);
          return _this;
        }
        PDFFlateStream2.prototype.getContents = function() {
          return this.contentsCache.access();
        };
        PDFFlateStream2.prototype.getContentsSize = function() {
          return this.contentsCache.access().length;
        };
        PDFFlateStream2.prototype.getUnencodedContents = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getUnencodedContents");
        };
        return PDFFlateStream2;
      }(PDFStream_1.default)
    );
    exports.default = PDFFlateStream;
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFContentStream.js
var require_PDFContentStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFContentStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFFlateStream_1 = tslib_1.__importDefault(require_PDFFlateStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFContentStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFContentStream2, _super);
        function PDFContentStream2(dict, operators, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var _this = _super.call(this, dict, encode) || this;
          _this.operators = operators;
          return _this;
        }
        PDFContentStream2.prototype.push = function() {
          var _a;
          var operators = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
          }
          (_a = this.operators).push.apply(_a, operators);
        };
        PDFContentStream2.prototype.clone = function(context) {
          var operators = new Array(this.operators.length);
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            operators[idx] = this.operators[idx].clone(context);
          }
          var _a = this, dict = _a.dict, encode = _a.encode;
          return PDFContentStream2.of(dict.clone(context), operators, encode);
        };
        PDFContentStream2.prototype.getContentsString = function() {
          var value = "";
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            value += this.operators[idx] + "\n";
          }
          return value;
        };
        PDFContentStream2.prototype.getUnencodedContents = function() {
          var buffer = new Uint8Array(this.getUnencodedContentsSize());
          var offset2 = 0;
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            offset2 += this.operators[idx].copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          return buffer;
        };
        PDFContentStream2.prototype.getUnencodedContentsSize = function() {
          var size = 0;
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            size += this.operators[idx].sizeInBytes() + 1;
          }
          return size;
        };
        PDFContentStream2.of = function(dict, operators, encode) {
          if (encode === void 0) {
            encode = true;
          }
          return new PDFContentStream2(dict, operators, encode);
        };
        return PDFContentStream2;
      }(PDFFlateStream_1.default)
    );
    exports.default = PDFContentStream;
  }
});

// node_modules/pdf-lib/cjs/utils/rng.js
var require_rng = __commonJS({
  "node_modules/pdf-lib/cjs/utils/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleRNG = void 0;
    var SimpleRNG = (
      /** @class */
      function() {
        function SimpleRNG2(seed) {
          this.seed = seed;
        }
        SimpleRNG2.prototype.nextInt = function() {
          var x = Math.sin(this.seed++) * 1e4;
          return x - Math.floor(x);
        };
        SimpleRNG2.withSeed = function(seed) {
          return new SimpleRNG2(seed);
        };
        return SimpleRNG2;
      }()
    );
    exports.SimpleRNG = SimpleRNG;
  }
});

// node_modules/pdf-lib/cjs/core/PDFContext.js
var require_PDFContext = __commonJS({
  "node_modules/pdf-lib/cjs/core/PDFContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pako_1 = tslib_1.__importDefault(require_pako());
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFBool_1 = tslib_1.__importDefault(require_PDFBool());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNull_1 = tslib_1.__importDefault(require_PDFNull());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFOperator_1 = tslib_1.__importDefault(require_PDFOperator());
    var PDFOperatorNames_1 = tslib_1.__importDefault(require_PDFOperatorNames());
    var PDFContentStream_1 = tslib_1.__importDefault(require_PDFContentStream());
    var utils_1 = require_utils2();
    var rng_1 = require_rng();
    var byAscendingObjectNumber = function(_a, _b) {
      var a = _a[0];
      var b = _b[0];
      return a.objectNumber - b.objectNumber;
    };
    var PDFContext = (
      /** @class */
      function() {
        function PDFContext2() {
          this.largestObjectNumber = 0;
          this.header = PDFHeader_1.default.forVersion(1, 7);
          this.trailerInfo = {};
          this.indirectObjects = /* @__PURE__ */ new Map();
          this.rng = rng_1.SimpleRNG.withSeed(1);
        }
        PDFContext2.prototype.assign = function(ref, object) {
          this.indirectObjects.set(ref, object);
          if (ref.objectNumber > this.largestObjectNumber) {
            this.largestObjectNumber = ref.objectNumber;
          }
        };
        PDFContext2.prototype.nextRef = function() {
          this.largestObjectNumber += 1;
          return PDFRef_1.default.of(this.largestObjectNumber);
        };
        PDFContext2.prototype.register = function(object) {
          var ref = this.nextRef();
          this.assign(ref, object);
          return ref;
        };
        PDFContext2.prototype.delete = function(ref) {
          return this.indirectObjects.delete(ref);
        };
        PDFContext2.prototype.lookupMaybe = function(ref) {
          var types = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
          }
          var preservePDFNull = types.includes(PDFNull_1.default);
          var result = ref instanceof PDFRef_1.default ? this.indirectObjects.get(ref) : ref;
          if (!result || result === PDFNull_1.default && !preservePDFNull)
            return void 0;
          for (var idx = 0, len = types.length; idx < len; idx++) {
            var type = types[idx];
            if (type === PDFNull_1.default) {
              if (result === PDFNull_1.default)
                return result;
            } else {
              if (result instanceof type)
                return result;
            }
          }
          throw new errors_1.UnexpectedObjectTypeError(types, result);
        };
        PDFContext2.prototype.lookup = function(ref) {
          var types = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
          }
          var result = ref instanceof PDFRef_1.default ? this.indirectObjects.get(ref) : ref;
          if (types.length === 0)
            return result;
          for (var idx = 0, len = types.length; idx < len; idx++) {
            var type = types[idx];
            if (type === PDFNull_1.default) {
              if (result === PDFNull_1.default)
                return result;
            } else {
              if (result instanceof type)
                return result;
            }
          }
          throw new errors_1.UnexpectedObjectTypeError(types, result);
        };
        PDFContext2.prototype.getObjectRef = function(pdfObject) {
          var entries = Array.from(this.indirectObjects.entries());
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], ref = _a[0], object = _a[1];
            if (object === pdfObject) {
              return ref;
            }
          }
          return void 0;
        };
        PDFContext2.prototype.enumerateIndirectObjects = function() {
          return Array.from(this.indirectObjects.entries()).sort(byAscendingObjectNumber);
        };
        PDFContext2.prototype.obj = function(literal) {
          if (literal instanceof PDFObject_1.default) {
            return literal;
          } else if (literal === null || literal === void 0) {
            return PDFNull_1.default;
          } else if (typeof literal === "string") {
            return PDFName_1.default.of(literal);
          } else if (typeof literal === "number") {
            return PDFNumber_1.default.of(literal);
          } else if (typeof literal === "boolean") {
            return literal ? PDFBool_1.default.True : PDFBool_1.default.False;
          } else if (Array.isArray(literal)) {
            var array = PDFArray_1.default.withContext(this);
            for (var idx = 0, len = literal.length; idx < len; idx++) {
              array.push(this.obj(literal[idx]));
            }
            return array;
          } else {
            var dict = PDFDict_1.default.withContext(this);
            var keys = Object.keys(literal);
            for (var idx = 0, len = keys.length; idx < len; idx++) {
              var key = keys[idx];
              var value = literal[key];
              if (value !== void 0)
                dict.set(PDFName_1.default.of(key), this.obj(value));
            }
            return dict;
          }
        };
        PDFContext2.prototype.stream = function(contents, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return PDFRawStream_1.default.of(this.obj(dict), utils_1.typedArrayFor(contents));
        };
        PDFContext2.prototype.flateStream = function(contents, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return this.stream(pako_1.default.deflate(utils_1.typedArrayFor(contents)), tslib_1.__assign(tslib_1.__assign({}, dict), { Filter: "FlateDecode" }));
        };
        PDFContext2.prototype.contentStream = function(operators, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return PDFContentStream_1.default.of(this.obj(dict), operators);
        };
        PDFContext2.prototype.formXObject = function(operators, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return this.contentStream(operators, tslib_1.__assign(tslib_1.__assign({ BBox: this.obj([0, 0, 0, 0]), Matrix: this.obj([1, 0, 0, 1, 0, 0]) }, dict), { Type: "XObject", Subtype: "Form" }));
        };
        PDFContext2.prototype.getPushGraphicsStateContentStream = function() {
          if (this.pushGraphicsStateContentStreamRef) {
            return this.pushGraphicsStateContentStreamRef;
          }
          var dict = this.obj({});
          var op = PDFOperator_1.default.of(PDFOperatorNames_1.default.PushGraphicsState);
          var stream = PDFContentStream_1.default.of(dict, [op]);
          this.pushGraphicsStateContentStreamRef = this.register(stream);
          return this.pushGraphicsStateContentStreamRef;
        };
        PDFContext2.prototype.getPopGraphicsStateContentStream = function() {
          if (this.popGraphicsStateContentStreamRef) {
            return this.popGraphicsStateContentStreamRef;
          }
          var dict = this.obj({});
          var op = PDFOperator_1.default.of(PDFOperatorNames_1.default.PopGraphicsState);
          var stream = PDFContentStream_1.default.of(dict, [op]);
          this.popGraphicsStateContentStreamRef = this.register(stream);
          return this.popGraphicsStateContentStreamRef;
        };
        PDFContext2.prototype.addRandomSuffix = function(prefix, suffixLength) {
          if (suffixLength === void 0) {
            suffixLength = 4;
          }
          return prefix + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, suffixLength));
        };
        PDFContext2.create = function() {
          return new PDFContext2();
        };
        return PDFContext2;
      }()
    );
    exports.default = PDFContext;
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFPageLeaf.js
var require_PDFPageLeaf = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFPageLeaf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFPageLeaf = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFPageLeaf2, _super);
        function PDFPageLeaf2(map, context, autoNormalizeCTM) {
          if (autoNormalizeCTM === void 0) {
            autoNormalizeCTM = true;
          }
          var _this = _super.call(this, map, context) || this;
          _this.normalized = false;
          _this.autoNormalizeCTM = autoNormalizeCTM;
          return _this;
        }
        PDFPageLeaf2.prototype.clone = function(context) {
          var clone = PDFPageLeaf2.fromMapWithContext(/* @__PURE__ */ new Map(), context || this.context, this.autoNormalizeCTM);
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            clone.set(key, value);
          }
          return clone;
        };
        PDFPageLeaf2.prototype.Parent = function() {
          return this.lookupMaybe(PDFName_1.default.Parent, PDFDict_1.default);
        };
        PDFPageLeaf2.prototype.Contents = function() {
          return this.lookup(PDFName_1.default.of("Contents"));
        };
        PDFPageLeaf2.prototype.Annots = function() {
          return this.lookupMaybe(PDFName_1.default.Annots, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.BleedBox = function() {
          return this.lookupMaybe(PDFName_1.default.BleedBox, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.TrimBox = function() {
          return this.lookupMaybe(PDFName_1.default.TrimBox, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.ArtBox = function() {
          return this.lookupMaybe(PDFName_1.default.ArtBox, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.Resources = function() {
          var dictOrRef = this.getInheritableAttribute(PDFName_1.default.Resources);
          return this.context.lookupMaybe(dictOrRef, PDFDict_1.default);
        };
        PDFPageLeaf2.prototype.MediaBox = function() {
          var arrayOrRef = this.getInheritableAttribute(PDFName_1.default.MediaBox);
          return this.context.lookup(arrayOrRef, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.CropBox = function() {
          var arrayOrRef = this.getInheritableAttribute(PDFName_1.default.CropBox);
          return this.context.lookupMaybe(arrayOrRef, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.Rotate = function() {
          var numberOrRef = this.getInheritableAttribute(PDFName_1.default.Rotate);
          return this.context.lookupMaybe(numberOrRef, PDFNumber_1.default);
        };
        PDFPageLeaf2.prototype.getInheritableAttribute = function(name) {
          var attribute;
          this.ascend(function(node) {
            if (!attribute)
              attribute = node.get(name);
          });
          return attribute;
        };
        PDFPageLeaf2.prototype.setParent = function(parentRef) {
          this.set(PDFName_1.default.Parent, parentRef);
        };
        PDFPageLeaf2.prototype.addContentStream = function(contentStreamRef) {
          var Contents = this.normalizedEntries().Contents || this.context.obj([]);
          this.set(PDFName_1.default.Contents, Contents);
          Contents.push(contentStreamRef);
        };
        PDFPageLeaf2.prototype.wrapContentStreams = function(startStream, endStream) {
          var Contents = this.Contents();
          if (Contents instanceof PDFArray_1.default) {
            Contents.insert(0, startStream);
            Contents.push(endStream);
            return true;
          }
          return false;
        };
        PDFPageLeaf2.prototype.addAnnot = function(annotRef) {
          var Annots = this.normalizedEntries().Annots;
          Annots.push(annotRef);
        };
        PDFPageLeaf2.prototype.removeAnnot = function(annotRef) {
          var Annots = this.normalizedEntries().Annots;
          var index = Annots.indexOf(annotRef);
          if (index !== void 0) {
            Annots.remove(index);
          }
        };
        PDFPageLeaf2.prototype.setFontDictionary = function(name, fontDictRef) {
          var Font = this.normalizedEntries().Font;
          Font.set(name, fontDictRef);
        };
        PDFPageLeaf2.prototype.newFontDictionaryKey = function(tag) {
          var Font = this.normalizedEntries().Font;
          return Font.uniqueKey(tag);
        };
        PDFPageLeaf2.prototype.newFontDictionary = function(tag, fontDictRef) {
          var key = this.newFontDictionaryKey(tag);
          this.setFontDictionary(key, fontDictRef);
          return key;
        };
        PDFPageLeaf2.prototype.setXObject = function(name, xObjectRef) {
          var XObject = this.normalizedEntries().XObject;
          XObject.set(name, xObjectRef);
        };
        PDFPageLeaf2.prototype.newXObjectKey = function(tag) {
          var XObject = this.normalizedEntries().XObject;
          return XObject.uniqueKey(tag);
        };
        PDFPageLeaf2.prototype.newXObject = function(tag, xObjectRef) {
          var key = this.newXObjectKey(tag);
          this.setXObject(key, xObjectRef);
          return key;
        };
        PDFPageLeaf2.prototype.setExtGState = function(name, extGStateRef) {
          var ExtGState = this.normalizedEntries().ExtGState;
          ExtGState.set(name, extGStateRef);
        };
        PDFPageLeaf2.prototype.newExtGStateKey = function(tag) {
          var ExtGState = this.normalizedEntries().ExtGState;
          return ExtGState.uniqueKey(tag);
        };
        PDFPageLeaf2.prototype.newExtGState = function(tag, extGStateRef) {
          var key = this.newExtGStateKey(tag);
          this.setExtGState(key, extGStateRef);
          return key;
        };
        PDFPageLeaf2.prototype.ascend = function(visitor) {
          visitor(this);
          var Parent = this.Parent();
          if (Parent)
            Parent.ascend(visitor);
        };
        PDFPageLeaf2.prototype.normalize = function() {
          if (this.normalized)
            return;
          var context = this.context;
          var contentsRef = this.get(PDFName_1.default.Contents);
          var contents = this.context.lookup(contentsRef);
          if (contents instanceof PDFStream_1.default) {
            this.set(PDFName_1.default.Contents, context.obj([contentsRef]));
          }
          if (this.autoNormalizeCTM) {
            this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream());
          }
          var dictOrRef = this.getInheritableAttribute(PDFName_1.default.Resources);
          var Resources = context.lookupMaybe(dictOrRef, PDFDict_1.default) || context.obj({});
          this.set(PDFName_1.default.Resources, Resources);
          var Font = Resources.lookupMaybe(PDFName_1.default.Font, PDFDict_1.default) || context.obj({});
          Resources.set(PDFName_1.default.Font, Font);
          var XObject = Resources.lookupMaybe(PDFName_1.default.XObject, PDFDict_1.default) || context.obj({});
          Resources.set(PDFName_1.default.XObject, XObject);
          var ExtGState = Resources.lookupMaybe(PDFName_1.default.ExtGState, PDFDict_1.default) || context.obj({});
          Resources.set(PDFName_1.default.ExtGState, ExtGState);
          var Annots = this.Annots() || context.obj([]);
          this.set(PDFName_1.default.Annots, Annots);
          this.normalized = true;
        };
        PDFPageLeaf2.prototype.normalizedEntries = function() {
          this.normalize();
          var Annots = this.Annots();
          var Resources = this.Resources();
          var Contents = this.Contents();
          return {
            Annots,
            Resources,
            Contents,
            Font: Resources.lookup(PDFName_1.default.Font, PDFDict_1.default),
            XObject: Resources.lookup(PDFName_1.default.XObject, PDFDict_1.default),
            ExtGState: Resources.lookup(PDFName_1.default.ExtGState, PDFDict_1.default)
          };
        };
        PDFPageLeaf2.InheritableEntries = [
          "Resources",
          "MediaBox",
          "CropBox",
          "Rotate"
        ];
        PDFPageLeaf2.withContextAndParent = function(context, parent) {
          var dict = /* @__PURE__ */ new Map();
          dict.set(PDFName_1.default.Type, PDFName_1.default.Page);
          dict.set(PDFName_1.default.Parent, parent);
          dict.set(PDFName_1.default.Resources, context.obj({}));
          dict.set(PDFName_1.default.MediaBox, context.obj([0, 0, 612, 792]));
          return new PDFPageLeaf2(dict, context, false);
        };
        PDFPageLeaf2.fromMapWithContext = function(map, context, autoNormalizeCTM) {
          if (autoNormalizeCTM === void 0) {
            autoNormalizeCTM = true;
          }
          return new PDFPageLeaf2(map, context, autoNormalizeCTM);
        };
        return PDFPageLeaf2;
      }(PDFDict_1.default)
    );
    exports.default = PDFPageLeaf;
  }
});

// node_modules/pdf-lib/cjs/core/PDFObjectCopier.js
var require_PDFObjectCopier = __commonJS({
  "node_modules/pdf-lib/cjs/core/PDFObjectCopier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFPageLeaf_1 = tslib_1.__importDefault(require_PDFPageLeaf());
    var PDFObjectCopier = (
      /** @class */
      function() {
        function PDFObjectCopier2(src, dest) {
          var _this = this;
          this.traversedObjects = /* @__PURE__ */ new Map();
          this.copy = function(object) {
            return object instanceof PDFPageLeaf_1.default ? _this.copyPDFPage(object) : object instanceof PDFDict_1.default ? _this.copyPDFDict(object) : object instanceof PDFArray_1.default ? _this.copyPDFArray(object) : object instanceof PDFStream_1.default ? _this.copyPDFStream(object) : object instanceof PDFRef_1.default ? _this.copyPDFIndirectObject(object) : object.clone();
          };
          this.copyPDFPage = function(originalPage) {
            var clonedPage = originalPage.clone();
            var InheritableEntries = PDFPageLeaf_1.default.InheritableEntries;
            for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {
              var key = PDFName_1.default.of(InheritableEntries[idx]);
              var value = clonedPage.getInheritableAttribute(key);
              if (!clonedPage.get(key) && value)
                clonedPage.set(key, value);
            }
            clonedPage.delete(PDFName_1.default.of("Parent"));
            return _this.copyPDFDict(clonedPage);
          };
          this.copyPDFDict = function(originalDict) {
            if (_this.traversedObjects.has(originalDict)) {
              return _this.traversedObjects.get(originalDict);
            }
            var clonedDict = originalDict.clone(_this.dest);
            _this.traversedObjects.set(originalDict, clonedDict);
            var entries = originalDict.entries();
            for (var idx = 0, len = entries.length; idx < len; idx++) {
              var _a = entries[idx], key = _a[0], value = _a[1];
              clonedDict.set(key, _this.copy(value));
            }
            return clonedDict;
          };
          this.copyPDFArray = function(originalArray) {
            if (_this.traversedObjects.has(originalArray)) {
              return _this.traversedObjects.get(originalArray);
            }
            var clonedArray = originalArray.clone(_this.dest);
            _this.traversedObjects.set(originalArray, clonedArray);
            for (var idx = 0, len = originalArray.size(); idx < len; idx++) {
              var value = originalArray.get(idx);
              clonedArray.set(idx, _this.copy(value));
            }
            return clonedArray;
          };
          this.copyPDFStream = function(originalStream) {
            if (_this.traversedObjects.has(originalStream)) {
              return _this.traversedObjects.get(originalStream);
            }
            var clonedStream = originalStream.clone(_this.dest);
            _this.traversedObjects.set(originalStream, clonedStream);
            var entries = originalStream.dict.entries();
            for (var idx = 0, len = entries.length; idx < len; idx++) {
              var _a = entries[idx], key = _a[0], value = _a[1];
              clonedStream.dict.set(key, _this.copy(value));
            }
            return clonedStream;
          };
          this.copyPDFIndirectObject = function(ref) {
            var alreadyMapped = _this.traversedObjects.has(ref);
            if (!alreadyMapped) {
              var newRef = _this.dest.nextRef();
              _this.traversedObjects.set(ref, newRef);
              var dereferencedValue = _this.src.lookup(ref);
              if (dereferencedValue) {
                var cloned = _this.copy(dereferencedValue);
                _this.dest.assign(newRef, cloned);
              }
            }
            return _this.traversedObjects.get(ref);
          };
          this.src = src;
          this.dest = dest;
        }
        PDFObjectCopier2.for = function(src, dest) {
          return new PDFObjectCopier2(src, dest);
        };
        return PDFObjectCopier2;
      }()
    );
    exports.default = PDFObjectCopier;
  }
});

// node_modules/pdf-lib/cjs/core/document/PDFCrossRefSection.js
var require_PDFCrossRefSection = __commonJS({
  "node_modules/pdf-lib/cjs/core/document/PDFCrossRefSection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFCrossRefSection = (
      /** @class */
      function() {
        function PDFCrossRefSection2(firstEntry) {
          this.subsections = firstEntry ? [[firstEntry]] : [];
          this.chunkIdx = 0;
          this.chunkLength = firstEntry ? 1 : 0;
        }
        PDFCrossRefSection2.prototype.addEntry = function(ref, offset2) {
          this.append({ ref, offset: offset2, deleted: false });
        };
        PDFCrossRefSection2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
          this.append({ ref, offset: nextFreeObjectNumber, deleted: true });
        };
        PDFCrossRefSection2.prototype.toString = function() {
          var section = "xref\n";
          for (var rangeIdx = 0, rangeLen = this.subsections.length; rangeIdx < rangeLen; rangeIdx++) {
            var range = this.subsections[rangeIdx];
            section += range[0].ref.objectNumber + " " + range.length + "\n";
            for (var entryIdx = 0, entryLen = range.length; entryIdx < entryLen; entryIdx++) {
              var entry = range[entryIdx];
              section += utils_1.padStart(String(entry.offset), 10, "0");
              section += " ";
              section += utils_1.padStart(String(entry.ref.generationNumber), 5, "0");
              section += " ";
              section += entry.deleted ? "f" : "n";
              section += " \n";
            }
          }
          return section;
        };
        PDFCrossRefSection2.prototype.sizeInBytes = function() {
          var size = 5;
          for (var idx = 0, len = this.subsections.length; idx < len; idx++) {
            var subsection = this.subsections[idx];
            var subsectionLength = subsection.length;
            var firstEntry = subsection[0];
            size += 2;
            size += String(firstEntry.ref.objectNumber).length;
            size += String(subsectionLength).length;
            size += 20 * subsectionLength;
          }
          return size;
        };
        PDFCrossRefSection2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.x;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.f;
          buffer[offset2++] = CharCodes_1.default.Newline;
          offset2 += this.copySubsectionsIntoBuffer(this.subsections, buffer, offset2);
          return offset2 - initialOffset;
        };
        PDFCrossRefSection2.prototype.copySubsectionsIntoBuffer = function(subsections, buffer, offset2) {
          var initialOffset = offset2;
          var length = subsections.length;
          for (var idx = 0; idx < length; idx++) {
            var subsection = this.subsections[idx];
            var firstObjectNumber = String(subsection[0].ref.objectNumber);
            offset2 += utils_1.copyStringIntoBuffer(firstObjectNumber, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            var rangeLength = String(subsection.length);
            offset2 += utils_1.copyStringIntoBuffer(rangeLength, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
            offset2 += this.copyEntriesIntoBuffer(subsection, buffer, offset2);
          }
          return offset2 - initialOffset;
        };
        PDFCrossRefSection2.prototype.copyEntriesIntoBuffer = function(entries, buffer, offset2) {
          var length = entries.length;
          for (var idx = 0; idx < length; idx++) {
            var entry = entries[idx];
            var entryOffset = utils_1.padStart(String(entry.offset), 10, "0");
            offset2 += utils_1.copyStringIntoBuffer(entryOffset, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            var entryGen = utils_1.padStart(String(entry.ref.generationNumber), 5, "0");
            offset2 += utils_1.copyStringIntoBuffer(entryGen, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            buffer[offset2++] = entry.deleted ? CharCodes_1.default.f : CharCodes_1.default.n;
            buffer[offset2++] = CharCodes_1.default.Space;
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          return 20 * length;
        };
        PDFCrossRefSection2.prototype.append = function(currEntry) {
          if (this.chunkLength === 0) {
            this.subsections.push([currEntry]);
            this.chunkIdx = 0;
            this.chunkLength = 1;
            return;
          }
          var chunk = this.subsections[this.chunkIdx];
          var prevEntry = chunk[this.chunkLength - 1];
          if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
            this.subsections.push([currEntry]);
            this.chunkIdx += 1;
            this.chunkLength = 1;
          } else {
            chunk.push(currEntry);
            this.chunkLength += 1;
          }
        };
        PDFCrossRefSection2.create = function() {
          return new PDFCrossRefSection2({
            ref: PDFRef_1.default.of(0, 65535),
            offset: 0,
            deleted: true
          });
        };
        PDFCrossRefSection2.createEmpty = function() {
          return new PDFCrossRefSection2();
        };
        return PDFCrossRefSection2;
      }()
    );
    exports.default = PDFCrossRefSection;
  }
});

// node_modules/pdf-lib/cjs/core/document/PDFTrailer.js
var require_PDFTrailer = __commonJS({
  "node_modules/pdf-lib/cjs/core/document/PDFTrailer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFTrailer = (
      /** @class */
      function() {
        function PDFTrailer2(lastXRefOffset) {
          this.lastXRefOffset = String(lastXRefOffset);
        }
        PDFTrailer2.prototype.toString = function() {
          return "startxref\n" + this.lastXRefOffset + "\n%%EOF";
        };
        PDFTrailer2.prototype.sizeInBytes = function() {
          return 16 + this.lastXRefOffset.length;
        };
        PDFTrailer2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.s;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.x;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.f;
          buffer[offset2++] = CharCodes_1.default.Newline;
          offset2 += utils_1.copyStringIntoBuffer(this.lastXRefOffset, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = CharCodes_1.default.E;
          buffer[offset2++] = CharCodes_1.default.O;
          buffer[offset2++] = CharCodes_1.default.F;
          return offset2 - initialOffset;
        };
        PDFTrailer2.forLastCrossRefSectionOffset = function(offset2) {
          return new PDFTrailer2(offset2);
        };
        return PDFTrailer2;
      }()
    );
    exports.default = PDFTrailer;
  }
});

// node_modules/pdf-lib/cjs/core/document/PDFTrailerDict.js
var require_PDFTrailerDict = __commonJS({
  "node_modules/pdf-lib/cjs/core/document/PDFTrailerDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFTrailerDict = (
      /** @class */
      function() {
        function PDFTrailerDict2(dict) {
          this.dict = dict;
        }
        PDFTrailerDict2.prototype.toString = function() {
          return "trailer\n" + this.dict.toString();
        };
        PDFTrailerDict2.prototype.sizeInBytes = function() {
          return 8 + this.dict.sizeInBytes();
        };
        PDFTrailerDict2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.i;
          buffer[offset2++] = CharCodes_1.default.l;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.Newline;
          offset2 += this.dict.copyBytesInto(buffer, offset2);
          return offset2 - initialOffset;
        };
        PDFTrailerDict2.of = function(dict) {
          return new PDFTrailerDict2(dict);
        };
        return PDFTrailerDict2;
      }()
    );
    exports.default = PDFTrailerDict;
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFObjectStream.js
var require_PDFObjectStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFObjectStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFFlateStream_1 = tslib_1.__importDefault(require_PDFFlateStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFObjectStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectStream2, _super);
        function PDFObjectStream2(context, objects, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var _this = _super.call(this, context.obj({}), encode) || this;
          _this.objects = objects;
          _this.offsets = _this.computeObjectOffsets();
          _this.offsetsString = _this.computeOffsetsString();
          _this.dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("ObjStm"));
          _this.dict.set(PDFName_1.default.of("N"), PDFNumber_1.default.of(_this.objects.length));
          _this.dict.set(PDFName_1.default.of("First"), PDFNumber_1.default.of(_this.offsetsString.length));
          return _this;
        }
        PDFObjectStream2.prototype.getObjectsCount = function() {
          return this.objects.length;
        };
        PDFObjectStream2.prototype.clone = function(context) {
          return PDFObjectStream2.withContextAndObjects(context || this.dict.context, this.objects.slice(), this.encode);
        };
        PDFObjectStream2.prototype.getContentsString = function() {
          var value = this.offsetsString;
          for (var idx = 0, len = this.objects.length; idx < len; idx++) {
            var _a = this.objects[idx], object = _a[1];
            value += object + "\n";
          }
          return value;
        };
        PDFObjectStream2.prototype.getUnencodedContents = function() {
          var buffer = new Uint8Array(this.getUnencodedContentsSize());
          var offset2 = utils_1.copyStringIntoBuffer(this.offsetsString, buffer, 0);
          for (var idx = 0, len = this.objects.length; idx < len; idx++) {
            var _a = this.objects[idx], object = _a[1];
            offset2 += object.copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          return buffer;
        };
        PDFObjectStream2.prototype.getUnencodedContentsSize = function() {
          return this.offsetsString.length + utils_1.last(this.offsets)[1] + utils_1.last(this.objects)[1].sizeInBytes() + 1;
        };
        PDFObjectStream2.prototype.computeOffsetsString = function() {
          var offsetsString = "";
          for (var idx = 0, len = this.offsets.length; idx < len; idx++) {
            var _a = this.offsets[idx], objectNumber = _a[0], offset2 = _a[1];
            offsetsString += objectNumber + " " + offset2 + " ";
          }
          return offsetsString;
        };
        PDFObjectStream2.prototype.computeObjectOffsets = function() {
          var offset2 = 0;
          var offsets = new Array(this.objects.length);
          for (var idx = 0, len = this.objects.length; idx < len; idx++) {
            var _a = this.objects[idx], ref = _a[0], object = _a[1];
            offsets[idx] = [ref.objectNumber, offset2];
            offset2 += object.sizeInBytes() + 1;
          }
          return offsets;
        };
        PDFObjectStream2.withContextAndObjects = function(context, objects, encode) {
          if (encode === void 0) {
            encode = true;
          }
          return new PDFObjectStream2(context, objects, encode);
        };
        return PDFObjectStream2;
      }(PDFFlateStream_1.default)
    );
    exports.default = PDFObjectStream;
  }
});

// node_modules/pdf-lib/cjs/core/writers/PDFWriter.js
var require_PDFWriter = __commonJS({
  "node_modules/pdf-lib/cjs/core/writers/PDFWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFCrossRefSection_1 = tslib_1.__importDefault(require_PDFCrossRefSection());
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var PDFTrailer_1 = tslib_1.__importDefault(require_PDFTrailer());
    var PDFTrailerDict_1 = tslib_1.__importDefault(require_PDFTrailerDict());
    var PDFObjectStream_1 = tslib_1.__importDefault(require_PDFObjectStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFWriter = (
      /** @class */
      function() {
        function PDFWriter2(context, objectsPerTick) {
          var _this = this;
          this.parsedObjects = 0;
          this.shouldWaitForTick = function(n) {
            _this.parsedObjects += n;
            return _this.parsedObjects % _this.objectsPerTick === 0;
          };
          this.context = context;
          this.objectsPerTick = objectsPerTick;
        }
        PDFWriter2.prototype.serializeToBuffer = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset2, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;
            return tslib_1.__generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.computeBufferSize()];
                case 1:
                  _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;
                  offset2 = 0;
                  buffer = new Uint8Array(size);
                  offset2 += header.copyBytesInto(buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  idx = 0, len = indirectObjects.length;
                  _c.label = 2;
                case 2:
                  if (!(idx < len))
                    return [3, 5];
                  _b = indirectObjects[idx], ref = _b[0], object = _b[1];
                  objectNumber = String(ref.objectNumber);
                  offset2 += utils_1.copyStringIntoBuffer(objectNumber, buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Space;
                  generationNumber = String(ref.generationNumber);
                  offset2 += utils_1.copyStringIntoBuffer(generationNumber, buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Space;
                  buffer[offset2++] = CharCodes_1.default.o;
                  buffer[offset2++] = CharCodes_1.default.b;
                  buffer[offset2++] = CharCodes_1.default.j;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  offset2 += object.copyBytesInto(buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  buffer[offset2++] = CharCodes_1.default.e;
                  buffer[offset2++] = CharCodes_1.default.n;
                  buffer[offset2++] = CharCodes_1.default.d;
                  buffer[offset2++] = CharCodes_1.default.o;
                  buffer[offset2++] = CharCodes_1.default.b;
                  buffer[offset2++] = CharCodes_1.default.j;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  n = object instanceof PDFObjectStream_1.default ? object.getObjectsCount() : 1;
                  if (!this.shouldWaitForTick(n))
                    return [3, 4];
                  return [4, utils_1.waitForTick()];
                case 3:
                  _c.sent();
                  _c.label = 4;
                case 4:
                  idx++;
                  return [3, 2];
                case 5:
                  if (xref) {
                    offset2 += xref.copyBytesInto(buffer, offset2);
                    buffer[offset2++] = CharCodes_1.default.Newline;
                  }
                  if (trailerDict) {
                    offset2 += trailerDict.copyBytesInto(buffer, offset2);
                    buffer[offset2++] = CharCodes_1.default.Newline;
                    buffer[offset2++] = CharCodes_1.default.Newline;
                  }
                  offset2 += trailer.copyBytesInto(buffer, offset2);
                  return [2, buffer];
              }
            });
          });
        };
        PDFWriter2.prototype.computeIndirectObjectSize = function(_a) {
          var ref = _a[0], object = _a[1];
          var refSize = ref.sizeInBytes() + 3;
          var objectSize = object.sizeInBytes() + 9;
          return refSize + objectSize;
        };
        PDFWriter2.prototype.createTrailerDict = function() {
          return this.context.obj({
            Size: this.context.largestObjectNumber + 1,
            Root: this.context.trailerInfo.Root,
            Encrypt: this.context.trailerInfo.Encrypt,
            Info: this.context.trailerInfo.Info,
            ID: this.context.trailerInfo.ID
          });
        };
        PDFWriter2.prototype.computeBufferSize = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  header = PDFHeader_1.default.forVersion(1, 7);
                  size = header.sizeInBytes() + 2;
                  xref = PDFCrossRefSection_1.default.create();
                  indirectObjects = this.context.enumerateIndirectObjects();
                  idx = 0, len = indirectObjects.length;
                  _a.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  indirectObject = indirectObjects[idx];
                  ref = indirectObject[0];
                  xref.addEntry(ref, size);
                  size += this.computeIndirectObjectSize(indirectObject);
                  if (!this.shouldWaitForTick(1))
                    return [3, 3];
                  return [4, utils_1.waitForTick()];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  xrefOffset = size;
                  size += xref.sizeInBytes() + 1;
                  trailerDict = PDFTrailerDict_1.default.of(this.createTrailerDict());
                  size += trailerDict.sizeInBytes() + 2;
                  trailer = PDFTrailer_1.default.forLastCrossRefSectionOffset(xrefOffset);
                  size += trailer.sizeInBytes();
                  return [2, { size, header, indirectObjects, xref, trailerDict, trailer }];
              }
            });
          });
        };
        PDFWriter2.forContext = function(context, objectsPerTick) {
          return new PDFWriter2(context, objectsPerTick);
        };
        return PDFWriter2;
      }()
    );
    exports.default = PDFWriter;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFInvalidObject.js
var require_PDFInvalidObject = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFInvalidObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var PDFInvalidObject = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFInvalidObject2, _super);
        function PDFInvalidObject2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        PDFInvalidObject2.prototype.clone = function() {
          return PDFInvalidObject2.of(this.data.slice());
        };
        PDFInvalidObject2.prototype.toString = function() {
          return "PDFInvalidObject(" + this.data.length + " bytes)";
        };
        PDFInvalidObject2.prototype.sizeInBytes = function() {
          return this.data.length;
        };
        PDFInvalidObject2.prototype.copyBytesInto = function(buffer, offset2) {
          var length = this.data.length;
          for (var idx = 0; idx < length; idx++) {
            buffer[offset2++] = this.data[idx];
          }
          return length;
        };
        PDFInvalidObject2.of = function(data) {
          return new PDFInvalidObject2(data);
        };
        return PDFInvalidObject2;
      }(PDFObject_1.default)
    );
    exports.default = PDFInvalidObject;
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFCrossRefStream.js
var require_PDFCrossRefStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFCrossRefStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFFlateStream_1 = tslib_1.__importDefault(require_PDFFlateStream());
    var utils_1 = require_utils2();
    var EntryType;
    (function(EntryType2) {
      EntryType2[EntryType2["Deleted"] = 0] = "Deleted";
      EntryType2[EntryType2["Uncompressed"] = 1] = "Uncompressed";
      EntryType2[EntryType2["Compressed"] = 2] = "Compressed";
    })(EntryType = exports.EntryType || (exports.EntryType = {}));
    var PDFCrossRefStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFCrossRefStream2, _super);
        function PDFCrossRefStream2(dict, entries, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var _this = _super.call(this, dict, encode) || this;
          _this.computeIndex = function() {
            var subsections = [];
            var subsectionLength = 0;
            for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
              var currEntry = _this.entries[idx];
              var prevEntry = _this.entries[idx - 1];
              if (idx === 0) {
                subsections.push(currEntry.ref.objectNumber);
              } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
                subsections.push(subsectionLength);
                subsections.push(currEntry.ref.objectNumber);
                subsectionLength = 0;
              }
              subsectionLength += 1;
            }
            subsections.push(subsectionLength);
            return subsections;
          };
          _this.computeEntryTuples = function() {
            var entryTuples = new Array(_this.entries.length);
            for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
              var entry = _this.entries[idx];
              if (entry.type === EntryType.Deleted) {
                var type = entry.type, nextFreeObjectNumber = entry.nextFreeObjectNumber, ref = entry.ref;
                entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];
              }
              if (entry.type === EntryType.Uncompressed) {
                var type = entry.type, offset2 = entry.offset, ref = entry.ref;
                entryTuples[idx] = [type, offset2, ref.generationNumber];
              }
              if (entry.type === EntryType.Compressed) {
                var type = entry.type, objectStreamRef = entry.objectStreamRef, index = entry.index;
                entryTuples[idx] = [type, objectStreamRef.objectNumber, index];
              }
            }
            return entryTuples;
          };
          _this.computeMaxEntryByteWidths = function() {
            var entryTuples = _this.entryTuplesCache.access();
            var widths = [0, 0, 0];
            for (var idx = 0, len = entryTuples.length; idx < len; idx++) {
              var _a = entryTuples[idx], first = _a[0], second = _a[1], third = _a[2];
              var firstSize = utils_1.sizeInBytes(first);
              var secondSize = utils_1.sizeInBytes(second);
              var thirdSize = utils_1.sizeInBytes(third);
              if (firstSize > widths[0])
                widths[0] = firstSize;
              if (secondSize > widths[1])
                widths[1] = secondSize;
              if (thirdSize > widths[2])
                widths[2] = thirdSize;
            }
            return widths;
          };
          _this.entries = entries || [];
          _this.entryTuplesCache = utils_1.Cache.populatedBy(_this.computeEntryTuples);
          _this.maxByteWidthsCache = utils_1.Cache.populatedBy(_this.computeMaxEntryByteWidths);
          _this.indexCache = utils_1.Cache.populatedBy(_this.computeIndex);
          dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("XRef"));
          return _this;
        }
        PDFCrossRefStream2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
          var type = EntryType.Deleted;
          this.entries.push({ type, ref, nextFreeObjectNumber });
          this.entryTuplesCache.invalidate();
          this.maxByteWidthsCache.invalidate();
          this.indexCache.invalidate();
          this.contentsCache.invalidate();
        };
        PDFCrossRefStream2.prototype.addUncompressedEntry = function(ref, offset2) {
          var type = EntryType.Uncompressed;
          this.entries.push({ type, ref, offset: offset2 });
          this.entryTuplesCache.invalidate();
          this.maxByteWidthsCache.invalidate();
          this.indexCache.invalidate();
          this.contentsCache.invalidate();
        };
        PDFCrossRefStream2.prototype.addCompressedEntry = function(ref, objectStreamRef, index) {
          var type = EntryType.Compressed;
          this.entries.push({ type, ref, objectStreamRef, index });
          this.entryTuplesCache.invalidate();
          this.maxByteWidthsCache.invalidate();
          this.indexCache.invalidate();
          this.contentsCache.invalidate();
        };
        PDFCrossRefStream2.prototype.clone = function(context) {
          var _a = this, dict = _a.dict, entries = _a.entries, encode = _a.encode;
          return PDFCrossRefStream2.of(dict.clone(context), entries.slice(), encode);
        };
        PDFCrossRefStream2.prototype.getContentsString = function() {
          var entryTuples = this.entryTuplesCache.access();
          var byteWidths = this.maxByteWidthsCache.access();
          var value = "";
          for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
            var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
            var firstBytes = utils_1.reverseArray(utils_1.bytesFor(first));
            var secondBytes = utils_1.reverseArray(utils_1.bytesFor(second));
            var thirdBytes = utils_1.reverseArray(utils_1.bytesFor(third));
            for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
              value += (firstBytes[idx] || 0).toString(2);
            }
            for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
              value += (secondBytes[idx] || 0).toString(2);
            }
            for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
              value += (thirdBytes[idx] || 0).toString(2);
            }
          }
          return value;
        };
        PDFCrossRefStream2.prototype.getUnencodedContents = function() {
          var entryTuples = this.entryTuplesCache.access();
          var byteWidths = this.maxByteWidthsCache.access();
          var buffer = new Uint8Array(this.getUnencodedContentsSize());
          var offset2 = 0;
          for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
            var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
            var firstBytes = utils_1.reverseArray(utils_1.bytesFor(first));
            var secondBytes = utils_1.reverseArray(utils_1.bytesFor(second));
            var thirdBytes = utils_1.reverseArray(utils_1.bytesFor(third));
            for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
              buffer[offset2++] = firstBytes[idx] || 0;
            }
            for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
              buffer[offset2++] = secondBytes[idx] || 0;
            }
            for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
              buffer[offset2++] = thirdBytes[idx] || 0;
            }
          }
          return buffer;
        };
        PDFCrossRefStream2.prototype.getUnencodedContentsSize = function() {
          var byteWidths = this.maxByteWidthsCache.access();
          var entryWidth = utils_1.sum(byteWidths);
          return entryWidth * this.entries.length;
        };
        PDFCrossRefStream2.prototype.updateDict = function() {
          _super.prototype.updateDict.call(this);
          var byteWidths = this.maxByteWidthsCache.access();
          var index = this.indexCache.access();
          var context = this.dict.context;
          this.dict.set(PDFName_1.default.of("W"), context.obj(byteWidths));
          this.dict.set(PDFName_1.default.of("Index"), context.obj(index));
        };
        PDFCrossRefStream2.create = function(dict, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var stream = new PDFCrossRefStream2(dict, [], encode);
          stream.addDeletedEntry(PDFRef_1.default.of(0, 65535), 0);
          return stream;
        };
        PDFCrossRefStream2.of = function(dict, entries, encode) {
          if (encode === void 0) {
            encode = true;
          }
          return new PDFCrossRefStream2(dict, entries, encode);
        };
        return PDFCrossRefStream2;
      }(PDFFlateStream_1.default)
    );
    exports.default = PDFCrossRefStream;
  }
});

// node_modules/pdf-lib/cjs/core/writers/PDFStreamWriter.js
var require_PDFStreamWriter = __commonJS({
  "node_modules/pdf-lib/cjs/core/writers/PDFStreamWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var PDFTrailer_1 = tslib_1.__importDefault(require_PDFTrailer());
    var PDFInvalidObject_1 = tslib_1.__importDefault(require_PDFInvalidObject());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFCrossRefStream_1 = tslib_1.__importDefault(require_PDFCrossRefStream());
    var PDFObjectStream_1 = tslib_1.__importDefault(require_PDFObjectStream());
    var PDFWriter_1 = tslib_1.__importDefault(require_PDFWriter());
    var utils_1 = require_utils2();
    var PDFStreamWriter = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFStreamWriter2, _super);
        function PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream) {
          var _this = _super.call(this, context, objectsPerTick) || this;
          _this.encodeStreams = encodeStreams;
          _this.objectsPerStream = objectsPerStream;
          return _this;
        }
        PDFStreamWriter2.prototype.computeBufferSize = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  objectNumber = this.context.largestObjectNumber + 1;
                  header = PDFHeader_1.default.forVersion(1, 7);
                  size = header.sizeInBytes() + 2;
                  xrefStream = PDFCrossRefStream_1.default.create(this.createTrailerDict(), this.encodeStreams);
                  uncompressedObjects = [];
                  compressedObjects = [];
                  objectStreamRefs = [];
                  indirectObjects = this.context.enumerateIndirectObjects();
                  idx = 0, len = indirectObjects.length;
                  _a.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 6];
                  indirectObject = indirectObjects[idx];
                  ref = indirectObject[0], object = indirectObject[1];
                  shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object instanceof PDFStream_1.default || object instanceof PDFInvalidObject_1.default || ref.generationNumber !== 0;
                  if (!shouldNotCompress)
                    return [3, 4];
                  uncompressedObjects.push(indirectObject);
                  xrefStream.addUncompressedEntry(ref, size);
                  size += this.computeIndirectObjectSize(indirectObject);
                  if (!this.shouldWaitForTick(1))
                    return [3, 3];
                  return [4, utils_1.waitForTick()];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  return [3, 5];
                case 4:
                  chunk = utils_1.last(compressedObjects);
                  objectStreamRef = utils_1.last(objectStreamRefs);
                  if (!chunk || chunk.length % this.objectsPerStream === 0) {
                    chunk = [];
                    compressedObjects.push(chunk);
                    objectStreamRef = PDFRef_1.default.of(objectNumber++);
                    objectStreamRefs.push(objectStreamRef);
                  }
                  xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);
                  chunk.push(indirectObject);
                  _a.label = 5;
                case 5:
                  idx++;
                  return [3, 1];
                case 6:
                  idx = 0, len = compressedObjects.length;
                  _a.label = 7;
                case 7:
                  if (!(idx < len))
                    return [3, 10];
                  chunk = compressedObjects[idx];
                  ref = objectStreamRefs[idx];
                  objectStream = PDFObjectStream_1.default.withContextAndObjects(this.context, chunk, this.encodeStreams);
                  xrefStream.addUncompressedEntry(ref, size);
                  size += this.computeIndirectObjectSize([ref, objectStream]);
                  uncompressedObjects.push([ref, objectStream]);
                  if (!this.shouldWaitForTick(chunk.length))
                    return [3, 9];
                  return [4, utils_1.waitForTick()];
                case 8:
                  _a.sent();
                  _a.label = 9;
                case 9:
                  idx++;
                  return [3, 7];
                case 10:
                  xrefStreamRef = PDFRef_1.default.of(objectNumber++);
                  xrefStream.dict.set(PDFName_1.default.of("Size"), PDFNumber_1.default.of(objectNumber));
                  xrefStream.addUncompressedEntry(xrefStreamRef, size);
                  xrefOffset = size;
                  size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);
                  uncompressedObjects.push([xrefStreamRef, xrefStream]);
                  trailer = PDFTrailer_1.default.forLastCrossRefSectionOffset(xrefOffset);
                  size += trailer.sizeInBytes();
                  return [2, { size, header, indirectObjects: uncompressedObjects, trailer }];
              }
            });
          });
        };
        PDFStreamWriter2.forContext = function(context, objectsPerTick, encodeStreams, objectsPerStream) {
          if (encodeStreams === void 0) {
            encodeStreams = true;
          }
          if (objectsPerStream === void 0) {
            objectsPerStream = 50;
          }
          return new PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream);
        };
        return PDFStreamWriter2;
      }(PDFWriter_1.default)
    );
    exports.default = PDFStreamWriter;
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFHexString.js
var require_PDFHexString = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFHexString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var errors_1 = require_errors2();
    var PDFHexString = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFHexString2, _super);
        function PDFHexString2(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          return _this;
        }
        PDFHexString2.prototype.asBytes = function() {
          var hex = this.value + (this.value.length % 2 === 1 ? "0" : "");
          var hexLength = hex.length;
          var bytes = new Uint8Array(hex.length / 2);
          var hexOffset = 0;
          var bytesOffset = 0;
          while (hexOffset < hexLength) {
            var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);
            bytes[bytesOffset] = byte;
            hexOffset += 2;
            bytesOffset += 1;
          }
          return bytes;
        };
        PDFHexString2.prototype.decodeText = function() {
          var bytes = this.asBytes();
          if (utils_1.hasUtf16BOM(bytes))
            return utils_1.utf16Decode(bytes);
          return utils_1.pdfDocEncodingDecode(bytes);
        };
        PDFHexString2.prototype.decodeDate = function() {
          var text = this.decodeText();
          var date = utils_1.parseDate(text);
          if (!date)
            throw new errors_1.InvalidPDFDateStringError(text);
          return date;
        };
        PDFHexString2.prototype.asString = function() {
          return this.value;
        };
        PDFHexString2.prototype.clone = function() {
          return PDFHexString2.of(this.value);
        };
        PDFHexString2.prototype.toString = function() {
          return "<" + this.value + ">";
        };
        PDFHexString2.prototype.sizeInBytes = function() {
          return this.value.length + 2;
        };
        PDFHexString2.prototype.copyBytesInto = function(buffer, offset2) {
          buffer[offset2++] = CharCodes_1.default.LessThan;
          offset2 += utils_1.copyStringIntoBuffer(this.value, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.GreaterThan;
          return this.value.length + 2;
        };
        PDFHexString2.of = function(value) {
          return new PDFHexString2(value);
        };
        PDFHexString2.fromText = function(value) {
          var encoded = utils_1.utf16Encode(value);
          var hex = "";
          for (var idx = 0, len = encoded.length; idx < len; idx++) {
            hex += utils_1.toHexStringOfMinLength(encoded[idx], 4);
          }
          return new PDFHexString2(hex);
        };
        return PDFHexString2;
      }(PDFObject_1.default)
    );
    exports.default = PDFHexString;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/StandardFontEmbedder.js
var require_StandardFontEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/StandardFontEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var standard_fonts_1 = require_lib();
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var utils_1 = require_utils2();
    var StandardFontEmbedder = (
      /** @class */
      function() {
        function StandardFontEmbedder2(fontName, customName) {
          this.encoding = fontName === standard_fonts_1.FontNames.ZapfDingbats ? standard_fonts_1.Encodings.ZapfDingbats : fontName === standard_fonts_1.FontNames.Symbol ? standard_fonts_1.Encodings.Symbol : standard_fonts_1.Encodings.WinAnsi;
          this.font = standard_fonts_1.Font.load(fontName);
          this.fontName = this.font.FontName;
          this.customName = customName;
        }
        StandardFontEmbedder2.prototype.encodeText = function(text) {
          var glyphs = this.encodeTextAsGlyphs(text);
          var hexCodes = new Array(glyphs.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            hexCodes[idx] = utils_1.toHexString(glyphs[idx].code);
          }
          return PDFHexString_1.default.of(hexCodes.join(""));
        };
        StandardFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
          var glyphs = this.encodeTextAsGlyphs(text);
          var totalWidth = 0;
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var left2 = glyphs[idx].name;
            var right2 = (glyphs[idx + 1] || {}).name;
            var kernAmount = this.font.getXAxisKerningForPair(left2, right2) || 0;
            totalWidth += this.widthOfGlyph(left2) + kernAmount;
          }
          var scale = size / 1e3;
          return totalWidth * scale;
        };
        StandardFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.descender, descender = _a === void 0 ? true : _a;
          var _b = this.font, Ascender = _b.Ascender, Descender = _b.Descender, FontBBox = _b.FontBBox;
          var yTop = Ascender || FontBBox[3];
          var yBottom = Descender || FontBBox[1];
          var height = yTop - yBottom;
          if (!descender)
            height += Descender || 0;
          return height / 1e3 * size;
        };
        StandardFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
          var _a = this.font, Ascender = _a.Ascender, Descender = _a.Descender, FontBBox = _a.FontBBox;
          var yTop = Ascender || FontBBox[3];
          var yBottom = Descender || FontBBox[1];
          return 1e3 * height / (yTop - yBottom);
        };
        StandardFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
          var fontDict = context.obj({
            Type: "Font",
            Subtype: "Type1",
            BaseFont: this.customName || this.fontName,
            Encoding: this.encoding === standard_fonts_1.Encodings.WinAnsi ? "WinAnsiEncoding" : void 0
          });
          if (ref) {
            context.assign(ref, fontDict);
            return ref;
          } else {
            return context.register(fontDict);
          }
        };
        StandardFontEmbedder2.prototype.widthOfGlyph = function(glyphName) {
          return this.font.getWidthOfGlyph(glyphName) || 250;
        };
        StandardFontEmbedder2.prototype.encodeTextAsGlyphs = function(text) {
          var codePoints = Array.from(text);
          var glyphs = new Array(codePoints.length);
          for (var idx = 0, len = codePoints.length; idx < len; idx++) {
            var codePoint = utils_1.toCodePoint(codePoints[idx]);
            glyphs[idx] = this.encoding.encodeUnicodeCodePoint(codePoint);
          }
          return glyphs;
        };
        StandardFontEmbedder2.for = function(fontName, customName) {
          return new StandardFontEmbedder2(fontName, customName);
        };
        return StandardFontEmbedder2;
      }()
    );
    exports.default = StandardFontEmbedder;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/CMap.js
var require_CMap = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/CMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCmap = void 0;
    var utils_1 = require_utils2();
    var unicode_1 = require_unicode();
    exports.createCmap = function(glyphs, glyphId) {
      var bfChars = new Array(glyphs.length);
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        var glyph = glyphs[idx];
        var id = cmapHexFormat(cmapHexString(glyphId(glyph)));
        var unicode = cmapHexFormat.apply(void 0, glyph.codePoints.map(cmapCodePointFormat));
        bfChars[idx] = [id, unicode];
      }
      return fillCmapTemplate(bfChars);
    };
    var fillCmapTemplate = function(bfChars) {
      return "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" + bfChars.length + " beginbfchar\n" + bfChars.map(function(_a) {
        var glyphId = _a[0], codePoint = _a[1];
        return glyphId + " " + codePoint;
      }).join("\n") + "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    };
    var cmapHexFormat = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return "<" + values.join("") + ">";
    };
    var cmapHexString = function(value) {
      return utils_1.toHexStringOfMinLength(value, 4);
    };
    var cmapCodePointFormat = function(codePoint) {
      if (unicode_1.isWithinBMP(codePoint))
        return cmapHexString(codePoint);
      if (unicode_1.hasSurrogates(codePoint)) {
        var hs = unicode_1.highSurrogate(codePoint);
        var ls = unicode_1.lowSurrogate(codePoint);
        return "" + cmapHexString(hs) + cmapHexString(ls);
      }
      var hex = utils_1.toHexString(codePoint);
      var msg = "0x" + hex + " is not a valid UTF-8 or UTF-16 codepoint.";
      throw new Error(msg);
    };
  }
});

// node_modules/pdf-lib/cjs/core/embedders/FontFlags.js
var require_FontFlags = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/FontFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveFontFlags = void 0;
    var makeFontFlags = function(options) {
      var flags = 0;
      var flipBit = function(bit) {
        flags |= 1 << bit - 1;
      };
      if (options.fixedPitch)
        flipBit(1);
      if (options.serif)
        flipBit(2);
      if (options.symbolic)
        flipBit(3);
      if (options.script)
        flipBit(4);
      if (options.nonsymbolic)
        flipBit(6);
      if (options.italic)
        flipBit(7);
      if (options.allCap)
        flipBit(17);
      if (options.smallCap)
        flipBit(18);
      if (options.forceBold)
        flipBit(19);
      return flags;
    };
    exports.deriveFontFlags = function(font) {
      var familyClass = font["OS/2"] ? font["OS/2"].sFamilyClass : 0;
      var flags = makeFontFlags({
        fixedPitch: font.post.isFixedPitch,
        serif: 1 <= familyClass && familyClass <= 7,
        symbolic: true,
        script: familyClass === 10,
        italic: font.head.macStyle.italic
      });
      return flags;
    };
  }
});

// node_modules/pdf-lib/cjs/core/objects/PDFString.js
var require_PDFString = __commonJS({
  "node_modules/pdf-lib/cjs/core/objects/PDFString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var errors_1 = require_errors2();
    var PDFString = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFString2, _super);
        function PDFString2(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          return _this;
        }
        PDFString2.prototype.asBytes = function() {
          var bytes = [];
          var octal = "";
          var escaped = false;
          var pushByte = function(byte2) {
            if (byte2 !== void 0)
              bytes.push(byte2);
            escaped = false;
          };
          for (var idx = 0, len = this.value.length; idx < len; idx++) {
            var char = this.value[idx];
            var byte = utils_1.toCharCode(char);
            var nextChar = this.value[idx + 1];
            if (!escaped) {
              if (byte === CharCodes_1.default.BackSlash)
                escaped = true;
              else
                pushByte(byte);
            } else {
              if (byte === CharCodes_1.default.Newline)
                pushByte();
              else if (byte === CharCodes_1.default.CarriageReturn)
                pushByte();
              else if (byte === CharCodes_1.default.n)
                pushByte(CharCodes_1.default.Newline);
              else if (byte === CharCodes_1.default.r)
                pushByte(CharCodes_1.default.CarriageReturn);
              else if (byte === CharCodes_1.default.t)
                pushByte(CharCodes_1.default.Tab);
              else if (byte === CharCodes_1.default.b)
                pushByte(CharCodes_1.default.Backspace);
              else if (byte === CharCodes_1.default.f)
                pushByte(CharCodes_1.default.FormFeed);
              else if (byte === CharCodes_1.default.LeftParen)
                pushByte(CharCodes_1.default.LeftParen);
              else if (byte === CharCodes_1.default.RightParen)
                pushByte(CharCodes_1.default.RightParen);
              else if (byte === CharCodes_1.default.Backspace)
                pushByte(CharCodes_1.default.BackSlash);
              else if (byte >= CharCodes_1.default.Zero && byte <= CharCodes_1.default.Seven) {
                octal += char;
                if (octal.length === 3 || !(nextChar >= "0" && nextChar <= "7")) {
                  pushByte(parseInt(octal, 8));
                  octal = "";
                }
              } else {
                pushByte(byte);
              }
            }
          }
          return new Uint8Array(bytes);
        };
        PDFString2.prototype.decodeText = function() {
          var bytes = this.asBytes();
          if (utils_1.hasUtf16BOM(bytes))
            return utils_1.utf16Decode(bytes);
          return utils_1.pdfDocEncodingDecode(bytes);
        };
        PDFString2.prototype.decodeDate = function() {
          var text = this.decodeText();
          var date = utils_1.parseDate(text);
          if (!date)
            throw new errors_1.InvalidPDFDateStringError(text);
          return date;
        };
        PDFString2.prototype.asString = function() {
          return this.value;
        };
        PDFString2.prototype.clone = function() {
          return PDFString2.of(this.value);
        };
        PDFString2.prototype.toString = function() {
          return "(" + this.value + ")";
        };
        PDFString2.prototype.sizeInBytes = function() {
          return this.value.length + 2;
        };
        PDFString2.prototype.copyBytesInto = function(buffer, offset2) {
          buffer[offset2++] = CharCodes_1.default.LeftParen;
          offset2 += utils_1.copyStringIntoBuffer(this.value, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.RightParen;
          return this.value.length + 2;
        };
        PDFString2.of = function(value) {
          return new PDFString2(value);
        };
        PDFString2.fromDate = function(date) {
          var year = utils_1.padStart(String(date.getUTCFullYear()), 4, "0");
          var month = utils_1.padStart(String(date.getUTCMonth() + 1), 2, "0");
          var day = utils_1.padStart(String(date.getUTCDate()), 2, "0");
          var hours = utils_1.padStart(String(date.getUTCHours()), 2, "0");
          var mins = utils_1.padStart(String(date.getUTCMinutes()), 2, "0");
          var secs = utils_1.padStart(String(date.getUTCSeconds()), 2, "0");
          return new PDFString2("D:" + year + month + day + hours + mins + secs + "Z");
        };
        return PDFString2;
      }(PDFObject_1.default)
    );
    exports.default = PDFString;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/CustomFontEmbedder.js
var require_CustomFontEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/CustomFontEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CMap_1 = require_CMap();
    var FontFlags_1 = require_FontFlags();
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var utils_1 = require_utils2();
    var CustomFontEmbedder = (
      /** @class */
      function() {
        function CustomFontEmbedder2(font, fontData, customName, fontFeatures) {
          var _this = this;
          this.allGlyphsInFontSortedById = function() {
            var glyphs = new Array(_this.font.characterSet.length);
            for (var idx = 0, len = glyphs.length; idx < len; idx++) {
              var codePoint = _this.font.characterSet[idx];
              glyphs[idx] = _this.font.glyphForCodePoint(codePoint);
            }
            return utils_1.sortedUniq(glyphs.sort(utils_1.byAscendingId), function(g) {
              return g.id;
            });
          };
          this.font = font;
          this.scale = 1e3 / this.font.unitsPerEm;
          this.fontData = fontData;
          this.fontName = this.font.postscriptName || "Font";
          this.customName = customName;
          this.fontFeatures = fontFeatures;
          this.baseFontName = "";
          this.glyphCache = utils_1.Cache.populatedBy(this.allGlyphsInFontSortedById);
        }
        CustomFontEmbedder2.for = function(fontkit, fontData, customName, fontFeatures) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var font;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, fontkit.create(fontData)];
                case 1:
                  font = _a.sent();
                  return [2, new CustomFontEmbedder2(font, fontData, customName, fontFeatures)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.encodeText = function(text) {
          var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
          var hexCodes = new Array(glyphs.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            hexCodes[idx] = utils_1.toHexStringOfMinLength(glyphs[idx].id, 4);
          }
          return PDFHexString_1.default.of(hexCodes.join(""));
        };
        CustomFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
          var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
          var totalWidth = 0;
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            totalWidth += glyphs[idx].advanceWidth * this.scale;
          }
          var scale = size / 1e3;
          return totalWidth * scale;
        };
        CustomFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.descender, descender = _a === void 0 ? true : _a;
          var _b = this.font, ascent = _b.ascent, descent = _b.descent, bbox = _b.bbox;
          var yTop = (ascent || bbox.maxY) * this.scale;
          var yBottom = (descent || bbox.minY) * this.scale;
          var height = yTop - yBottom;
          if (!descender)
            height -= Math.abs(descent) || 0;
          return height / 1e3 * size;
        };
        CustomFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
          var _a = this.font, ascent = _a.ascent, descent = _a.descent, bbox = _a.bbox;
          var yTop = (ascent || bbox.maxY) * this.scale;
          var yBottom = (descent || bbox.minY) * this.scale;
          return 1e3 * height / (yTop - yBottom);
        };
        CustomFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
          this.baseFontName = this.customName || context.addRandomSuffix(this.fontName);
          return this.embedFontDict(context, ref);
        };
        CustomFontEmbedder2.prototype.embedFontDict = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var cidFontDictRef, unicodeCMapRef, fontDict;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.embedCIDFontDict(context)];
                case 1:
                  cidFontDictRef = _a.sent();
                  unicodeCMapRef = this.embedUnicodeCmap(context);
                  fontDict = context.obj({
                    Type: "Font",
                    Subtype: "Type0",
                    BaseFont: this.baseFontName,
                    Encoding: "Identity-H",
                    DescendantFonts: [cidFontDictRef],
                    ToUnicode: unicodeCMapRef
                  });
                  if (ref) {
                    context.assign(ref, fontDict);
                    return [2, ref];
                  } else {
                    return [2, context.register(fontDict)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.isCFF = function() {
          return this.font.cff;
        };
        CustomFontEmbedder2.prototype.embedCIDFontDict = function(context) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var fontDescriptorRef, cidFontDict;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.embedFontDescriptor(context)];
                case 1:
                  fontDescriptorRef = _a.sent();
                  cidFontDict = context.obj({
                    Type: "Font",
                    Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
                    CIDToGIDMap: "Identity",
                    BaseFont: this.baseFontName,
                    CIDSystemInfo: {
                      Registry: PDFString_1.default.of("Adobe"),
                      Ordering: PDFString_1.default.of("Identity"),
                      Supplement: 0
                    },
                    FontDescriptor: fontDescriptorRef,
                    W: this.computeWidths()
                  });
                  return [2, context.register(cidFontDict)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.embedFontDescriptor = function(context) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var fontStreamRef, scale, _a, italicAngle, ascent, descent, capHeight, xHeight, _b, minX, minY, maxX, maxY, fontDescriptor;
            var _c;
            return tslib_1.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, this.embedFontStream(context)];
                case 1:
                  fontStreamRef = _d.sent();
                  scale = this.scale;
                  _a = this.font, italicAngle = _a.italicAngle, ascent = _a.ascent, descent = _a.descent, capHeight = _a.capHeight, xHeight = _a.xHeight;
                  _b = this.font.bbox, minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
                  fontDescriptor = context.obj((_c = {
                    Type: "FontDescriptor",
                    FontName: this.baseFontName,
                    Flags: FontFlags_1.deriveFontFlags(this.font),
                    FontBBox: [minX * scale, minY * scale, maxX * scale, maxY * scale],
                    ItalicAngle: italicAngle,
                    Ascent: ascent * scale,
                    Descent: descent * scale,
                    CapHeight: (capHeight || ascent) * scale,
                    XHeight: (xHeight || 0) * scale,
                    // Not sure how to compute/find this, nor is anybody else really:
                    // https://stackoverflow.com/questions/35485179/stemv-value-of-the-truetype-font
                    StemV: 0
                  }, _c[this.isCFF() ? "FontFile3" : "FontFile2"] = fontStreamRef, _c));
                  return [2, context.register(fontDescriptor)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.serializeFont = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, this.fontData];
            });
          });
        };
        CustomFontEmbedder2.prototype.embedFontStream = function(context) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var fontStream, _a, _b;
            return tslib_1.__generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _b = (_a = context).flateStream;
                  return [4, this.serializeFont()];
                case 1:
                  fontStream = _b.apply(_a, [_c.sent(), {
                    Subtype: this.isCFF() ? "CIDFontType0C" : void 0
                  }]);
                  return [2, context.register(fontStream)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.embedUnicodeCmap = function(context) {
          var cmap = CMap_1.createCmap(this.glyphCache.access(), this.glyphId.bind(this));
          var cmapStream = context.flateStream(cmap);
          return context.register(cmapStream);
        };
        CustomFontEmbedder2.prototype.glyphId = function(glyph) {
          return glyph ? glyph.id : -1;
        };
        CustomFontEmbedder2.prototype.computeWidths = function() {
          var glyphs = this.glyphCache.access();
          var widths = [];
          var currSection = [];
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var currGlyph = glyphs[idx];
            var prevGlyph = glyphs[idx - 1];
            var currGlyphId = this.glyphId(currGlyph);
            var prevGlyphId = this.glyphId(prevGlyph);
            if (idx === 0) {
              widths.push(currGlyphId);
            } else if (currGlyphId - prevGlyphId !== 1) {
              widths.push(currSection);
              widths.push(currGlyphId);
              currSection = [];
            }
            currSection.push(currGlyph.advanceWidth * this.scale);
          }
          widths.push(currSection);
          return widths;
        };
        return CustomFontEmbedder2;
      }()
    );
    exports.default = CustomFontEmbedder;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/CustomFontSubsetEmbedder.js
var require_CustomFontSubsetEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/CustomFontSubsetEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CustomFontEmbedder_1 = tslib_1.__importDefault(require_CustomFontEmbedder());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var utils_1 = require_utils2();
    var CustomFontSubsetEmbedder = (
      /** @class */
      function(_super) {
        tslib_1.__extends(CustomFontSubsetEmbedder2, _super);
        function CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures) {
          var _this = _super.call(this, font, fontData, customFontName, fontFeatures) || this;
          _this.subset = _this.font.createSubset();
          _this.glyphs = [];
          _this.glyphCache = utils_1.Cache.populatedBy(function() {
            return _this.glyphs;
          });
          _this.glyphIdMap = /* @__PURE__ */ new Map();
          return _this;
        }
        CustomFontSubsetEmbedder2.for = function(fontkit, fontData, customFontName, fontFeatures) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var font;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, fontkit.create(fontData)];
                case 1:
                  font = _a.sent();
                  return [2, new CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures)];
              }
            });
          });
        };
        CustomFontSubsetEmbedder2.prototype.encodeText = function(text) {
          var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
          var hexCodes = new Array(glyphs.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var glyph = glyphs[idx];
            var subsetGlyphId = this.subset.includeGlyph(glyph);
            this.glyphs[subsetGlyphId - 1] = glyph;
            this.glyphIdMap.set(glyph.id, subsetGlyphId);
            hexCodes[idx] = utils_1.toHexStringOfMinLength(subsetGlyphId, 4);
          }
          this.glyphCache.invalidate();
          return PDFHexString_1.default.of(hexCodes.join(""));
        };
        CustomFontSubsetEmbedder2.prototype.isCFF = function() {
          return this.subset.cff;
        };
        CustomFontSubsetEmbedder2.prototype.glyphId = function(glyph) {
          return glyph ? this.glyphIdMap.get(glyph.id) : -1;
        };
        CustomFontSubsetEmbedder2.prototype.serializeFont = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var parts = [];
            _this.subset.encodeStream().on("data", function(bytes) {
              return parts.push(bytes);
            }).on("end", function() {
              return resolve(utils_1.mergeUint8Arrays(parts));
            }).on("error", function(err) {
              return reject(err);
            });
          });
        };
        return CustomFontSubsetEmbedder2;
      }(CustomFontEmbedder_1.default)
    );
    exports.default = CustomFontSubsetEmbedder;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/FileEmbedder.js
var require_FileEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/FileEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AFRelationship = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var AFRelationship;
    (function(AFRelationship2) {
      AFRelationship2["Source"] = "Source";
      AFRelationship2["Data"] = "Data";
      AFRelationship2["Alternative"] = "Alternative";
      AFRelationship2["Supplement"] = "Supplement";
      AFRelationship2["EncryptedPayload"] = "EncryptedPayload";
      AFRelationship2["FormData"] = "EncryptedPayload";
      AFRelationship2["Schema"] = "Schema";
      AFRelationship2["Unspecified"] = "Unspecified";
    })(AFRelationship = exports.AFRelationship || (exports.AFRelationship = {}));
    var FileEmbedder = (
      /** @class */
      function() {
        function FileEmbedder2(fileData, fileName, options) {
          if (options === void 0) {
            options = {};
          }
          this.fileData = fileData;
          this.fileName = fileName;
          this.options = options;
        }
        FileEmbedder2.for = function(bytes, fileName, options) {
          if (options === void 0) {
            options = {};
          }
          return new FileEmbedder2(bytes, fileName, options);
        };
        FileEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, mimeType, description, creationDate, modificationDate, afRelationship, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;
            return tslib_1.__generator(this, function(_b) {
              _a = this.options, mimeType = _a.mimeType, description = _a.description, creationDate = _a.creationDate, modificationDate = _a.modificationDate, afRelationship = _a.afRelationship;
              embeddedFileStream = context.flateStream(this.fileData, {
                Type: "EmbeddedFile",
                Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : void 0,
                Params: {
                  Size: this.fileData.length,
                  CreationDate: creationDate ? PDFString_1.default.fromDate(creationDate) : void 0,
                  ModDate: modificationDate ? PDFString_1.default.fromDate(modificationDate) : void 0
                }
              });
              embeddedFileStreamRef = context.register(embeddedFileStream);
              fileSpecDict = context.obj({
                Type: "Filespec",
                F: PDFString_1.default.of(this.fileName),
                UF: PDFHexString_1.default.fromText(this.fileName),
                EF: { F: embeddedFileStreamRef },
                Desc: description ? PDFHexString_1.default.fromText(description) : void 0,
                AFRelationship: afRelationship !== null && afRelationship !== void 0 ? afRelationship : void 0
              });
              if (ref) {
                context.assign(ref, fileSpecDict);
                return [2, ref];
              } else {
                return [2, context.register(fileSpecDict)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        return FileEmbedder2;
      }()
    );
    exports.default = FileEmbedder;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/JpegEmbedder.js
var require_JpegEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/JpegEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var MARKERS = [
      65472,
      65473,
      65474,
      65475,
      65477,
      65478,
      65479,
      65480,
      65481,
      65482,
      65483,
      65484,
      65485,
      65486,
      65487
    ];
    var ColorSpace;
    (function(ColorSpace2) {
      ColorSpace2["DeviceGray"] = "DeviceGray";
      ColorSpace2["DeviceRGB"] = "DeviceRGB";
      ColorSpace2["DeviceCMYK"] = "DeviceCMYK";
    })(ColorSpace || (ColorSpace = {}));
    var ChannelToColorSpace = {
      1: ColorSpace.DeviceGray,
      3: ColorSpace.DeviceRGB,
      4: ColorSpace.DeviceCMYK
    };
    var JpegEmbedder = (
      /** @class */
      function() {
        function JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace) {
          this.imageData = imageData;
          this.bitsPerComponent = bitsPerComponent;
          this.width = width;
          this.height = height;
          this.colorSpace = colorSpace;
        }
        JpegEmbedder2.for = function(imageData) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var dataView, soi, pos, marker, bitsPerComponent, height, width, channelByte, channelName, colorSpace;
            return tslib_1.__generator(this, function(_a) {
              dataView = new DataView(imageData.buffer);
              soi = dataView.getUint16(0);
              if (soi !== 65496)
                throw new Error("SOI not found in JPEG");
              pos = 2;
              while (pos < dataView.byteLength) {
                marker = dataView.getUint16(pos);
                pos += 2;
                if (MARKERS.includes(marker))
                  break;
                pos += dataView.getUint16(pos);
              }
              if (!MARKERS.includes(marker))
                throw new Error("Invalid JPEG");
              pos += 2;
              bitsPerComponent = dataView.getUint8(pos++);
              height = dataView.getUint16(pos);
              pos += 2;
              width = dataView.getUint16(pos);
              pos += 2;
              channelByte = dataView.getUint8(pos++);
              channelName = ChannelToColorSpace[channelByte];
              if (!channelName)
                throw new Error("Unknown JPEG channel.");
              colorSpace = channelName;
              return [2, new JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace)];
            });
          });
        };
        JpegEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var xObject;
            return tslib_1.__generator(this, function(_a) {
              xObject = context.stream(this.imageData, {
                Type: "XObject",
                Subtype: "Image",
                BitsPerComponent: this.bitsPerComponent,
                Width: this.width,
                Height: this.height,
                ColorSpace: this.colorSpace,
                Filter: "DCTDecode",
                // CMYK JPEG streams in PDF are typically stored complemented,
                // with 1 as 'off' and 0 as 'on' (PDF 32000-1:2008, 8.6.4.4).
                //
                // Standalone CMYK JPEG (usually exported by Photoshop) are
                // stored inverse, with 0 as 'off' and 1 as 'on', like RGB.
                //
                // Applying a swap here as a hedge that most bytes passing
                // through this method will benefit from it.
                Decode: this.colorSpace === ColorSpace.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0
              });
              if (ref) {
                context.assign(ref, xObject);
                return [2, ref];
              } else {
                return [2, context.register(xObject)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        return JpegEmbedder2;
      }()
    );
    exports.default = JpegEmbedder;
  }
});

// node_modules/@pdf-lib/upng/cjs/UPNG.js
var require_UPNG = __commonJS({
  "node_modules/@pdf-lib/upng/cjs/UPNG.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _pako = _interopRequireDefault(require_pako());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UPNG = {};
    UPNG.toRGBA8 = function(out) {
      var w = out.width, h = out.height;
      if (out.tabs.acTL == null)
        return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
      var frms = [];
      if (out.frames[0].data == null)
        out.frames[0].data = out.data;
      var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
      for (var i = 0; i < out.frames.length; i++) {
        var frm = out.frames[i];
        var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
        var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
        if (i != 0)
          for (var j = 0; j < len; j++)
            prev[j] = img[j];
        if (frm.blend == 0)
          UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
        else if (frm.blend == 1)
          UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
        frms.push(img.buffer.slice(0));
        if (frm.dispose == 0) {
        } else if (frm.dispose == 1)
          UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
        else if (frm.dispose == 2)
          for (var j = 0; j < len; j++)
            img[j] = prev[j];
      }
      return frms;
    };
    UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
      var area = w * h, bpp = UPNG.decode._getBPP(out);
      var bpl = Math.ceil(w * bpp / 8);
      var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
      var ctype = out.ctype, depth = out.depth;
      var rs = UPNG._bin.readUshort;
      var time = Date.now();
      if (ctype == 6) {
        var qarea = area << 2;
        if (depth == 8)
          for (var i = 0; i < qarea; i += 4) {
            bf[i] = data[i];
            bf[i + 1] = data[i + 1];
            bf[i + 2] = data[i + 2];
            bf[i + 3] = data[i + 3];
          }
        if (depth == 16)
          for (var i = 0; i < qarea; i++) {
            bf[i] = data[i << 1];
          }
      } else if (ctype == 2) {
        var ts = out.tabs["tRNS"];
        if (ts == null) {
          if (depth == 8)
            for (var i = 0; i < area; i++) {
              var ti = i * 3;
              bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
            }
          if (depth == 16)
            for (var i = 0; i < area; i++) {
              var ti = i * 6;
              bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
            }
        } else {
          var tr = ts[0], tg = ts[1], tb = ts[2];
          if (depth == 8)
            for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 3;
              bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
              if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
                bf[qi + 3] = 0;
            }
          if (depth == 16)
            for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 6;
              bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
              if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
                bf[qi + 3] = 0;
            }
        }
      } else if (ctype == 3) {
        var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
        if (depth == 1)
          for (var y = 0; y < h; y++) {
            var s0 = y * bpl, t0 = y * w;
            for (var i = 0; i < w; i++) {
              var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
              bf[qi] = p[cj];
              bf[qi + 1] = p[cj + 1];
              bf[qi + 2] = p[cj + 2];
              bf[qi + 3] = j < tl ? ap[j] : 255;
            }
          }
        if (depth == 2)
          for (var y = 0; y < h; y++) {
            var s0 = y * bpl, t0 = y * w;
            for (var i = 0; i < w; i++) {
              var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
              bf[qi] = p[cj];
              bf[qi + 1] = p[cj + 1];
              bf[qi + 2] = p[cj + 2];
              bf[qi + 3] = j < tl ? ap[j] : 255;
            }
          }
        if (depth == 4)
          for (var y = 0; y < h; y++) {
            var s0 = y * bpl, t0 = y * w;
            for (var i = 0; i < w; i++) {
              var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
              bf[qi] = p[cj];
              bf[qi + 1] = p[cj + 1];
              bf[qi + 2] = p[cj + 2];
              bf[qi + 3] = j < tl ? ap[j] : 255;
            }
          }
        if (depth == 8)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, j = data[i], cj = 3 * j;
            bf[qi] = p[cj];
            bf[qi + 1] = p[cj + 1];
            bf[qi + 2] = p[cj + 2];
            bf[qi + 3] = j < tl ? ap[j] : 255;
          }
      } else if (ctype == 4) {
        if (depth == 8)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, di = i << 1, gr = data[di];
            bf[qi] = gr;
            bf[qi + 1] = gr;
            bf[qi + 2] = gr;
            bf[qi + 3] = data[di + 1];
          }
        if (depth == 16)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, di = i << 2, gr = data[di];
            bf[qi] = gr;
            bf[qi + 1] = gr;
            bf[qi + 2] = gr;
            bf[qi + 3] = data[di + 2];
          }
      } else if (ctype == 0) {
        var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
        for (var y = 0; y < h; y++) {
          var off = y * bpl, to = y * w;
          if (depth == 1)
            for (var x = 0; x < w; x++) {
              var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 2)
            for (var x = 0; x < w; x++) {
              var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 4)
            for (var x = 0; x < w; x++) {
              var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 8)
            for (var x = 0; x < w; x++) {
              var gr = data[off + x], al = gr == tr ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 16)
            for (var x = 0; x < w; x++) {
              var gr = data[off + (x << 1)], al = rs(data, off + (x << i)) == tr ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
        }
      }
      return bf;
    };
    UPNG.decode = function(buff) {
      var data = new Uint8Array(buff), offset2 = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
      var out = {
        tabs: {},
        frames: []
      };
      var dd = new Uint8Array(data.length), doff = 0;
      var fd, foff = 0;
      var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
      for (var i = 0; i < 8; i++)
        if (data[i] != mgck[i])
          throw "The input is not a PNG file!";
      while (offset2 < data.length) {
        var len = bin.readUint(data, offset2);
        offset2 += 4;
        var type = bin.readASCII(data, offset2, 4);
        offset2 += 4;
        if (type == "IHDR") {
          UPNG.decode._IHDR(data, offset2, out);
        } else if (type == "IDAT") {
          for (var i = 0; i < len; i++)
            dd[doff + i] = data[offset2 + i];
          doff += len;
        } else if (type == "acTL") {
          out.tabs[type] = {
            num_frames: rUi(data, offset2),
            num_plays: rUi(data, offset2 + 4)
          };
          fd = new Uint8Array(data.length);
        } else if (type == "fcTL") {
          if (foff != 0) {
            var fr = out.frames[out.frames.length - 1];
            fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
            foff = 0;
          }
          var rct = {
            x: rUi(data, offset2 + 12),
            y: rUi(data, offset2 + 16),
            width: rUi(data, offset2 + 4),
            height: rUi(data, offset2 + 8)
          };
          var del = rUs(data, offset2 + 22);
          del = rUs(data, offset2 + 20) / (del == 0 ? 100 : del);
          var frm = {
            rect: rct,
            delay: Math.round(del * 1e3),
            dispose: data[offset2 + 24],
            blend: data[offset2 + 25]
          };
          out.frames.push(frm);
        } else if (type == "fdAT") {
          for (var i = 0; i < len - 4; i++)
            fd[foff + i] = data[offset2 + i + 4];
          foff += len - 4;
        } else if (type == "pHYs") {
          out.tabs[type] = [bin.readUint(data, offset2), bin.readUint(data, offset2 + 4), data[offset2 + 8]];
        } else if (type == "cHRM") {
          out.tabs[type] = [];
          for (var i = 0; i < 8; i++)
            out.tabs[type].push(bin.readUint(data, offset2 + i * 4));
        } else if (type == "tEXt") {
          if (out.tabs[type] == null)
            out.tabs[type] = {};
          var nz = bin.nextZero(data, offset2);
          var keyw = bin.readASCII(data, offset2, nz - offset2);
          var text = bin.readASCII(data, nz + 1, offset2 + len - nz - 1);
          out.tabs[type][keyw] = text;
        } else if (type == "iTXt") {
          if (out.tabs[type] == null)
            out.tabs[type] = {};
          var nz = 0, off = offset2;
          nz = bin.nextZero(data, off);
          var keyw = bin.readASCII(data, off, nz - off);
          off = nz + 1;
          var cflag = data[off], cmeth = data[off + 1];
          off += 2;
          nz = bin.nextZero(data, off);
          var ltag = bin.readASCII(data, off, nz - off);
          off = nz + 1;
          nz = bin.nextZero(data, off);
          var tkeyw = bin.readUTF8(data, off, nz - off);
          off = nz + 1;
          var text = bin.readUTF8(data, off, len - (off - offset2));
          out.tabs[type][keyw] = text;
        } else if (type == "PLTE") {
          out.tabs[type] = bin.readBytes(data, offset2, len);
        } else if (type == "hIST") {
          var pl = out.tabs["PLTE"].length / 3;
          out.tabs[type] = [];
          for (var i = 0; i < pl; i++)
            out.tabs[type].push(rUs(data, offset2 + i * 2));
        } else if (type == "tRNS") {
          if (out.ctype == 3)
            out.tabs[type] = bin.readBytes(data, offset2, len);
          else if (out.ctype == 0)
            out.tabs[type] = rUs(data, offset2);
          else if (out.ctype == 2)
            out.tabs[type] = [rUs(data, offset2), rUs(data, offset2 + 2), rUs(data, offset2 + 4)];
        } else if (type == "gAMA")
          out.tabs[type] = bin.readUint(data, offset2) / 1e5;
        else if (type == "sRGB")
          out.tabs[type] = data[offset2];
        else if (type == "bKGD") {
          if (out.ctype == 0 || out.ctype == 4)
            out.tabs[type] = [rUs(data, offset2)];
          else if (out.ctype == 2 || out.ctype == 6)
            out.tabs[type] = [rUs(data, offset2), rUs(data, offset2 + 2), rUs(data, offset2 + 4)];
          else if (out.ctype == 3)
            out.tabs[type] = data[offset2];
        } else if (type == "IEND") {
          break;
        }
        offset2 += len;
        var crc = bin.readUint(data, offset2);
        offset2 += 4;
      }
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
      delete out.compress;
      delete out.interlace;
      delete out.filter;
      return out;
    };
    UPNG.decode._decompress = function(out, dd, w, h) {
      var time = Date.now();
      var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
      dd = UPNG.decode._inflate(dd, buff);
      var time = Date.now();
      if (out.interlace == 0)
        dd = UPNG.decode._filterZero(dd, out, 0, w, h);
      else if (out.interlace == 1)
        dd = UPNG.decode._readInterlace(dd, out);
      return dd;
    };
    UPNG.decode._inflate = function(data, buff) {
      var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
      return out;
    };
    UPNG.inflateRaw = function() {
      var H = {};
      H.H = {};
      H.H.N = function(N, W) {
        var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;
        if (N[0] == 3 && N[1] == 0)
          return W ? W : new R(0);
        var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;
        if (Z)
          W = new R(N.length >>> 2 << 3);
        while (i == 0) {
          i = n(N, d, 1);
          m = n(N, d + 1, 2);
          d += 3;
          if (m == 0) {
            if ((d & 7) != 0)
              d += 8 - (d & 7);
            var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
            if (Z)
              W = H.H.W(W, w + q);
            W.set(new R(N.buffer, N.byteOffset + D, q), w);
            d = D + q << 3;
            w += q;
            continue;
          }
          if (Z)
            W = H.H.W(W, w + (1 << 17));
          if (m == 1) {
            v = b.J;
            C = b.h;
            X = (1 << 9) - 1;
            u = (1 << 5) - 1;
          }
          if (m == 2) {
            J = A(N, d, 5) + 257;
            h = A(N, d + 5, 5) + 1;
            Q = A(N, d + 10, 4) + 4;
            d += 14;
            var E = d, j = 1;
            for (var c = 0; c < 38; c += 2) {
              b.Q[c] = 0;
              b.Q[c + 1] = 0;
            }
            for (var c = 0; c < Q; c++) {
              var K = A(N, d + c * 3, 3);
              b.Q[(b.X[c] << 1) + 1] = K;
              if (K > j)
                j = K;
            }
            d += 3 * Q;
            M(b.Q, j);
            I(b.Q, j, b.u);
            v = b.w;
            C = b.d;
            d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);
            var r = V.V(b.v, 0, J, b.C);
            X = (1 << r) - 1;
            var S = V.V(b.v, J, h, b.D);
            u = (1 << S) - 1;
            M(b.C, r);
            I(b.C, r, v);
            M(b.D, S);
            I(b.D, S, C);
          }
          while (true) {
            var T = v[e(N, d) & X];
            d += T & 15;
            var p = T >>> 4;
            if (p >>> 8 == 0) {
              W[w++] = p;
            } else if (p == 256) {
              break;
            } else {
              var z = w + p - 254;
              if (p > 264) {
                var _ = b.q[p - 257];
                z = w + (_ >>> 3) + A(N, d, _ & 7);
                d += _ & 7;
              }
              var $ = C[e(N, d) & u];
              d += $ & 15;
              var s = $ >>> 4, Y = b.c[s], a = (Y >>> 4) + n(N, d, Y & 15);
              d += Y & 15;
              while (w < z) {
                W[w] = W[w++ - a];
                W[w] = W[w++ - a];
                W[w] = W[w++ - a];
                W[w] = W[w++ - a];
              }
              w = z;
            }
          }
        }
        return W.length == w ? W : W.slice(0, w);
      };
      H.H.W = function(N, W) {
        var R = N.length;
        if (W <= R)
          return N;
        var V = new Uint8Array(R << 1);
        V.set(N, 0);
        return V;
      };
      H.H.R = function(N, W, R, V, n, A) {
        var l = H.H.e, M = H.H.Z, I = 0;
        while (I < R) {
          var e = N[M(V, n) & W];
          n += e & 15;
          var b = e >>> 4;
          if (b <= 15) {
            A[I] = b;
            I++;
          } else {
            var Z = 0, m = 0;
            if (b == 16) {
              m = 3 + l(V, n, 2);
              n += 2;
              Z = A[I - 1];
            } else if (b == 17) {
              m = 3 + l(V, n, 3);
              n += 3;
            } else if (b == 18) {
              m = 11 + l(V, n, 7);
              n += 7;
            }
            var J = I + m;
            while (I < J) {
              A[I] = Z;
              I++;
            }
          }
        }
        return n;
      };
      H.H.V = function(N, W, R, V) {
        var n = 0, A = 0, l = V.length >>> 1;
        while (A < R) {
          var M = N[A + W];
          V[A << 1] = 0;
          V[(A << 1) + 1] = M;
          if (M > n)
            n = M;
          A++;
        }
        while (A < l) {
          V[A << 1] = 0;
          V[(A << 1) + 1] = 0;
          A++;
        }
        return n;
      };
      H.H.n = function(N, W) {
        var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j;
        for (var M = 0; M <= W; M++)
          e[M] = 0;
        for (M = 1; M < V; M += 2)
          e[N[M]]++;
        var b = R.K;
        n = 0;
        e[0] = 0;
        for (A = 1; A <= W; A++) {
          n = n + e[A - 1] << 1;
          b[A] = n;
        }
        for (l = 0; l < V; l += 2) {
          I = N[l + 1];
          if (I != 0) {
            N[l] = b[I];
            b[I]++;
          }
        }
      };
      H.H.A = function(N, W, R) {
        var V = N.length, n = H.H.m, A = n.r;
        for (var l = 0; l < V; l += 2)
          if (N[l + 1] != 0) {
            var M = l >> 1, I = N[l + 1], e = M << 4 | I, b = W - I, Z = N[l] << b, m = Z + (1 << b);
            while (Z != m) {
              var J = A[Z] >>> 15 - W;
              R[J] = e;
              Z++;
            }
          }
      };
      H.H.l = function(N, W) {
        var R = H.H.m.r, V = 15 - W;
        for (var n = 0; n < N.length; n += 2) {
          var A = N[n] << W - N[n + 1];
          N[n] = R[A] >>> V;
        }
      };
      H.H.M = function(N, W, R) {
        R = R << (W & 7);
        var V = W >>> 3;
        N[V] |= R;
        N[V + 1] |= R >>> 8;
      };
      H.H.I = function(N, W, R) {
        R = R << (W & 7);
        var V = W >>> 3;
        N[V] |= R;
        N[V + 1] |= R >>> 8;
        N[V + 2] |= R >>> 16;
      };
      H.H.e = function(N, W, R) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;
      };
      H.H.b = function(N, W, R) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;
      };
      H.H.Z = function(N, W) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
      };
      H.H.i = function(N, W) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
      };
      H.H.m = function() {
        var N = Uint16Array, W = Uint32Array;
        return {
          K: new N(16),
          j: new N(16),
          X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
          S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
          T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
          q: new N(32),
          p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
          z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
          c: new W(32),
          J: new N(512),
          _: [],
          h: new N(32),
          $: [],
          w: new N(32768),
          C: [],
          v: [],
          d: new N(32768),
          D: [],
          u: new N(512),
          Q: [],
          r: new N(1 << 15),
          s: new W(286),
          Y: new W(30),
          a: new W(19),
          t: new W(15e3),
          k: new N(1 << 16),
          g: new N(1 << 15)
        };
      }();
      (function() {
        var N = H.H.m, W = 1 << 15;
        for (var R = 0; R < W; R++) {
          var V = R;
          V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
          V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
          V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
          V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
          N.r[R] = (V >>> 16 | V << 16) >>> 17;
        }
        function n(A, l, M) {
          while (l-- != 0)
            A.push(0, M);
        }
        for (var R = 0; R < 32; R++) {
          N.q[R] = N.S[R] << 3 | N.T[R];
          N.c[R] = N.p[R] << 4 | N.z[R];
        }
        n(N._, 144, 8);
        n(N._, 255 - 143, 9);
        n(N._, 279 - 255, 7);
        n(N._, 287 - 279, 8);
        H.H.n(N._, 9);
        H.H.A(N._, 9, N.J);
        H.H.l(N._, 9);
        n(N.$, 32, 5);
        H.H.n(N.$, 5);
        H.H.A(N.$, 5, N.h);
        H.H.l(N.$, 5);
        n(N.Q, 19, 0);
        n(N.C, 286, 0);
        n(N.D, 30, 0);
        n(N.v, 320, 0);
      })();
      return H.H.N;
    }();
    UPNG.decode._readInterlace = function(data, out) {
      var w = out.width, h = out.height;
      var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
      var img = new Uint8Array(h * bpl);
      var di = 0;
      var starting_row = [0, 0, 4, 0, 2, 0, 1];
      var starting_col = [0, 4, 0, 2, 0, 1, 0];
      var row_increment = [8, 8, 8, 4, 4, 2, 2];
      var col_increment = [8, 8, 4, 4, 2, 2, 1];
      var pass = 0;
      while (pass < 7) {
        var ri = row_increment[pass], ci = col_increment[pass];
        var sw = 0, sh = 0;
        var cr = starting_row[pass];
        while (cr < h) {
          cr += ri;
          sh++;
        }
        var cc = starting_col[pass];
        while (cc < w) {
          cc += ci;
          sw++;
        }
        var bpll = Math.ceil(sw * bpp / 8);
        UPNG.decode._filterZero(data, out, di, sw, sh);
        var y = 0, row = starting_row[pass];
        while (row < h) {
          var col = starting_col[pass];
          var cdi = di + y * bpll << 3;
          while (col < w) {
            if (bpp == 1) {
              var val = data[cdi >> 3];
              val = val >> 7 - (cdi & 7) & 1;
              img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
            }
            if (bpp == 2) {
              var val = data[cdi >> 3];
              val = val >> 6 - (cdi & 7) & 3;
              img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
            }
            if (bpp == 4) {
              var val = data[cdi >> 3];
              val = val >> 4 - (cdi & 7) & 15;
              img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
            }
            if (bpp >= 8) {
              var ii = row * bpl + col * cbpp;
              for (var j = 0; j < cbpp; j++)
                img[ii + j] = data[(cdi >> 3) + j];
            }
            cdi += bpp;
            col += ci;
          }
          y++;
          row += ri;
        }
        if (sw * sh != 0)
          di += sh * (1 + bpll);
        pass = pass + 1;
      }
      return img;
    };
    UPNG.decode._getBPP = function(out) {
      var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
      return noc * out.depth;
    };
    UPNG.decode._filterZero = function(data, out, off, w, h) {
      var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
      bpp = Math.ceil(bpp / 8);
      var i = 0, di = 1, type = data[off], x = 0;
      if (type > 1)
        data[off] = [0, 0, 1][type - 2];
      if (type == 3)
        for (x = bpp; x < bpl; x++)
          data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
      for (var y = 0; y < h; y++) {
        i = off + y * bpl;
        di = i + y + 1;
        type = data[di - 1];
        x = 0;
        if (type == 0)
          for (; x < bpl; x++)
            data[i + x] = data[di + x];
        else if (type == 1) {
          for (; x < bpp; x++)
            data[i + x] = data[di + x];
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + data[i + x - bpp];
        } else if (type == 2) {
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + data[i + x - bpl];
        } else if (type == 3) {
          for (; x < bpp; x++)
            data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);
        } else {
          for (; x < bpp; x++)
            data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);
        }
      }
      return data;
    };
    UPNG.decode._paeth = function(a, b, c) {
      var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;
      if (pa * pa <= pb * pb && pa * pa <= pc * pc)
        return a;
      else if (pb * pb <= pc * pc)
        return b;
      return c;
    };
    UPNG.decode._IHDR = function(data, offset2, out) {
      var bin = UPNG._bin;
      out.width = bin.readUint(data, offset2);
      offset2 += 4;
      out.height = bin.readUint(data, offset2);
      offset2 += 4;
      out.depth = data[offset2];
      offset2++;
      out.ctype = data[offset2];
      offset2++;
      out.compress = data[offset2];
      offset2++;
      out.filter = data[offset2];
      offset2++;
      out.interlace = data[offset2];
      offset2++;
    };
    UPNG._bin = {
      nextZero: function(data, p) {
        while (data[p] != 0)
          p++;
        return p;
      },
      readUshort: function(buff, p) {
        return buff[p] << 8 | buff[p + 1];
      },
      writeUshort: function(buff, p, n) {
        buff[p] = n >> 8 & 255;
        buff[p + 1] = n & 255;
      },
      readUint: function(buff, p) {
        return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
      },
      writeUint: function(buff, p, n) {
        buff[p] = n >> 24 & 255;
        buff[p + 1] = n >> 16 & 255;
        buff[p + 2] = n >> 8 & 255;
        buff[p + 3] = n & 255;
      },
      readASCII: function(buff, p, l) {
        var s = "";
        for (var i = 0; i < l; i++)
          s += String.fromCharCode(buff[p + i]);
        return s;
      },
      writeASCII: function(data, p, s) {
        for (var i = 0; i < s.length; i++)
          data[p + i] = s.charCodeAt(i);
      },
      readBytes: function(buff, p, l) {
        var arr = [];
        for (var i = 0; i < l; i++)
          arr.push(buff[p + i]);
        return arr;
      },
      pad: function(n) {
        return n.length < 2 ? "0" + n : n;
      },
      readUTF8: function(buff, p, l) {
        var s = "", ns;
        for (var i = 0; i < l; i++)
          s += "%" + UPNG._bin.pad(buff[p + i].toString(16));
        try {
          ns = decodeURIComponent(s);
        } catch (e) {
          return UPNG._bin.readASCII(buff, p, l);
        }
        return ns;
      }
    };
    UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
      var w = Math.min(sw, tw), h = Math.min(sh, th);
      var si = 0, ti = 0;
      for (var y = 0; y < h; y++)
        for (var x = 0; x < w; x++) {
          if (xoff >= 0 && yoff >= 0) {
            si = y * sw + x << 2;
            ti = (yoff + y) * tw + xoff + x << 2;
          } else {
            si = (-yoff + y) * sw - xoff + x << 2;
            ti = y * tw + x << 2;
          }
          if (mode == 0) {
            tb[ti] = sb[si];
            tb[ti + 1] = sb[si + 1];
            tb[ti + 2] = sb[si + 2];
            tb[ti + 3] = sb[si + 3];
          } else if (mode == 1) {
            var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
            var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
            var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
            tb[ti + 3] = 255 * oa;
            tb[ti + 0] = (fr + br * ifa) * ioa;
            tb[ti + 1] = (fg + bg * ifa) * ioa;
            tb[ti + 2] = (fb + bb * ifa) * ioa;
          } else if (mode == 2) {
            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
            if (fa == ba && fr == br && fg == bg && fb == bb) {
              tb[ti] = 0;
              tb[ti + 1] = 0;
              tb[ti + 2] = 0;
              tb[ti + 3] = 0;
            } else {
              tb[ti] = fr;
              tb[ti + 1] = fg;
              tb[ti + 2] = fb;
              tb[ti + 3] = fa;
            }
          } else if (mode == 3) {
            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
            if (fa == ba && fr == br && fg == bg && fb == bb)
              continue;
            if (fa < 220 && ba > 20)
              return false;
          }
        }
      return true;
    };
    UPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte) {
      if (ps == null)
        ps = 0;
      if (forbidPlte == null)
        forbidPlte = false;
      var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);
      UPNG.encode.compressPNG(nimg, -1);
      return UPNG.encode._main(nimg, w, h, dels, tabs);
    };
    UPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {
      var nimg = {
        ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4),
        depth,
        frames: []
      };
      var time = Date.now();
      var bipp = (cc + ac) * depth, bipl = bipp * w;
      for (var i = 0; i < bufs.length; i++)
        nimg.frames.push({
          rect: {
            x: 0,
            y: 0,
            width: w,
            height: h
          },
          img: new Uint8Array(bufs[i]),
          blend: 0,
          dispose: 1,
          bpp: Math.ceil(bipp / 8),
          bpl: Math.ceil(bipl / 8)
        });
      UPNG.encode.compressPNG(nimg, 0, true);
      var out = UPNG.encode._main(nimg, w, h, dels, tabs);
      return out;
    };
    UPNG.encode._main = function(nimg, w, h, dels, tabs) {
      if (tabs == null)
        tabs = {};
      var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;
      var offset2 = 8, anim = nimg.frames.length > 1, pltAlpha = false;
      var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);
      if (tabs["sRGB"] != null)
        leng += 8 + 1 + 4;
      if (tabs["pHYs"] != null)
        leng += 8 + 9 + 4;
      if (nimg.ctype == 3) {
        var dl = nimg.plte.length;
        for (var i = 0; i < dl; i++)
          if (nimg.plte[i] >>> 24 != 255)
            pltAlpha = true;
        leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);
      }
      for (var j = 0; j < nimg.frames.length; j++) {
        var fr = nimg.frames[j];
        if (anim)
          leng += 38;
        leng += fr.cimg.length + 12;
        if (j != 0)
          leng += 4;
      }
      leng += 12;
      var data = new Uint8Array(leng);
      var wr = [137, 80, 78, 71, 13, 10, 26, 10];
      for (var i = 0; i < 8; i++)
        data[i] = wr[i];
      wUi(data, offset2, 13);
      offset2 += 4;
      wAs(data, offset2, "IHDR");
      offset2 += 4;
      wUi(data, offset2, w);
      offset2 += 4;
      wUi(data, offset2, h);
      offset2 += 4;
      data[offset2] = nimg.depth;
      offset2++;
      data[offset2] = nimg.ctype;
      offset2++;
      data[offset2] = 0;
      offset2++;
      data[offset2] = 0;
      offset2++;
      data[offset2] = 0;
      offset2++;
      wUi(data, offset2, crc(data, offset2 - 17, 17));
      offset2 += 4;
      if (tabs["sRGB"] != null) {
        wUi(data, offset2, 1);
        offset2 += 4;
        wAs(data, offset2, "sRGB");
        offset2 += 4;
        data[offset2] = tabs["sRGB"];
        offset2++;
        wUi(data, offset2, crc(data, offset2 - 5, 5));
        offset2 += 4;
      }
      if (tabs["pHYs"] != null) {
        wUi(data, offset2, 9);
        offset2 += 4;
        wAs(data, offset2, "pHYs");
        offset2 += 4;
        wUi(data, offset2, tabs["pHYs"][0]);
        offset2 += 4;
        wUi(data, offset2, tabs["pHYs"][1]);
        offset2 += 4;
        data[offset2] = tabs["pHYs"][2];
        offset2++;
        wUi(data, offset2, crc(data, offset2 - 13, 13));
        offset2 += 4;
      }
      if (anim) {
        wUi(data, offset2, 8);
        offset2 += 4;
        wAs(data, offset2, "acTL");
        offset2 += 4;
        wUi(data, offset2, nimg.frames.length);
        offset2 += 4;
        wUi(data, offset2, tabs["loop"] != null ? tabs["loop"] : 0);
        offset2 += 4;
        wUi(data, offset2, crc(data, offset2 - 12, 12));
        offset2 += 4;
      }
      if (nimg.ctype == 3) {
        var dl = nimg.plte.length;
        wUi(data, offset2, dl * 3);
        offset2 += 4;
        wAs(data, offset2, "PLTE");
        offset2 += 4;
        for (var i = 0; i < dl; i++) {
          var ti = i * 3, c = nimg.plte[i], r = c & 255, g = c >>> 8 & 255, b = c >>> 16 & 255;
          data[offset2 + ti + 0] = r;
          data[offset2 + ti + 1] = g;
          data[offset2 + ti + 2] = b;
        }
        offset2 += dl * 3;
        wUi(data, offset2, crc(data, offset2 - dl * 3 - 4, dl * 3 + 4));
        offset2 += 4;
        if (pltAlpha) {
          wUi(data, offset2, dl);
          offset2 += 4;
          wAs(data, offset2, "tRNS");
          offset2 += 4;
          for (var i = 0; i < dl; i++)
            data[offset2 + i] = nimg.plte[i] >>> 24 & 255;
          offset2 += dl;
          wUi(data, offset2, crc(data, offset2 - dl - 4, dl + 4));
          offset2 += 4;
        }
      }
      var fi = 0;
      for (var j = 0; j < nimg.frames.length; j++) {
        var fr = nimg.frames[j];
        if (anim) {
          wUi(data, offset2, 26);
          offset2 += 4;
          wAs(data, offset2, "fcTL");
          offset2 += 4;
          wUi(data, offset2, fi++);
          offset2 += 4;
          wUi(data, offset2, fr.rect.width);
          offset2 += 4;
          wUi(data, offset2, fr.rect.height);
          offset2 += 4;
          wUi(data, offset2, fr.rect.x);
          offset2 += 4;
          wUi(data, offset2, fr.rect.y);
          offset2 += 4;
          wUs(data, offset2, dels[j]);
          offset2 += 2;
          wUs(data, offset2, 1e3);
          offset2 += 2;
          data[offset2] = fr.dispose;
          offset2++;
          data[offset2] = fr.blend;
          offset2++;
          wUi(data, offset2, crc(data, offset2 - 30, 30));
          offset2 += 4;
        }
        var imgd = fr.cimg, dl = imgd.length;
        wUi(data, offset2, dl + (j == 0 ? 0 : 4));
        offset2 += 4;
        var ioff = offset2;
        wAs(data, offset2, j == 0 ? "IDAT" : "fdAT");
        offset2 += 4;
        if (j != 0) {
          wUi(data, offset2, fi++);
          offset2 += 4;
        }
        data.set(imgd, offset2);
        offset2 += dl;
        wUi(data, offset2, crc(data, ioff, offset2 - ioff));
        offset2 += 4;
      }
      wUi(data, offset2, 0);
      offset2 += 4;
      wAs(data, offset2, "IEND");
      offset2 += 4;
      wUi(data, offset2, crc(data, offset2 - 4, 4));
      offset2 += 4;
      return data.buffer;
    };
    UPNG.encode.compressPNG = function(out, filter, levelZero) {
      for (var i = 0; i < out.frames.length; i++) {
        var frm = out.frames[i], nw = frm.rect.width, nh = frm.rect.height;
        var fdata = new Uint8Array(nh * frm.bpl + nh);
        frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);
      }
    };
    UPNG.encode.compress = function(bufs, w, h, ps, prms) {
      var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];
      var ctype = 6, depth = 8, alphaAnd = 255;
      for (var j = 0; j < bufs.length; j++) {
        var img = new Uint8Array(bufs[j]), ilen = img.length;
        for (var i = 0; i < ilen; i += 4)
          alphaAnd &= img[i + 3];
      }
      var gotAlpha = alphaAnd != 255;
      var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);
      var cmap = {}, plte = [], inds = [];
      if (ps != 0) {
        var nbufs = [];
        for (var i = 0; i < frms.length; i++)
          nbufs.push(frms[i].img.buffer);
        var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);
        var cof = 0, bb = new Uint8Array(qres.abuf);
        for (var i = 0; i < frms.length; i++) {
          var ti = frms[i].img, bln = ti.length;
          inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));
          for (var j = 0; j < bln; j += 4) {
            ti[j] = bb[cof + j];
            ti[j + 1] = bb[cof + j + 1];
            ti[j + 2] = bb[cof + j + 2];
            ti[j + 3] = bb[cof + j + 3];
          }
          cof += bln;
        }
        for (var i = 0; i < qres.plte.length; i++)
          plte.push(qres.plte[i].est.rgba);
      } else {
        for (var j = 0; j < frms.length; j++) {
          var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;
          var ind = new Uint8Array(ilen);
          inds.push(ind);
          for (var i = 0; i < ilen; i++) {
            var c = img32[i];
            if (i != 0 && c == img32[i - 1])
              ind[i] = ind[i - 1];
            else if (i > nw && c == img32[i - nw])
              ind[i] = ind[i - nw];
            else {
              var cmc = cmap[c];
              if (cmc == null) {
                cmap[c] = cmc = plte.length;
                plte.push(c);
                if (plte.length >= 300)
                  break;
              }
              ind[i] = cmc;
            }
          }
        }
      }
      var cc = plte.length;
      if (cc <= 256 && forbidPlte == false) {
        if (cc <= 2)
          depth = 1;
        else if (cc <= 4)
          depth = 2;
        else if (cc <= 16)
          depth = 4;
        else
          depth = 8;
        depth = Math.max(depth, minBits);
      }
      for (var j = 0; j < frms.length; j++) {
        var frm = frms[j], nx = frm.rect.x, ny = frm.rect.y, nw = frm.rect.width, nh = frm.rect.height;
        var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);
        var bpl = 4 * nw, bpp = 4;
        if (cc <= 256 && forbidPlte == false) {
          bpl = Math.ceil(depth * nw / 8);
          var nimg = new Uint8Array(bpl * nh);
          var inj = inds[j];
          for (var y = 0; y < nh; y++) {
            var i = y * bpl, ii = y * nw;
            if (depth == 8)
              for (var x = 0; x < nw; x++)
                nimg[i + x] = inj[ii + x];
            else if (depth == 4)
              for (var x = 0; x < nw; x++)
                nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;
            else if (depth == 2)
              for (var x = 0; x < nw; x++)
                nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;
            else if (depth == 1)
              for (var x = 0; x < nw; x++)
                nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;
          }
          cimg = nimg;
          ctype = 3;
          bpp = 1;
        } else if (gotAlpha == false && frms.length == 1) {
          var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;
          for (var i = 0; i < area; i++) {
            var ti = i * 3, qi = i * 4;
            nimg[ti] = cimg[qi];
            nimg[ti + 1] = cimg[qi + 1];
            nimg[ti + 2] = cimg[qi + 2];
          }
          cimg = nimg;
          ctype = 2;
          bpp = 3;
          bpl = 3 * nw;
        }
        frm.img = cimg;
        frm.bpl = bpl;
        frm.bpp = bpp;
      }
      return {
        ctype,
        depth,
        plte,
        frames: frms
      };
    };
    UPNG.encode.framize = function(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {
      var frms = [];
      for (var j = 0; j < bufs.length; j++) {
        var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);
        var nimg;
        var nx = 0, ny = 0, nw = w, nh = h, blend = alwaysBlend ? 1 : 0;
        if (j != 0) {
          var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;
          for (var it = 0; it < tlim; it++) {
            var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);
            var mix = w, miy = h, max2 = -1, may = -1;
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var i = y * w + x;
                if (cimg32[i] != p32[i]) {
                  if (x < mix)
                    mix = x;
                  if (x > max2)
                    max2 = x;
                  if (y < miy)
                    miy = y;
                  if (y > may)
                    may = y;
                }
              }
            if (max2 == -1)
              mix = miy = max2 = may = 0;
            if (evenCrd) {
              if ((mix & 1) == 1)
                mix--;
              if ((miy & 1) == 1)
                miy--;
            }
            var sarea = (max2 - mix + 1) * (may - miy + 1);
            if (sarea < tarea) {
              tarea = sarea;
              tstp = it;
              nx = mix;
              ny = miy;
              nw = max2 - mix + 1;
              nh = may - miy + 1;
            }
          }
          var pimg = new Uint8Array(bufs[j - 1 - tstp]);
          if (tstp == 1)
            frms[j - 1].dispose = 2;
          nimg = new Uint8Array(nw * nh * 4);
          UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);
          blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;
          if (blend == 1)
            UPNG.encode._prepareDiff(cimg, w, h, nimg, {
              x: nx,
              y: ny,
              width: nw,
              height: nh
            });
          else
            UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);
        } else
          nimg = cimg.slice(0);
        frms.push({
          rect: {
            x: nx,
            y: ny,
            width: nw,
            height: nh
          },
          img: nimg,
          blend,
          dispose: 0
        });
      }
      if (alwaysBlend)
        for (var j = 0; j < frms.length; j++) {
          var frm = frms[j];
          if (frm.blend == 1)
            continue;
          var r0 = frm.rect, r1 = frms[j - 1].rect;
          var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);
          var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);
          var r = {
            x: miX,
            y: miY,
            width: maX - miX,
            height: maY - miY
          };
          frms[j - 1].dispose = 1;
          if (j - 1 != 0)
            UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);
          UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);
        }
      var area = 0;
      if (bufs.length != 1)
        for (var i = 0; i < frms.length; i++) {
          var frm = frms[i];
          area += frm.rect.width * frm.rect.height;
        }
      return frms;
    };
    UPNG.encode._updateFrame = function(bufs, w, h, frms, i, r, evenCrd) {
      var U8 = Uint8Array, U32 = Uint32Array;
      var pimg = new U8(bufs[i - 1]), pimg32 = new U32(bufs[i - 1]), nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;
      var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);
      var mix = w, miy = h, max2 = -1, may = -1;
      for (var y = 0; y < r.height; y++)
        for (var x = 0; x < r.width; x++) {
          var cx = r.x + x, cy = r.y + y;
          var j = cy * w + cx, cc = cimg32[j];
          if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)) {
          } else {
            if (cx < mix)
              mix = cx;
            if (cx > max2)
              max2 = cx;
            if (cy < miy)
              miy = cy;
            if (cy > may)
              may = cy;
          }
        }
      if (max2 == -1)
        mix = miy = max2 = may = 0;
      if (evenCrd) {
        if ((mix & 1) == 1)
          mix--;
        if ((miy & 1) == 1)
          miy--;
      }
      r = {
        x: mix,
        y: miy,
        width: max2 - mix + 1,
        height: may - miy + 1
      };
      var fr = frms[i];
      fr.rect = r;
      fr.blend = 1;
      fr.img = new Uint8Array(r.width * r.height * 4);
      if (frms[i - 1].dispose == 0) {
        UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
        UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);
      } else
        UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
    };
    UPNG.encode._prepareDiff = function(cimg, w, h, nimg, rec) {
      UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);
    };
    UPNG.encode._filterZero = function(img, h, bpp, bpl, data, filter, levelZero) {
      var fls = [], ftry = [0, 1, 2, 3, 4];
      if (filter != -1)
        ftry = [filter];
      else if (h * bpl > 5e5 || bpp == 1)
        ftry = [0];
      var opts;
      if (levelZero)
        opts = {
          level: 0
        };
      var CMPR = levelZero && UZIP != null ? UZIP : _pako.default;
      for (var i = 0; i < ftry.length; i++) {
        for (var y = 0; y < h; y++)
          UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);
        fls.push(CMPR["deflate"](data, opts));
      }
      var ti, tsize = 1e9;
      for (var i = 0; i < fls.length; i++)
        if (fls[i].length < tsize) {
          ti = i;
          tsize = fls[i].length;
        }
      return fls[ti];
    };
    UPNG.encode._filterLine = function(data, img, y, bpl, bpp, type) {
      var i = y * bpl, di = i + y, paeth = UPNG.decode._paeth;
      data[di] = type;
      di++;
      if (type == 0) {
        if (bpl < 500)
          for (var x = 0; x < bpl; x++)
            data[di + x] = img[i + x];
        else
          data.set(new Uint8Array(img.buffer, i, bpl), di);
      } else if (type == 1) {
        for (var x = 0; x < bpp; x++)
          data[di + x] = img[i + x];
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;
      } else if (y == 0) {
        for (var x = 0; x < bpp; x++)
          data[di + x] = img[i + x];
        if (type == 2)
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x];
        if (type == 3)
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;
        if (type == 4)
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;
      } else {
        if (type == 2) {
          for (var x = 0; x < bpl; x++)
            data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;
        }
        if (type == 3) {
          for (var x = 0; x < bpp; x++)
            data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;
        }
        if (type == 4) {
          for (var x = 0; x < bpp; x++)
            data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;
        }
      }
    };
    UPNG.crc = {
      table: function() {
        var tab = new Uint32Array(256);
        for (var n = 0; n < 256; n++) {
          var c = n;
          for (var k = 0; k < 8; k++) {
            if (c & 1)
              c = 3988292384 ^ c >>> 1;
            else
              c = c >>> 1;
          }
          tab[n] = c;
        }
        return tab;
      }(),
      update: function(c, buf, off, len) {
        for (var i = 0; i < len; i++)
          c = UPNG.crc.table[(c ^ buf[off + i]) & 255] ^ c >>> 8;
        return c;
      },
      crc: function(b, o, l) {
        return UPNG.crc.update(4294967295, b, o, l) ^ 4294967295;
      }
    };
    UPNG.quantize = function(abuf, ps) {
      var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);
      var KD = UPNG.quantize.getKDtree(nimg, ps);
      var root = KD[0], leafs = KD[1];
      var planeDst = UPNG.quantize.planeDst;
      var sb = oimg, tb = nimg32, len = sb.length;
      var inds = new Uint8Array(oimg.length >> 2);
      for (var i = 0; i < len; i += 4) {
        var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);
        var nd = UPNG.quantize.getNearest(root, r, g, b, a);
        inds[i >> 2] = nd.ind;
        tb[i >> 2] = nd.est.rgba;
      }
      return {
        abuf: nimg.buffer,
        inds,
        plte: leafs
      };
    };
    UPNG.quantize.getKDtree = function(nimg, ps, err) {
      if (err == null)
        err = 1e-4;
      var nimg32 = new Uint32Array(nimg.buffer);
      var root = {
        i0: 0,
        i1: nimg.length,
        bst: null,
        est: null,
        tdst: 0,
        left: null,
        right: null
      };
      root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);
      root.est = UPNG.quantize.estats(root.bst);
      var leafs = [root];
      while (leafs.length < ps) {
        var maxL = 0, mi = 0;
        for (var i = 0; i < leafs.length; i++)
          if (leafs[i].est.L > maxL) {
            maxL = leafs[i].est.L;
            mi = i;
          }
        if (maxL < err)
          break;
        var node = leafs[mi];
        var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
        var s0wrong = node.i0 >= s0 || node.i1 <= s0;
        if (s0wrong) {
          node.est.L = 0;
          continue;
        }
        var ln = {
          i0: node.i0,
          i1: s0,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null
        };
        ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);
        ln.est = UPNG.quantize.estats(ln.bst);
        var rn = {
          i0: s0,
          i1: node.i1,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null
        };
        rn.bst = {
          R: [],
          m: [],
          N: node.bst.N - ln.bst.N
        };
        for (var i = 0; i < 16; i++)
          rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];
        for (var i = 0; i < 4; i++)
          rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];
        rn.est = UPNG.quantize.estats(rn.bst);
        node.left = ln;
        node.right = rn;
        leafs[mi] = ln;
        leafs.push(rn);
      }
      leafs.sort(function(a, b) {
        return b.bst.N - a.bst.N;
      });
      for (var i = 0; i < leafs.length; i++)
        leafs[i].ind = i;
      return [root, leafs];
    };
    UPNG.quantize.getNearest = function(nd, r, g, b, a) {
      if (nd.left == null) {
        nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a);
        return nd;
      }
      var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);
      var node0 = nd.left, node1 = nd.right;
      if (planeDst > 0) {
        node0 = nd.right;
        node1 = nd.left;
      }
      var ln = UPNG.quantize.getNearest(node0, r, g, b, a);
      if (ln.tdst <= planeDst * planeDst)
        return ln;
      var rn = UPNG.quantize.getNearest(node1, r, g, b, a);
      return rn.tdst < ln.tdst ? rn : ln;
    };
    UPNG.quantize.planeDst = function(est, r, g, b, a) {
      var e = est.e;
      return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;
    };
    UPNG.quantize.dist = function(q, r, g, b, a) {
      var d0 = r - q[0], d1 = g - q[1], d2 = b - q[2], d3 = a - q[3];
      return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
    };
    UPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {
      var vecDot = UPNG.quantize.vecDot;
      i1 -= 4;
      var shfs = 0;
      while (i0 < i1) {
        while (vecDot(nimg, i0, e) <= eMq)
          i0 += 4;
        while (vecDot(nimg, i1, e) > eMq)
          i1 -= 4;
        if (i0 >= i1)
          break;
        var t = nimg32[i0 >> 2];
        nimg32[i0 >> 2] = nimg32[i1 >> 2];
        nimg32[i1 >> 2] = t;
        i0 += 4;
        i1 -= 4;
      }
      while (vecDot(nimg, i0, e) > eMq)
        i0 -= 4;
      return i0 + 4;
    };
    UPNG.quantize.vecDot = function(nimg, i, e) {
      return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];
    };
    UPNG.quantize.stats = function(nimg, i0, i1) {
      var R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var m = [0, 0, 0, 0];
      var N = i1 - i0 >> 2;
      for (var i = i0; i < i1; i += 4) {
        var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);
        m[0] += r;
        m[1] += g;
        m[2] += b;
        m[3] += a;
        R[0] += r * r;
        R[1] += r * g;
        R[2] += r * b;
        R[3] += r * a;
        R[5] += g * g;
        R[6] += g * b;
        R[7] += g * a;
        R[10] += b * b;
        R[11] += b * a;
        R[15] += a * a;
      }
      R[4] = R[1];
      R[8] = R[2];
      R[9] = R[6];
      R[12] = R[3];
      R[13] = R[7];
      R[14] = R[11];
      return {
        R,
        m,
        N
      };
    };
    UPNG.quantize.estats = function(stats) {
      var R = stats.R, m = stats.m, N = stats.N;
      var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N == 0 ? 0 : 1 / N;
      var Rj = [R[0] - m0 * m0 * iN, R[1] - m0 * m1 * iN, R[2] - m0 * m2 * iN, R[3] - m0 * m3 * iN, R[4] - m1 * m0 * iN, R[5] - m1 * m1 * iN, R[6] - m1 * m2 * iN, R[7] - m1 * m3 * iN, R[8] - m2 * m0 * iN, R[9] - m2 * m1 * iN, R[10] - m2 * m2 * iN, R[11] - m2 * m3 * iN, R[12] - m3 * m0 * iN, R[13] - m3 * m1 * iN, R[14] - m3 * m2 * iN, R[15] - m3 * m3 * iN];
      var A = Rj, M = UPNG.M4;
      var b = [0.5, 0.5, 0.5, 0.5], mi = 0, tmi = 0;
      if (N != 0)
        for (var i = 0; i < 10; i++) {
          b = M.multVec(A, b);
          tmi = Math.sqrt(M.dot(b, b));
          b = M.sml(1 / tmi, b);
          if (Math.abs(tmi - mi) < 1e-9)
            break;
          mi = tmi;
        }
      var q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];
      var eMq255 = M.dot(M.sml(255, q), b);
      return {
        Cov: Rj,
        q,
        e: b,
        L: mi,
        eMq255,
        eMq: M.dot(b, q),
        rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0
      };
    };
    UPNG.M4 = {
      multVec: function(m, v) {
        return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3], m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3], m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3], m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]];
      },
      dot: function(x, y) {
        return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
      },
      sml: function(a, y) {
        return [a * y[0], a * y[1], a * y[2], a * y[3]];
      }
    };
    UPNG.encode.concatRGBA = function(bufs) {
      var tlen = 0;
      for (var i = 0; i < bufs.length; i++)
        tlen += bufs[i].byteLength;
      var nimg = new Uint8Array(tlen), noff = 0;
      for (var i = 0; i < bufs.length; i++) {
        var img = new Uint8Array(bufs[i]), il = img.length;
        for (var j = 0; j < il; j += 4) {
          var r = img[j], g = img[j + 1], b = img[j + 2], a = img[j + 3];
          if (a == 0)
            r = g = b = 0;
          nimg[noff + j] = r;
          nimg[noff + j + 1] = g;
          nimg[noff + j + 2] = b;
          nimg[noff + j + 3] = a;
        }
        noff += il;
      }
      return nimg.buffer;
    };
    var _default = UPNG;
    exports.default = _default;
  }
});

// node_modules/pdf-lib/cjs/utils/png.js
var require_png = __commonJS({
  "node_modules/pdf-lib/cjs/utils/png.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PNG = exports.PngType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var upng_1 = tslib_1.__importDefault(require_UPNG());
    var getImageType = function(ctype) {
      if (ctype === 0)
        return PngType.Greyscale;
      if (ctype === 2)
        return PngType.Truecolour;
      if (ctype === 3)
        return PngType.IndexedColour;
      if (ctype === 4)
        return PngType.GreyscaleWithAlpha;
      if (ctype === 6)
        return PngType.TruecolourWithAlpha;
      throw new Error("Unknown color type: " + ctype);
    };
    var splitAlphaChannel = function(rgbaChannel) {
      var pixelCount = Math.floor(rgbaChannel.length / 4);
      var rgbChannel = new Uint8Array(pixelCount * 3);
      var alphaChannel = new Uint8Array(pixelCount * 1);
      var rgbaOffset = 0;
      var rgbOffset = 0;
      var alphaOffset = 0;
      while (rgbaOffset < rgbaChannel.length) {
        rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
        rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
        rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
        alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];
      }
      return { rgbChannel, alphaChannel };
    };
    var PngType;
    (function(PngType2) {
      PngType2["Greyscale"] = "Greyscale";
      PngType2["Truecolour"] = "Truecolour";
      PngType2["IndexedColour"] = "IndexedColour";
      PngType2["GreyscaleWithAlpha"] = "GreyscaleWithAlpha";
      PngType2["TruecolourWithAlpha"] = "TruecolourWithAlpha";
    })(PngType = exports.PngType || (exports.PngType = {}));
    var PNG = (
      /** @class */
      function() {
        function PNG2(pngData) {
          var upng = upng_1.default.decode(pngData);
          var frames = upng_1.default.toRGBA8(upng);
          if (frames.length > 1)
            throw new Error("Animated PNGs are not supported");
          var frame = new Uint8Array(frames[0]);
          var _a = splitAlphaChannel(frame), rgbChannel = _a.rgbChannel, alphaChannel = _a.alphaChannel;
          this.rgbChannel = rgbChannel;
          var hasAlphaValues = alphaChannel.some(function(a) {
            return a < 255;
          });
          if (hasAlphaValues)
            this.alphaChannel = alphaChannel;
          this.type = getImageType(upng.ctype);
          this.width = upng.width;
          this.height = upng.height;
          this.bitsPerComponent = 8;
        }
        PNG2.load = function(pngData) {
          return new PNG2(pngData);
        };
        return PNG2;
      }()
    );
    exports.PNG = PNG;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/PngEmbedder.js
var require_PngEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/PngEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var png_1 = require_png();
    var PngEmbedder = (
      /** @class */
      function() {
        function PngEmbedder2(png) {
          this.image = png;
          this.bitsPerComponent = png.bitsPerComponent;
          this.width = png.width;
          this.height = png.height;
          this.colorSpace = "DeviceRGB";
        }
        PngEmbedder2.for = function(imageData) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var png;
            return tslib_1.__generator(this, function(_a) {
              png = png_1.PNG.load(imageData);
              return [2, new PngEmbedder2(png)];
            });
          });
        };
        PngEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var SMask, xObject;
            return tslib_1.__generator(this, function(_a) {
              SMask = this.embedAlphaChannel(context);
              xObject = context.flateStream(this.image.rgbChannel, {
                Type: "XObject",
                Subtype: "Image",
                BitsPerComponent: this.image.bitsPerComponent,
                Width: this.image.width,
                Height: this.image.height,
                ColorSpace: this.colorSpace,
                SMask
              });
              if (ref) {
                context.assign(ref, xObject);
                return [2, ref];
              } else {
                return [2, context.register(xObject)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        PngEmbedder2.prototype.embedAlphaChannel = function(context) {
          if (!this.image.alphaChannel)
            return void 0;
          var xObject = context.flateStream(this.image.alphaChannel, {
            Type: "XObject",
            Subtype: "Image",
            Height: this.image.height,
            Width: this.image.width,
            BitsPerComponent: this.image.bitsPerComponent,
            ColorSpace: "DeviceGray",
            Decode: [0, 1]
          });
          return context.register(xObject);
        };
        return PngEmbedder2;
      }()
    );
    exports.default = PngEmbedder;
  }
});

// node_modules/pdf-lib/cjs/core/streams/Stream.js
var require_Stream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/Stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Stream = (
      /** @class */
      function() {
        function Stream2(buffer, start2, length) {
          this.bytes = buffer;
          this.start = start2 || 0;
          this.pos = this.start;
          this.end = !!start2 && !!length ? start2 + length : this.bytes.length;
        }
        Object.defineProperty(Stream2.prototype, "length", {
          get: function() {
            return this.end - this.start;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Stream2.prototype, "isEmpty", {
          get: function() {
            return this.length === 0;
          },
          enumerable: false,
          configurable: true
        });
        Stream2.prototype.getByte = function() {
          if (this.pos >= this.end) {
            return -1;
          }
          return this.bytes[this.pos++];
        };
        Stream2.prototype.getUint16 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          if (b0 === -1 || b1 === -1) {
            return -1;
          }
          return (b0 << 8) + b1;
        };
        Stream2.prototype.getInt32 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          var b2 = this.getByte();
          var b3 = this.getByte();
          return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
        };
        Stream2.prototype.getBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var bytes = this.bytes;
          var pos = this.pos;
          var strEnd = this.end;
          if (!length) {
            var subarray = bytes.subarray(pos, strEnd);
            return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
          } else {
            var end2 = pos + length;
            if (end2 > strEnd) {
              end2 = strEnd;
            }
            this.pos = end2;
            var subarray = bytes.subarray(pos, end2);
            return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
          }
        };
        Stream2.prototype.peekByte = function() {
          var peekedByte = this.getByte();
          this.pos--;
          return peekedByte;
        };
        Stream2.prototype.peekBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var bytes = this.getBytes(length, forceClamped);
          this.pos -= bytes.length;
          return bytes;
        };
        Stream2.prototype.skip = function(n) {
          if (!n) {
            n = 1;
          }
          this.pos += n;
        };
        Stream2.prototype.reset = function() {
          this.pos = this.start;
        };
        Stream2.prototype.moveStart = function() {
          this.start = this.pos;
        };
        Stream2.prototype.makeSubStream = function(start2, length) {
          return new Stream2(this.bytes, start2, length);
        };
        Stream2.prototype.decode = function() {
          return this.bytes;
        };
        return Stream2;
      }()
    );
    exports.default = Stream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/DecodeStream.js
var require_DecodeStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/DecodeStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var Stream_1 = tslib_1.__importDefault(require_Stream());
    var emptyBuffer = new Uint8Array(0);
    var DecodeStream = (
      /** @class */
      function() {
        function DecodeStream2(maybeMinBufferLength) {
          this.pos = 0;
          this.bufferLength = 0;
          this.eof = false;
          this.buffer = emptyBuffer;
          this.minBufferLength = 512;
          if (maybeMinBufferLength) {
            while (this.minBufferLength < maybeMinBufferLength) {
              this.minBufferLength *= 2;
            }
          }
        }
        Object.defineProperty(DecodeStream2.prototype, "isEmpty", {
          get: function() {
            while (!this.eof && this.bufferLength === 0) {
              this.readBlock();
            }
            return this.bufferLength === 0;
          },
          enumerable: false,
          configurable: true
        });
        DecodeStream2.prototype.getByte = function() {
          var pos = this.pos;
          while (this.bufferLength <= pos) {
            if (this.eof) {
              return -1;
            }
            this.readBlock();
          }
          return this.buffer[this.pos++];
        };
        DecodeStream2.prototype.getUint16 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          if (b0 === -1 || b1 === -1) {
            return -1;
          }
          return (b0 << 8) + b1;
        };
        DecodeStream2.prototype.getInt32 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          var b2 = this.getByte();
          var b3 = this.getByte();
          return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
        };
        DecodeStream2.prototype.getBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var end2;
          var pos = this.pos;
          if (length) {
            this.ensureBuffer(pos + length);
            end2 = pos + length;
            while (!this.eof && this.bufferLength < end2) {
              this.readBlock();
            }
            var bufEnd = this.bufferLength;
            if (end2 > bufEnd) {
              end2 = bufEnd;
            }
          } else {
            while (!this.eof) {
              this.readBlock();
            }
            end2 = this.bufferLength;
          }
          this.pos = end2;
          var subarray = this.buffer.subarray(pos, end2);
          return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
        };
        DecodeStream2.prototype.peekByte = function() {
          var peekedByte = this.getByte();
          this.pos--;
          return peekedByte;
        };
        DecodeStream2.prototype.peekBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var bytes = this.getBytes(length, forceClamped);
          this.pos -= bytes.length;
          return bytes;
        };
        DecodeStream2.prototype.skip = function(n) {
          if (!n) {
            n = 1;
          }
          this.pos += n;
        };
        DecodeStream2.prototype.reset = function() {
          this.pos = 0;
        };
        DecodeStream2.prototype.makeSubStream = function(start2, length) {
          var end2 = start2 + length;
          while (this.bufferLength <= end2 && !this.eof) {
            this.readBlock();
          }
          return new Stream_1.default(
            this.buffer,
            start2,
            length
            /* dict */
          );
        };
        DecodeStream2.prototype.decode = function() {
          while (!this.eof)
            this.readBlock();
          return this.buffer.subarray(0, this.bufferLength);
        };
        DecodeStream2.prototype.readBlock = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "readBlock");
        };
        DecodeStream2.prototype.ensureBuffer = function(requested) {
          var buffer = this.buffer;
          if (requested <= buffer.byteLength) {
            return buffer;
          }
          var size = this.minBufferLength;
          while (size < requested) {
            size *= 2;
          }
          var buffer2 = new Uint8Array(size);
          buffer2.set(buffer);
          return this.buffer = buffer2;
        };
        return DecodeStream2;
      }()
    );
    exports.default = DecodeStream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/Ascii85Stream.js
var require_Ascii85Stream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/Ascii85Stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var isSpace = function(ch) {
      return ch === 32 || ch === 9 || ch === 13 || ch === 10;
    };
    var Ascii85Stream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(Ascii85Stream2, _super);
        function Ascii85Stream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          _this.input = new Uint8Array(5);
          if (maybeLength) {
            maybeLength = 0.8 * maybeLength;
          }
          return _this;
        }
        Ascii85Stream2.prototype.readBlock = function() {
          var TILDA_CHAR = 126;
          var Z_LOWER_CHAR = 122;
          var EOF = -1;
          var stream = this.stream;
          var c = stream.getByte();
          while (isSpace(c)) {
            c = stream.getByte();
          }
          if (c === EOF || c === TILDA_CHAR) {
            this.eof = true;
            return;
          }
          var bufferLength = this.bufferLength;
          var buffer;
          var i;
          if (c === Z_LOWER_CHAR) {
            buffer = this.ensureBuffer(bufferLength + 4);
            for (i = 0; i < 4; ++i) {
              buffer[bufferLength + i] = 0;
            }
            this.bufferLength += 4;
          } else {
            var input = this.input;
            input[0] = c;
            for (i = 1; i < 5; ++i) {
              c = stream.getByte();
              while (isSpace(c)) {
                c = stream.getByte();
              }
              input[i] = c;
              if (c === EOF || c === TILDA_CHAR) {
                break;
              }
            }
            buffer = this.ensureBuffer(bufferLength + i - 1);
            this.bufferLength += i - 1;
            if (i < 5) {
              for (; i < 5; ++i) {
                input[i] = 33 + 84;
              }
              this.eof = true;
            }
            var t = 0;
            for (i = 0; i < 5; ++i) {
              t = t * 85 + (input[i] - 33);
            }
            for (i = 3; i >= 0; --i) {
              buffer[bufferLength + i] = t & 255;
              t >>= 8;
            }
          }
        };
        return Ascii85Stream2;
      }(DecodeStream_1.default)
    );
    exports.default = Ascii85Stream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/AsciiHexStream.js
var require_AsciiHexStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/AsciiHexStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var AsciiHexStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(AsciiHexStream2, _super);
        function AsciiHexStream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          _this.firstDigit = -1;
          if (maybeLength) {
            maybeLength = 0.5 * maybeLength;
          }
          return _this;
        }
        AsciiHexStream2.prototype.readBlock = function() {
          var UPSTREAM_BLOCK_SIZE = 8e3;
          var bytes = this.stream.getBytes(UPSTREAM_BLOCK_SIZE);
          if (!bytes.length) {
            this.eof = true;
            return;
          }
          var maxDecodeLength = bytes.length + 1 >> 1;
          var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
          var bufferLength = this.bufferLength;
          var firstDigit = this.firstDigit;
          for (var i = 0, ii = bytes.length; i < ii; i++) {
            var ch = bytes[i];
            var digit = void 0;
            if (ch >= 48 && ch <= 57) {
              digit = ch & 15;
            } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
              digit = (ch & 15) + 9;
            } else if (ch === 62) {
              this.eof = true;
              break;
            } else {
              continue;
            }
            if (firstDigit < 0) {
              firstDigit = digit;
            } else {
              buffer[bufferLength++] = firstDigit << 4 | digit;
              firstDigit = -1;
            }
          }
          if (firstDigit >= 0 && this.eof) {
            buffer[bufferLength++] = firstDigit << 4;
            firstDigit = -1;
          }
          this.firstDigit = firstDigit;
          this.bufferLength = bufferLength;
        };
        return AsciiHexStream2;
      }(DecodeStream_1.default)
    );
    exports.default = AsciiHexStream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/FlateStream.js
var require_FlateStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/FlateStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var codeLenCodeMap = new Int32Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var lengthDecode = new Int32Array([
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      65547,
      65549,
      65551,
      65553,
      131091,
      131095,
      131099,
      131103,
      196643,
      196651,
      196659,
      196667,
      262211,
      262227,
      262243,
      262259,
      327811,
      327843,
      327875,
      327907,
      258,
      258,
      258
    ]);
    var distDecode = new Int32Array([
      1,
      2,
      3,
      4,
      65541,
      65543,
      131081,
      131085,
      196625,
      196633,
      262177,
      262193,
      327745,
      327777,
      393345,
      393409,
      459009,
      459137,
      524801,
      525057,
      590849,
      591361,
      657409,
      658433,
      724993,
      727041,
      794625,
      798721,
      868353,
      876545
    ]);
    var fixedLitCodeTab = [new Int32Array([
      459008,
      524368,
      524304,
      524568,
      459024,
      524400,
      524336,
      590016,
      459016,
      524384,
      524320,
      589984,
      524288,
      524416,
      524352,
      590048,
      459012,
      524376,
      524312,
      589968,
      459028,
      524408,
      524344,
      590032,
      459020,
      524392,
      524328,
      59e4,
      524296,
      524424,
      524360,
      590064,
      459010,
      524372,
      524308,
      524572,
      459026,
      524404,
      524340,
      590024,
      459018,
      524388,
      524324,
      589992,
      524292,
      524420,
      524356,
      590056,
      459014,
      524380,
      524316,
      589976,
      459030,
      524412,
      524348,
      590040,
      459022,
      524396,
      524332,
      590008,
      524300,
      524428,
      524364,
      590072,
      459009,
      524370,
      524306,
      524570,
      459025,
      524402,
      524338,
      590020,
      459017,
      524386,
      524322,
      589988,
      524290,
      524418,
      524354,
      590052,
      459013,
      524378,
      524314,
      589972,
      459029,
      524410,
      524346,
      590036,
      459021,
      524394,
      524330,
      590004,
      524298,
      524426,
      524362,
      590068,
      459011,
      524374,
      524310,
      524574,
      459027,
      524406,
      524342,
      590028,
      459019,
      524390,
      524326,
      589996,
      524294,
      524422,
      524358,
      590060,
      459015,
      524382,
      524318,
      589980,
      459031,
      524414,
      524350,
      590044,
      459023,
      524398,
      524334,
      590012,
      524302,
      524430,
      524366,
      590076,
      459008,
      524369,
      524305,
      524569,
      459024,
      524401,
      524337,
      590018,
      459016,
      524385,
      524321,
      589986,
      524289,
      524417,
      524353,
      590050,
      459012,
      524377,
      524313,
      589970,
      459028,
      524409,
      524345,
      590034,
      459020,
      524393,
      524329,
      590002,
      524297,
      524425,
      524361,
      590066,
      459010,
      524373,
      524309,
      524573,
      459026,
      524405,
      524341,
      590026,
      459018,
      524389,
      524325,
      589994,
      524293,
      524421,
      524357,
      590058,
      459014,
      524381,
      524317,
      589978,
      459030,
      524413,
      524349,
      590042,
      459022,
      524397,
      524333,
      590010,
      524301,
      524429,
      524365,
      590074,
      459009,
      524371,
      524307,
      524571,
      459025,
      524403,
      524339,
      590022,
      459017,
      524387,
      524323,
      589990,
      524291,
      524419,
      524355,
      590054,
      459013,
      524379,
      524315,
      589974,
      459029,
      524411,
      524347,
      590038,
      459021,
      524395,
      524331,
      590006,
      524299,
      524427,
      524363,
      590070,
      459011,
      524375,
      524311,
      524575,
      459027,
      524407,
      524343,
      590030,
      459019,
      524391,
      524327,
      589998,
      524295,
      524423,
      524359,
      590062,
      459015,
      524383,
      524319,
      589982,
      459031,
      524415,
      524351,
      590046,
      459023,
      524399,
      524335,
      590014,
      524303,
      524431,
      524367,
      590078,
      459008,
      524368,
      524304,
      524568,
      459024,
      524400,
      524336,
      590017,
      459016,
      524384,
      524320,
      589985,
      524288,
      524416,
      524352,
      590049,
      459012,
      524376,
      524312,
      589969,
      459028,
      524408,
      524344,
      590033,
      459020,
      524392,
      524328,
      590001,
      524296,
      524424,
      524360,
      590065,
      459010,
      524372,
      524308,
      524572,
      459026,
      524404,
      524340,
      590025,
      459018,
      524388,
      524324,
      589993,
      524292,
      524420,
      524356,
      590057,
      459014,
      524380,
      524316,
      589977,
      459030,
      524412,
      524348,
      590041,
      459022,
      524396,
      524332,
      590009,
      524300,
      524428,
      524364,
      590073,
      459009,
      524370,
      524306,
      524570,
      459025,
      524402,
      524338,
      590021,
      459017,
      524386,
      524322,
      589989,
      524290,
      524418,
      524354,
      590053,
      459013,
      524378,
      524314,
      589973,
      459029,
      524410,
      524346,
      590037,
      459021,
      524394,
      524330,
      590005,
      524298,
      524426,
      524362,
      590069,
      459011,
      524374,
      524310,
      524574,
      459027,
      524406,
      524342,
      590029,
      459019,
      524390,
      524326,
      589997,
      524294,
      524422,
      524358,
      590061,
      459015,
      524382,
      524318,
      589981,
      459031,
      524414,
      524350,
      590045,
      459023,
      524398,
      524334,
      590013,
      524302,
      524430,
      524366,
      590077,
      459008,
      524369,
      524305,
      524569,
      459024,
      524401,
      524337,
      590019,
      459016,
      524385,
      524321,
      589987,
      524289,
      524417,
      524353,
      590051,
      459012,
      524377,
      524313,
      589971,
      459028,
      524409,
      524345,
      590035,
      459020,
      524393,
      524329,
      590003,
      524297,
      524425,
      524361,
      590067,
      459010,
      524373,
      524309,
      524573,
      459026,
      524405,
      524341,
      590027,
      459018,
      524389,
      524325,
      589995,
      524293,
      524421,
      524357,
      590059,
      459014,
      524381,
      524317,
      589979,
      459030,
      524413,
      524349,
      590043,
      459022,
      524397,
      524333,
      590011,
      524301,
      524429,
      524365,
      590075,
      459009,
      524371,
      524307,
      524571,
      459025,
      524403,
      524339,
      590023,
      459017,
      524387,
      524323,
      589991,
      524291,
      524419,
      524355,
      590055,
      459013,
      524379,
      524315,
      589975,
      459029,
      524411,
      524347,
      590039,
      459021,
      524395,
      524331,
      590007,
      524299,
      524427,
      524363,
      590071,
      459011,
      524375,
      524311,
      524575,
      459027,
      524407,
      524343,
      590031,
      459019,
      524391,
      524327,
      589999,
      524295,
      524423,
      524359,
      590063,
      459015,
      524383,
      524319,
      589983,
      459031,
      524415,
      524351,
      590047,
      459023,
      524399,
      524335,
      590015,
      524303,
      524431,
      524367,
      590079
    ]), 9];
    var fixedDistCodeTab = [new Int32Array([
      327680,
      327696,
      327688,
      327704,
      327684,
      327700,
      327692,
      327708,
      327682,
      327698,
      327690,
      327706,
      327686,
      327702,
      327694,
      0,
      327681,
      327697,
      327689,
      327705,
      327685,
      327701,
      327693,
      327709,
      327683,
      327699,
      327691,
      327707,
      327687,
      327703,
      327695,
      0
    ]), 5];
    var FlateStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FlateStream2, _super);
        function FlateStream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          var cmf = stream.getByte();
          var flg = stream.getByte();
          if (cmf === -1 || flg === -1) {
            throw new Error("Invalid header in flate stream: " + cmf + ", " + flg);
          }
          if ((cmf & 15) !== 8) {
            throw new Error("Unknown compression method in flate stream: " + cmf + ", " + flg);
          }
          if (((cmf << 8) + flg) % 31 !== 0) {
            throw new Error("Bad FCHECK in flate stream: " + cmf + ", " + flg);
          }
          if (flg & 32) {
            throw new Error("FDICT bit set in flate stream: " + cmf + ", " + flg);
          }
          _this.codeSize = 0;
          _this.codeBuf = 0;
          return _this;
        }
        FlateStream2.prototype.readBlock = function() {
          var buffer;
          var len;
          var str = this.stream;
          var hdr = this.getBits(3);
          if (hdr & 1) {
            this.eof = true;
          }
          hdr >>= 1;
          if (hdr === 0) {
            var b = void 0;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            var blockLen = b;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            blockLen |= b << 8;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            var check = b;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            check |= b << 8;
            if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
              throw new Error("Bad uncompressed block length in flate stream");
            }
            this.codeBuf = 0;
            this.codeSize = 0;
            var bufferLength = this.bufferLength;
            buffer = this.ensureBuffer(bufferLength + blockLen);
            var end2 = bufferLength + blockLen;
            this.bufferLength = end2;
            if (blockLen === 0) {
              if (str.peekByte() === -1) {
                this.eof = true;
              }
            } else {
              for (var n = bufferLength; n < end2; ++n) {
                if ((b = str.getByte()) === -1) {
                  this.eof = true;
                  break;
                }
                buffer[n] = b;
              }
            }
            return;
          }
          var litCodeTable;
          var distCodeTable;
          if (hdr === 1) {
            litCodeTable = fixedLitCodeTab;
            distCodeTable = fixedDistCodeTab;
          } else if (hdr === 2) {
            var numLitCodes = this.getBits(5) + 257;
            var numDistCodes = this.getBits(5) + 1;
            var numCodeLenCodes = this.getBits(4) + 4;
            var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
            var i = void 0;
            for (i = 0; i < numCodeLenCodes; ++i) {
              codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
            }
            var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            len = 0;
            i = 0;
            var codes = numLitCodes + numDistCodes;
            var codeLengths = new Uint8Array(codes);
            var bitsLength = void 0;
            var bitsOffset = void 0;
            var what = void 0;
            while (i < codes) {
              var code = this.getCode(codeLenCodeTab);
              if (code === 16) {
                bitsLength = 2;
                bitsOffset = 3;
                what = len;
              } else if (code === 17) {
                bitsLength = 3;
                bitsOffset = 3;
                what = len = 0;
              } else if (code === 18) {
                bitsLength = 7;
                bitsOffset = 11;
                what = len = 0;
              } else {
                codeLengths[i++] = len = code;
                continue;
              }
              var repeatLength = this.getBits(bitsLength) + bitsOffset;
              while (repeatLength-- > 0) {
                codeLengths[i++] = what;
              }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
          } else {
            throw new Error("Unknown block type in flate stream");
          }
          buffer = this.buffer;
          var limit = buffer ? buffer.length : 0;
          var pos = this.bufferLength;
          while (true) {
            var code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
              if (pos + 1 >= limit) {
                buffer = this.ensureBuffer(pos + 1);
                limit = buffer.length;
              }
              buffer[pos++] = code1;
              continue;
            }
            if (code1 === 256) {
              this.bufferLength = pos;
              return;
            }
            code1 -= 257;
            code1 = lengthDecode[code1];
            var code2 = code1 >> 16;
            if (code2 > 0) {
              code2 = this.getBits(code2);
            }
            len = (code1 & 65535) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = distDecode[code1];
            code2 = code1 >> 16;
            if (code2 > 0) {
              code2 = this.getBits(code2);
            }
            var dist = (code1 & 65535) + code2;
            if (pos + len >= limit) {
              buffer = this.ensureBuffer(pos + len);
              limit = buffer.length;
            }
            for (var k = 0; k < len; ++k, ++pos) {
              buffer[pos] = buffer[pos - dist];
            }
          }
        };
        FlateStream2.prototype.getBits = function(bits) {
          var str = this.stream;
          var codeSize = this.codeSize;
          var codeBuf = this.codeBuf;
          var b;
          while (codeSize < bits) {
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad encoding in flate stream");
            }
            codeBuf |= b << codeSize;
            codeSize += 8;
          }
          b = codeBuf & (1 << bits) - 1;
          this.codeBuf = codeBuf >> bits;
          this.codeSize = codeSize -= bits;
          return b;
        };
        FlateStream2.prototype.getCode = function(table) {
          var str = this.stream;
          var codes = table[0];
          var maxLen = table[1];
          var codeSize = this.codeSize;
          var codeBuf = this.codeBuf;
          var b;
          while (codeSize < maxLen) {
            if ((b = str.getByte()) === -1) {
              break;
            }
            codeBuf |= b << codeSize;
            codeSize += 8;
          }
          var code = codes[codeBuf & (1 << maxLen) - 1];
          if (typeof codes === "number") {
            console.log("FLATE:", code);
          }
          var codeLen = code >> 16;
          var codeVal = code & 65535;
          if (codeLen < 1 || codeSize < codeLen) {
            throw new Error("Bad encoding in flate stream");
          }
          this.codeBuf = codeBuf >> codeLen;
          this.codeSize = codeSize - codeLen;
          return codeVal;
        };
        FlateStream2.prototype.generateHuffmanTable = function(lengths) {
          var n = lengths.length;
          var maxLen = 0;
          var i;
          for (i = 0; i < n; ++i) {
            if (lengths[i] > maxLen) {
              maxLen = lengths[i];
            }
          }
          var size = 1 << maxLen;
          var codes = new Int32Array(size);
          for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
            for (var val = 0; val < n; ++val) {
              if (lengths[val] === len) {
                var code2 = 0;
                var t = code;
                for (i = 0; i < len; ++i) {
                  code2 = code2 << 1 | t & 1;
                  t >>= 1;
                }
                for (i = code2; i < size; i += skip) {
                  codes[i] = len << 16 | val;
                }
                ++code;
              }
            }
          }
          return [codes, maxLen];
        };
        return FlateStream2;
      }(DecodeStream_1.default)
    );
    exports.default = FlateStream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/LZWStream.js
var require_LZWStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/LZWStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var LZWStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(LZWStream2, _super);
        function LZWStream2(stream, maybeLength, earlyChange) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          _this.cachedData = 0;
          _this.bitsCached = 0;
          var maxLzwDictionarySize = 4096;
          var lzwState = {
            earlyChange,
            codeLength: 9,
            nextCode: 258,
            dictionaryValues: new Uint8Array(maxLzwDictionarySize),
            dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
            dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
            currentSequence: new Uint8Array(maxLzwDictionarySize),
            currentSequenceLength: 0
          };
          for (var i = 0; i < 256; ++i) {
            lzwState.dictionaryValues[i] = i;
            lzwState.dictionaryLengths[i] = 1;
          }
          _this.lzwState = lzwState;
          return _this;
        }
        LZWStream2.prototype.readBlock = function() {
          var blockSize = 512;
          var estimatedDecodedSize = blockSize * 2;
          var decodedSizeDelta = blockSize;
          var i;
          var j;
          var q;
          var lzwState = this.lzwState;
          if (!lzwState) {
            return;
          }
          var earlyChange = lzwState.earlyChange;
          var nextCode = lzwState.nextCode;
          var dictionaryValues = lzwState.dictionaryValues;
          var dictionaryLengths = lzwState.dictionaryLengths;
          var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
          var codeLength = lzwState.codeLength;
          var prevCode = lzwState.prevCode;
          var currentSequence = lzwState.currentSequence;
          var currentSequenceLength = lzwState.currentSequenceLength;
          var decodedLength = 0;
          var currentBufferLength = this.bufferLength;
          var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
          for (i = 0; i < blockSize; i++) {
            var code = this.readBits(codeLength);
            var hasPrev = currentSequenceLength > 0;
            if (!code || code < 256) {
              currentSequence[0] = code;
              currentSequenceLength = 1;
            } else if (code >= 258) {
              if (code < nextCode) {
                currentSequenceLength = dictionaryLengths[code];
                for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                  currentSequence[j] = dictionaryValues[q];
                  q = dictionaryPrevCodes[q];
                }
              } else {
                currentSequence[currentSequenceLength++] = currentSequence[0];
              }
            } else if (code === 256) {
              codeLength = 9;
              nextCode = 258;
              currentSequenceLength = 0;
              continue;
            } else {
              this.eof = true;
              delete this.lzwState;
              break;
            }
            if (hasPrev) {
              dictionaryPrevCodes[nextCode] = prevCode;
              dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
              dictionaryValues[nextCode] = currentSequence[0];
              nextCode++;
              codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
            }
            prevCode = code;
            decodedLength += currentSequenceLength;
            if (estimatedDecodedSize < decodedLength) {
              do {
                estimatedDecodedSize += decodedSizeDelta;
              } while (estimatedDecodedSize < decodedLength);
              buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
            }
            for (j = 0; j < currentSequenceLength; j++) {
              buffer[currentBufferLength++] = currentSequence[j];
            }
          }
          lzwState.nextCode = nextCode;
          lzwState.codeLength = codeLength;
          lzwState.prevCode = prevCode;
          lzwState.currentSequenceLength = currentSequenceLength;
          this.bufferLength = currentBufferLength;
        };
        LZWStream2.prototype.readBits = function(n) {
          var bitsCached = this.bitsCached;
          var cachedData = this.cachedData;
          while (bitsCached < n) {
            var c = this.stream.getByte();
            if (c === -1) {
              this.eof = true;
              return null;
            }
            cachedData = cachedData << 8 | c;
            bitsCached += 8;
          }
          this.bitsCached = bitsCached -= n;
          this.cachedData = cachedData;
          return cachedData >>> bitsCached & (1 << n) - 1;
        };
        return LZWStream2;
      }(DecodeStream_1.default)
    );
    exports.default = LZWStream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/RunLengthStream.js
var require_RunLengthStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/RunLengthStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var RunLengthStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(RunLengthStream2, _super);
        function RunLengthStream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          return _this;
        }
        RunLengthStream2.prototype.readBlock = function() {
          var repeatHeader = this.stream.getBytes(2);
          if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
            this.eof = true;
            return;
          }
          var buffer;
          var bufferLength = this.bufferLength;
          var n = repeatHeader[0];
          if (n < 128) {
            buffer = this.ensureBuffer(bufferLength + n + 1);
            buffer[bufferLength++] = repeatHeader[1];
            if (n > 0) {
              var source = this.stream.getBytes(n);
              buffer.set(source, bufferLength);
              bufferLength += n;
            }
          } else {
            n = 257 - n;
            var b = repeatHeader[1];
            buffer = this.ensureBuffer(bufferLength + n + 1);
            for (var i = 0; i < n; i++) {
              buffer[bufferLength++] = b;
            }
          }
          this.bufferLength = bufferLength;
        };
        return RunLengthStream2;
      }(DecodeStream_1.default)
    );
    exports.default = RunLengthStream;
  }
});

// node_modules/pdf-lib/cjs/core/streams/decode.js
var require_decode = __commonJS({
  "node_modules/pdf-lib/cjs/core/streams/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePDFRawStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var Ascii85Stream_1 = tslib_1.__importDefault(require_Ascii85Stream());
    var AsciiHexStream_1 = tslib_1.__importDefault(require_AsciiHexStream());
    var FlateStream_1 = tslib_1.__importDefault(require_FlateStream());
    var LZWStream_1 = tslib_1.__importDefault(require_LZWStream());
    var RunLengthStream_1 = tslib_1.__importDefault(require_RunLengthStream());
    var Stream_1 = tslib_1.__importDefault(require_Stream());
    var decodeStream = function(stream, encoding, params) {
      if (encoding === PDFName_1.default.of("FlateDecode")) {
        return new FlateStream_1.default(stream);
      }
      if (encoding === PDFName_1.default.of("LZWDecode")) {
        var earlyChange = 1;
        if (params instanceof PDFDict_1.default) {
          var EarlyChange = params.lookup(PDFName_1.default.of("EarlyChange"));
          if (EarlyChange instanceof PDFNumber_1.default) {
            earlyChange = EarlyChange.asNumber();
          }
        }
        return new LZWStream_1.default(stream, void 0, earlyChange);
      }
      if (encoding === PDFName_1.default.of("ASCII85Decode")) {
        return new Ascii85Stream_1.default(stream);
      }
      if (encoding === PDFName_1.default.of("ASCIIHexDecode")) {
        return new AsciiHexStream_1.default(stream);
      }
      if (encoding === PDFName_1.default.of("RunLengthDecode")) {
        return new RunLengthStream_1.default(stream);
      }
      throw new errors_1.UnsupportedEncodingError(encoding.asString());
    };
    exports.decodePDFRawStream = function(_a) {
      var dict = _a.dict, contents = _a.contents;
      var stream = new Stream_1.default(contents);
      var Filter = dict.lookup(PDFName_1.default.of("Filter"));
      var DecodeParms = dict.lookup(PDFName_1.default.of("DecodeParms"));
      if (Filter instanceof PDFName_1.default) {
        stream = decodeStream(stream, Filter, DecodeParms);
      } else if (Filter instanceof PDFArray_1.default) {
        for (var idx = 0, len = Filter.size(); idx < len; idx++) {
          stream = decodeStream(stream, Filter.lookup(idx, PDFName_1.default), DecodeParms && DecodeParms.lookupMaybe(idx, PDFDict_1.default));
        }
      } else if (!!Filter) {
        throw new errors_1.UnexpectedObjectTypeError([PDFName_1.default, PDFArray_1.default], Filter);
      }
      return stream;
    };
  }
});

// node_modules/pdf-lib/cjs/core/embedders/PDFPageEmbedder.js
var require_PDFPageEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/PDFPageEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var decode_1 = require_decode();
    var PDFContentStream_1 = tslib_1.__importDefault(require_PDFContentStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var fullPageBoundingBox = function(page) {
      var mediaBox = page.MediaBox();
      var width = mediaBox.lookup(2, PDFNumber_1.default).asNumber() - mediaBox.lookup(0, PDFNumber_1.default).asNumber();
      var height = mediaBox.lookup(3, PDFNumber_1.default).asNumber() - mediaBox.lookup(1, PDFNumber_1.default).asNumber();
      return { left: 0, bottom: 0, right: width, top: height };
    };
    var boundingBoxAdjustedMatrix = function(bb) {
      return [1, 0, 0, 1, -bb.left, -bb.bottom];
    };
    var PDFPageEmbedder = (
      /** @class */
      function() {
        function PDFPageEmbedder2(page, boundingBox, transformationMatrix) {
          this.page = page;
          var bb = boundingBox !== null && boundingBox !== void 0 ? boundingBox : fullPageBoundingBox(page);
          this.width = bb.right - bb.left;
          this.height = bb.top - bb.bottom;
          this.boundingBox = bb;
          this.transformationMatrix = transformationMatrix !== null && transformationMatrix !== void 0 ? transformationMatrix : boundingBoxAdjustedMatrix(bb);
        }
        PDFPageEmbedder2.for = function(page, boundingBox, transformationMatrix) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, new PDFPageEmbedder2(page, boundingBox, transformationMatrix)];
            });
          });
        };
        PDFPageEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, Contents, Resources, decodedContents, _b, left2, bottom2, right2, top2, xObject;
            return tslib_1.__generator(this, function(_c) {
              _a = this.page.normalizedEntries(), Contents = _a.Contents, Resources = _a.Resources;
              if (!Contents)
                throw new errors_1.MissingPageContentsEmbeddingError();
              decodedContents = this.decodeContents(Contents);
              _b = this.boundingBox, left2 = _b.left, bottom2 = _b.bottom, right2 = _b.right, top2 = _b.top;
              xObject = context.flateStream(decodedContents, {
                Type: "XObject",
                Subtype: "Form",
                FormType: 1,
                BBox: [left2, bottom2, right2, top2],
                Matrix: this.transformationMatrix,
                Resources
              });
              if (ref) {
                context.assign(ref, xObject);
                return [2, ref];
              } else {
                return [2, context.register(xObject)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        PDFPageEmbedder2.prototype.decodeContents = function(contents) {
          var newline = Uint8Array.of(CharCodes_1.default.Newline);
          var decodedContents = [];
          for (var idx = 0, len = contents.size(); idx < len; idx++) {
            var stream = contents.lookup(idx, PDFStream_1.default);
            var content = void 0;
            if (stream instanceof PDFRawStream_1.default) {
              content = decode_1.decodePDFRawStream(stream).decode();
            } else if (stream instanceof PDFContentStream_1.default) {
              content = stream.getUnencodedContents();
            } else {
              throw new errors_1.UnrecognizedStreamTypeError(stream);
            }
            decodedContents.push(content, newline);
          }
          return utils_1.mergeIntoTypedArray.apply(void 0, decodedContents);
        };
        return PDFPageEmbedder2;
      }()
    );
    exports.default = PDFPageEmbedder;
  }
});

// node_modules/pdf-lib/cjs/core/interactive/ViewerPreferences.js
var require_ViewerPreferences = __commonJS({
  "node_modules/pdf-lib/cjs/core/interactive/ViewerPreferences.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Duplex = exports.PrintScaling = exports.ReadingDirection = exports.NonFullScreenPageMode = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFBool_1 = tslib_1.__importDefault(require_PDFBool());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var utils_1 = require_utils2();
    var asEnum = function(rawValue, enumType) {
      if (rawValue === void 0)
        return void 0;
      return enumType[rawValue];
    };
    var NonFullScreenPageMode;
    (function(NonFullScreenPageMode2) {
      NonFullScreenPageMode2["UseNone"] = "UseNone";
      NonFullScreenPageMode2["UseOutlines"] = "UseOutlines";
      NonFullScreenPageMode2["UseThumbs"] = "UseThumbs";
      NonFullScreenPageMode2["UseOC"] = "UseOC";
    })(NonFullScreenPageMode = exports.NonFullScreenPageMode || (exports.NonFullScreenPageMode = {}));
    var ReadingDirection;
    (function(ReadingDirection2) {
      ReadingDirection2["L2R"] = "L2R";
      ReadingDirection2["R2L"] = "R2L";
    })(ReadingDirection = exports.ReadingDirection || (exports.ReadingDirection = {}));
    var PrintScaling;
    (function(PrintScaling2) {
      PrintScaling2["None"] = "None";
      PrintScaling2["AppDefault"] = "AppDefault";
    })(PrintScaling = exports.PrintScaling || (exports.PrintScaling = {}));
    var Duplex;
    (function(Duplex2) {
      Duplex2["Simplex"] = "Simplex";
      Duplex2["DuplexFlipShortEdge"] = "DuplexFlipShortEdge";
      Duplex2["DuplexFlipLongEdge"] = "DuplexFlipLongEdge";
    })(Duplex = exports.Duplex || (exports.Duplex = {}));
    var ViewerPreferences = (
      /** @class */
      function() {
        function ViewerPreferences2(dict) {
          this.dict = dict;
        }
        ViewerPreferences2.prototype.lookupBool = function(key) {
          var returnObj = this.dict.lookup(PDFName_1.default.of(key));
          if (returnObj instanceof PDFBool_1.default)
            return returnObj;
          return void 0;
        };
        ViewerPreferences2.prototype.lookupName = function(key) {
          var returnObj = this.dict.lookup(PDFName_1.default.of(key));
          if (returnObj instanceof PDFName_1.default)
            return returnObj;
          return void 0;
        };
        ViewerPreferences2.prototype.HideToolbar = function() {
          return this.lookupBool("HideToolbar");
        };
        ViewerPreferences2.prototype.HideMenubar = function() {
          return this.lookupBool("HideMenubar");
        };
        ViewerPreferences2.prototype.HideWindowUI = function() {
          return this.lookupBool("HideWindowUI");
        };
        ViewerPreferences2.prototype.FitWindow = function() {
          return this.lookupBool("FitWindow");
        };
        ViewerPreferences2.prototype.CenterWindow = function() {
          return this.lookupBool("CenterWindow");
        };
        ViewerPreferences2.prototype.DisplayDocTitle = function() {
          return this.lookupBool("DisplayDocTitle");
        };
        ViewerPreferences2.prototype.NonFullScreenPageMode = function() {
          return this.lookupName("NonFullScreenPageMode");
        };
        ViewerPreferences2.prototype.Direction = function() {
          return this.lookupName("Direction");
        };
        ViewerPreferences2.prototype.PrintScaling = function() {
          return this.lookupName("PrintScaling");
        };
        ViewerPreferences2.prototype.Duplex = function() {
          return this.lookupName("Duplex");
        };
        ViewerPreferences2.prototype.PickTrayByPDFSize = function() {
          return this.lookupBool("PickTrayByPDFSize");
        };
        ViewerPreferences2.prototype.PrintPageRange = function() {
          var PrintPageRange = this.dict.lookup(PDFName_1.default.of("PrintPageRange"));
          if (PrintPageRange instanceof PDFArray_1.default)
            return PrintPageRange;
          return void 0;
        };
        ViewerPreferences2.prototype.NumCopies = function() {
          var NumCopies = this.dict.lookup(PDFName_1.default.of("NumCopies"));
          if (NumCopies instanceof PDFNumber_1.default)
            return NumCopies;
          return void 0;
        };
        ViewerPreferences2.prototype.getHideToolbar = function() {
          var _a, _b;
          return (_b = (_a = this.HideToolbar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getHideMenubar = function() {
          var _a, _b;
          return (_b = (_a = this.HideMenubar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getHideWindowUI = function() {
          var _a, _b;
          return (_b = (_a = this.HideWindowUI()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getFitWindow = function() {
          var _a, _b;
          return (_b = (_a = this.FitWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getCenterWindow = function() {
          var _a, _b;
          return (_b = (_a = this.CenterWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getDisplayDocTitle = function() {
          var _a, _b;
          return (_b = (_a = this.DisplayDocTitle()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getNonFullScreenPageMode = function() {
          var _a, _b;
          var mode = (_a = this.NonFullScreenPageMode()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return (_b = asEnum(mode, NonFullScreenPageMode)) !== null && _b !== void 0 ? _b : NonFullScreenPageMode.UseNone;
        };
        ViewerPreferences2.prototype.getReadingDirection = function() {
          var _a, _b;
          var direction = (_a = this.Direction()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return (_b = asEnum(direction, ReadingDirection)) !== null && _b !== void 0 ? _b : ReadingDirection.L2R;
        };
        ViewerPreferences2.prototype.getPrintScaling = function() {
          var _a, _b;
          var scaling = (_a = this.PrintScaling()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return (_b = asEnum(scaling, PrintScaling)) !== null && _b !== void 0 ? _b : PrintScaling.AppDefault;
        };
        ViewerPreferences2.prototype.getDuplex = function() {
          var _a;
          var duplex = (_a = this.Duplex()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return asEnum(duplex, Duplex);
        };
        ViewerPreferences2.prototype.getPickTrayByPDFSize = function() {
          var _a;
          return (_a = this.PickTrayByPDFSize()) === null || _a === void 0 ? void 0 : _a.asBoolean();
        };
        ViewerPreferences2.prototype.getPrintPageRange = function() {
          var rng2 = this.PrintPageRange();
          if (!rng2)
            return [];
          var pageRanges = [];
          for (var i = 0; i < rng2.size(); i += 2) {
            var start2 = rng2.lookup(i, PDFNumber_1.default).asNumber();
            var end2 = rng2.lookup(i + 1, PDFNumber_1.default).asNumber();
            pageRanges.push({ start: start2, end: end2 });
          }
          return pageRanges;
        };
        ViewerPreferences2.prototype.getNumCopies = function() {
          var _a, _b;
          return (_b = (_a = this.NumCopies()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
        };
        ViewerPreferences2.prototype.setHideToolbar = function(hideToolbar) {
          var HideToolbar = this.dict.context.obj(hideToolbar);
          this.dict.set(PDFName_1.default.of("HideToolbar"), HideToolbar);
        };
        ViewerPreferences2.prototype.setHideMenubar = function(hideMenubar) {
          var HideMenubar = this.dict.context.obj(hideMenubar);
          this.dict.set(PDFName_1.default.of("HideMenubar"), HideMenubar);
        };
        ViewerPreferences2.prototype.setHideWindowUI = function(hideWindowUI) {
          var HideWindowUI = this.dict.context.obj(hideWindowUI);
          this.dict.set(PDFName_1.default.of("HideWindowUI"), HideWindowUI);
        };
        ViewerPreferences2.prototype.setFitWindow = function(fitWindow) {
          var FitWindow = this.dict.context.obj(fitWindow);
          this.dict.set(PDFName_1.default.of("FitWindow"), FitWindow);
        };
        ViewerPreferences2.prototype.setCenterWindow = function(centerWindow) {
          var CenterWindow = this.dict.context.obj(centerWindow);
          this.dict.set(PDFName_1.default.of("CenterWindow"), CenterWindow);
        };
        ViewerPreferences2.prototype.setDisplayDocTitle = function(displayTitle) {
          var DisplayDocTitle = this.dict.context.obj(displayTitle);
          this.dict.set(PDFName_1.default.of("DisplayDocTitle"), DisplayDocTitle);
        };
        ViewerPreferences2.prototype.setNonFullScreenPageMode = function(nonFullScreenPageMode) {
          utils_1.assertIsOneOf(nonFullScreenPageMode, "nonFullScreenPageMode", NonFullScreenPageMode);
          var mode = PDFName_1.default.of(nonFullScreenPageMode);
          this.dict.set(PDFName_1.default.of("NonFullScreenPageMode"), mode);
        };
        ViewerPreferences2.prototype.setReadingDirection = function(readingDirection) {
          utils_1.assertIsOneOf(readingDirection, "readingDirection", ReadingDirection);
          var direction = PDFName_1.default.of(readingDirection);
          this.dict.set(PDFName_1.default.of("Direction"), direction);
        };
        ViewerPreferences2.prototype.setPrintScaling = function(printScaling) {
          utils_1.assertIsOneOf(printScaling, "printScaling", PrintScaling);
          var scaling = PDFName_1.default.of(printScaling);
          this.dict.set(PDFName_1.default.of("PrintScaling"), scaling);
        };
        ViewerPreferences2.prototype.setDuplex = function(duplex) {
          utils_1.assertIsOneOf(duplex, "duplex", Duplex);
          var dup = PDFName_1.default.of(duplex);
          this.dict.set(PDFName_1.default.of("Duplex"), dup);
        };
        ViewerPreferences2.prototype.setPickTrayByPDFSize = function(pickTrayByPDFSize) {
          var PickTrayByPDFSize = this.dict.context.obj(pickTrayByPDFSize);
          this.dict.set(PDFName_1.default.of("PickTrayByPDFSize"), PickTrayByPDFSize);
        };
        ViewerPreferences2.prototype.setPrintPageRange = function(printPageRange) {
          if (!Array.isArray(printPageRange))
            printPageRange = [printPageRange];
          var flatRange = [];
          for (var idx = 0, len = printPageRange.length; idx < len; idx++) {
            flatRange.push(printPageRange[idx].start);
            flatRange.push(printPageRange[idx].end);
          }
          utils_1.assertEachIs(flatRange, "printPageRange", ["number"]);
          var pageRanges = this.dict.context.obj(flatRange);
          this.dict.set(PDFName_1.default.of("PrintPageRange"), pageRanges);
        };
        ViewerPreferences2.prototype.setNumCopies = function(numCopies) {
          utils_1.assertRange(numCopies, "numCopies", 1, Number.MAX_VALUE);
          utils_1.assertInteger(numCopies, "numCopies");
          var NumCopies = this.dict.context.obj(numCopies);
          this.dict.set(PDFName_1.default.of("NumCopies"), NumCopies);
        };
        ViewerPreferences2.fromDict = function(dict) {
          return new ViewerPreferences2(dict);
        };
        ViewerPreferences2.create = function(context) {
          var dict = context.obj({});
          return new ViewerPreferences2(dict);
        };
        return ViewerPreferences2;
      }()
    );
    exports.default = ViewerPreferences;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroField.js
var require_PDFAcroField = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroField.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var utils_1 = require_utils2();
    var errors_1 = require_errors2();
    var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/;
    var PDFAcroField = (
      /** @class */
      function() {
        function PDFAcroField2(dict, ref) {
          this.dict = dict;
          this.ref = ref;
        }
        PDFAcroField2.prototype.T = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("T"), PDFString_1.default, PDFHexString_1.default);
        };
        PDFAcroField2.prototype.Ff = function() {
          var numberOrRef = this.getInheritableAttribute(PDFName_1.default.of("Ff"));
          return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_1.default);
        };
        PDFAcroField2.prototype.V = function() {
          var valueOrRef = this.getInheritableAttribute(PDFName_1.default.of("V"));
          return this.dict.context.lookup(valueOrRef);
        };
        PDFAcroField2.prototype.Kids = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("Kids"), PDFArray_1.default);
        };
        PDFAcroField2.prototype.DA = function() {
          var da = this.dict.lookup(PDFName_1.default.of("DA"));
          if (da instanceof PDFString_1.default || da instanceof PDFHexString_1.default)
            return da;
          return void 0;
        };
        PDFAcroField2.prototype.setKids = function(kids) {
          this.dict.set(PDFName_1.default.of("Kids"), this.dict.context.obj(kids));
        };
        PDFAcroField2.prototype.getParent = function() {
          var parentRef = this.dict.get(PDFName_1.default.of("Parent"));
          if (parentRef instanceof PDFRef_1.default) {
            var parent_1 = this.dict.lookup(PDFName_1.default.of("Parent"), PDFDict_1.default);
            return new PDFAcroField2(parent_1, parentRef);
          }
          return void 0;
        };
        PDFAcroField2.prototype.setParent = function(parent) {
          if (!parent)
            this.dict.delete(PDFName_1.default.of("Parent"));
          else
            this.dict.set(PDFName_1.default.of("Parent"), parent);
        };
        PDFAcroField2.prototype.getFullyQualifiedName = function() {
          var parent = this.getParent();
          if (!parent)
            return this.getPartialName();
          return parent.getFullyQualifiedName() + "." + this.getPartialName();
        };
        PDFAcroField2.prototype.getPartialName = function() {
          var _a;
          return (_a = this.T()) === null || _a === void 0 ? void 0 : _a.decodeText();
        };
        PDFAcroField2.prototype.setPartialName = function(partialName) {
          if (!partialName)
            this.dict.delete(PDFName_1.default.of("T"));
          else
            this.dict.set(PDFName_1.default.of("T"), PDFHexString_1.default.fromText(partialName));
        };
        PDFAcroField2.prototype.setDefaultAppearance = function(appearance) {
          this.dict.set(PDFName_1.default.of("DA"), PDFString_1.default.of(appearance));
        };
        PDFAcroField2.prototype.getDefaultAppearance = function() {
          var DA = this.DA();
          if (DA instanceof PDFHexString_1.default) {
            return DA.decodeText();
          }
          return DA === null || DA === void 0 ? void 0 : DA.asString();
        };
        PDFAcroField2.prototype.setFontSize = function(fontSize) {
          var _a;
          var name = (_a = this.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
          var da = this.getDefaultAppearance();
          if (!da)
            throw new errors_1.MissingDAEntryError(name);
          var daMatch = utils_1.findLastMatch(da, tfRegex);
          if (!daMatch.match)
            throw new errors_1.MissingTfOperatorError(name);
          var daStart = da.slice(0, daMatch.pos - daMatch.match[0].length);
          var daEnd = daMatch.pos <= da.length ? da.slice(daMatch.pos) : "";
          var fontName = daMatch.match[1];
          var modifiedDa = daStart + " /" + fontName + " " + fontSize + " Tf " + daEnd;
          this.setDefaultAppearance(modifiedDa);
        };
        PDFAcroField2.prototype.getFlags = function() {
          var _a, _b;
          return (_b = (_a = this.Ff()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
        };
        PDFAcroField2.prototype.setFlags = function(flags) {
          this.dict.set(PDFName_1.default.of("Ff"), PDFNumber_1.default.of(flags));
        };
        PDFAcroField2.prototype.hasFlag = function(flag) {
          var flags = this.getFlags();
          return (flags & flag) !== 0;
        };
        PDFAcroField2.prototype.setFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags | flag);
        };
        PDFAcroField2.prototype.clearFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags & ~flag);
        };
        PDFAcroField2.prototype.setFlagTo = function(flag, enable) {
          if (enable)
            this.setFlag(flag);
          else
            this.clearFlag(flag);
        };
        PDFAcroField2.prototype.getInheritableAttribute = function(name) {
          var attribute;
          this.ascend(function(node) {
            if (!attribute)
              attribute = node.dict.get(name);
          });
          return attribute;
        };
        PDFAcroField2.prototype.ascend = function(visitor) {
          visitor(this);
          var parent = this.getParent();
          if (parent)
            parent.ascend(visitor);
        };
        return PDFAcroField2;
      }()
    );
    exports.default = PDFAcroField;
  }
});

// node_modules/pdf-lib/cjs/core/annotation/BorderStyle.js
var require_BorderStyle = __commonJS({
  "node_modules/pdf-lib/cjs/core/annotation/BorderStyle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var BorderStyle = (
      /** @class */
      function() {
        function BorderStyle2(dict) {
          this.dict = dict;
        }
        BorderStyle2.prototype.W = function() {
          var W = this.dict.lookup(PDFName_1.default.of("W"));
          if (W instanceof PDFNumber_1.default)
            return W;
          return void 0;
        };
        BorderStyle2.prototype.getWidth = function() {
          var _a, _b;
          return (_b = (_a = this.W()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
        };
        BorderStyle2.prototype.setWidth = function(width) {
          var W = this.dict.context.obj(width);
          this.dict.set(PDFName_1.default.of("W"), W);
        };
        BorderStyle2.fromDict = function(dict) {
          return new BorderStyle2(dict);
        };
        return BorderStyle2;
      }()
    );
    exports.default = BorderStyle;
  }
});

// node_modules/pdf-lib/cjs/core/annotation/PDFAnnotation.js
var require_PDFAnnotation = __commonJS({
  "node_modules/pdf-lib/cjs/core/annotation/PDFAnnotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFAnnotation = (
      /** @class */
      function() {
        function PDFAnnotation2(dict) {
          this.dict = dict;
        }
        PDFAnnotation2.prototype.Rect = function() {
          return this.dict.lookup(PDFName_1.default.of("Rect"), PDFArray_1.default);
        };
        PDFAnnotation2.prototype.AP = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("AP"), PDFDict_1.default);
        };
        PDFAnnotation2.prototype.F = function() {
          var numberOrRef = this.dict.lookup(PDFName_1.default.of("F"));
          return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_1.default);
        };
        PDFAnnotation2.prototype.getRectangle = function() {
          var _a;
          var Rect = this.Rect();
          return (_a = Rect === null || Rect === void 0 ? void 0 : Rect.asRectangle()) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: 0, height: 0 };
        };
        PDFAnnotation2.prototype.setRectangle = function(rect) {
          var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
          var Rect = this.dict.context.obj([x, y, x + width, y + height]);
          this.dict.set(PDFName_1.default.of("Rect"), Rect);
        };
        PDFAnnotation2.prototype.getAppearanceState = function() {
          var AS = this.dict.lookup(PDFName_1.default.of("AS"));
          if (AS instanceof PDFName_1.default)
            return AS;
          return void 0;
        };
        PDFAnnotation2.prototype.setAppearanceState = function(state) {
          this.dict.set(PDFName_1.default.of("AS"), state);
        };
        PDFAnnotation2.prototype.setAppearances = function(appearances) {
          this.dict.set(PDFName_1.default.of("AP"), appearances);
        };
        PDFAnnotation2.prototype.ensureAP = function() {
          var AP = this.AP();
          if (!AP) {
            AP = this.dict.context.obj({});
            this.dict.set(PDFName_1.default.of("AP"), AP);
          }
          return AP;
        };
        PDFAnnotation2.prototype.getNormalAppearance = function() {
          var AP = this.ensureAP();
          var N = AP.get(PDFName_1.default.of("N"));
          if (N instanceof PDFRef_1.default || N instanceof PDFDict_1.default)
            return N;
          throw new Error("Unexpected N type: " + (N === null || N === void 0 ? void 0 : N.constructor.name));
        };
        PDFAnnotation2.prototype.setNormalAppearance = function(appearance) {
          var AP = this.ensureAP();
          AP.set(PDFName_1.default.of("N"), appearance);
        };
        PDFAnnotation2.prototype.setRolloverAppearance = function(appearance) {
          var AP = this.ensureAP();
          AP.set(PDFName_1.default.of("R"), appearance);
        };
        PDFAnnotation2.prototype.setDownAppearance = function(appearance) {
          var AP = this.ensureAP();
          AP.set(PDFName_1.default.of("D"), appearance);
        };
        PDFAnnotation2.prototype.removeRolloverAppearance = function() {
          var AP = this.AP();
          AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_1.default.of("R"));
        };
        PDFAnnotation2.prototype.removeDownAppearance = function() {
          var AP = this.AP();
          AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_1.default.of("D"));
        };
        PDFAnnotation2.prototype.getAppearances = function() {
          var AP = this.AP();
          if (!AP)
            return void 0;
          var N = AP.lookup(PDFName_1.default.of("N"), PDFDict_1.default, PDFStream_1.default);
          var R = AP.lookupMaybe(PDFName_1.default.of("R"), PDFDict_1.default, PDFStream_1.default);
          var D = AP.lookupMaybe(PDFName_1.default.of("D"), PDFDict_1.default, PDFStream_1.default);
          return { normal: N, rollover: R, down: D };
        };
        PDFAnnotation2.prototype.getFlags = function() {
          var _a, _b;
          return (_b = (_a = this.F()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
        };
        PDFAnnotation2.prototype.setFlags = function(flags) {
          this.dict.set(PDFName_1.default.of("F"), PDFNumber_1.default.of(flags));
        };
        PDFAnnotation2.prototype.hasFlag = function(flag) {
          var flags = this.getFlags();
          return (flags & flag) !== 0;
        };
        PDFAnnotation2.prototype.setFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags | flag);
        };
        PDFAnnotation2.prototype.clearFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags & ~flag);
        };
        PDFAnnotation2.prototype.setFlagTo = function(flag, enable) {
          if (enable)
            this.setFlag(flag);
          else
            this.clearFlag(flag);
        };
        PDFAnnotation2.fromDict = function(dict) {
          return new PDFAnnotation2(dict);
        };
        return PDFAnnotation2;
      }()
    );
    exports.default = PDFAnnotation;
  }
});

// node_modules/pdf-lib/cjs/core/annotation/AppearanceCharacteristics.js
var require_AppearanceCharacteristics = __commonJS({
  "node_modules/pdf-lib/cjs/core/annotation/AppearanceCharacteristics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var AppearanceCharacteristics = (
      /** @class */
      function() {
        function AppearanceCharacteristics2(dict) {
          this.dict = dict;
        }
        AppearanceCharacteristics2.prototype.R = function() {
          var R = this.dict.lookup(PDFName_1.default.of("R"));
          if (R instanceof PDFNumber_1.default)
            return R;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.BC = function() {
          var BC = this.dict.lookup(PDFName_1.default.of("BC"));
          if (BC instanceof PDFArray_1.default)
            return BC;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.BG = function() {
          var BG = this.dict.lookup(PDFName_1.default.of("BG"));
          if (BG instanceof PDFArray_1.default)
            return BG;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.CA = function() {
          var CA = this.dict.lookup(PDFName_1.default.of("CA"));
          if (CA instanceof PDFHexString_1.default || CA instanceof PDFString_1.default)
            return CA;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.RC = function() {
          var RC = this.dict.lookup(PDFName_1.default.of("RC"));
          if (RC instanceof PDFHexString_1.default || RC instanceof PDFString_1.default)
            return RC;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.AC = function() {
          var AC = this.dict.lookup(PDFName_1.default.of("AC"));
          if (AC instanceof PDFHexString_1.default || AC instanceof PDFString_1.default)
            return AC;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.getRotation = function() {
          var _a;
          return (_a = this.R()) === null || _a === void 0 ? void 0 : _a.asNumber();
        };
        AppearanceCharacteristics2.prototype.getBorderColor = function() {
          var BC = this.BC();
          if (!BC)
            return void 0;
          var components = [];
          for (var idx = 0, len = BC === null || BC === void 0 ? void 0 : BC.size(); idx < len; idx++) {
            var component = BC.get(idx);
            if (component instanceof PDFNumber_1.default)
              components.push(component.asNumber());
          }
          return components;
        };
        AppearanceCharacteristics2.prototype.getBackgroundColor = function() {
          var BG = this.BG();
          if (!BG)
            return void 0;
          var components = [];
          for (var idx = 0, len = BG === null || BG === void 0 ? void 0 : BG.size(); idx < len; idx++) {
            var component = BG.get(idx);
            if (component instanceof PDFNumber_1.default)
              components.push(component.asNumber());
          }
          return components;
        };
        AppearanceCharacteristics2.prototype.getCaptions = function() {
          var CA = this.CA();
          var RC = this.RC();
          var AC = this.AC();
          return {
            normal: CA === null || CA === void 0 ? void 0 : CA.decodeText(),
            rollover: RC === null || RC === void 0 ? void 0 : RC.decodeText(),
            down: AC === null || AC === void 0 ? void 0 : AC.decodeText()
          };
        };
        AppearanceCharacteristics2.prototype.setRotation = function(rotation) {
          var R = this.dict.context.obj(rotation);
          this.dict.set(PDFName_1.default.of("R"), R);
        };
        AppearanceCharacteristics2.prototype.setBorderColor = function(color) {
          var BC = this.dict.context.obj(color);
          this.dict.set(PDFName_1.default.of("BC"), BC);
        };
        AppearanceCharacteristics2.prototype.setBackgroundColor = function(color) {
          var BG = this.dict.context.obj(color);
          this.dict.set(PDFName_1.default.of("BG"), BG);
        };
        AppearanceCharacteristics2.prototype.setCaptions = function(captions) {
          var CA = PDFHexString_1.default.fromText(captions.normal);
          this.dict.set(PDFName_1.default.of("CA"), CA);
          if (captions.rollover) {
            var RC = PDFHexString_1.default.fromText(captions.rollover);
            this.dict.set(PDFName_1.default.of("RC"), RC);
          } else {
            this.dict.delete(PDFName_1.default.of("RC"));
          }
          if (captions.down) {
            var AC = PDFHexString_1.default.fromText(captions.down);
            this.dict.set(PDFName_1.default.of("AC"), AC);
          } else {
            this.dict.delete(PDFName_1.default.of("AC"));
          }
        };
        AppearanceCharacteristics2.fromDict = function(dict) {
          return new AppearanceCharacteristics2(dict);
        };
        return AppearanceCharacteristics2;
      }()
    );
    exports.default = AppearanceCharacteristics;
  }
});

// node_modules/pdf-lib/cjs/core/annotation/PDFWidgetAnnotation.js
var require_PDFWidgetAnnotation = __commonJS({
  "node_modules/pdf-lib/cjs/core/annotation/PDFWidgetAnnotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var BorderStyle_1 = tslib_1.__importDefault(require_BorderStyle());
    var PDFAnnotation_1 = tslib_1.__importDefault(require_PDFAnnotation());
    var AppearanceCharacteristics_1 = tslib_1.__importDefault(require_AppearanceCharacteristics());
    var PDFWidgetAnnotation = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFWidgetAnnotation2, _super);
        function PDFWidgetAnnotation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFWidgetAnnotation2.prototype.MK = function() {
          var MK = this.dict.lookup(PDFName_1.default.of("MK"));
          if (MK instanceof PDFDict_1.default)
            return MK;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.BS = function() {
          var BS = this.dict.lookup(PDFName_1.default.of("BS"));
          if (BS instanceof PDFDict_1.default)
            return BS;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.DA = function() {
          var da = this.dict.lookup(PDFName_1.default.of("DA"));
          if (da instanceof PDFString_1.default || da instanceof PDFHexString_1.default)
            return da;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.P = function() {
          var P = this.dict.get(PDFName_1.default.of("P"));
          if (P instanceof PDFRef_1.default)
            return P;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.setP = function(page) {
          this.dict.set(PDFName_1.default.of("P"), page);
        };
        PDFWidgetAnnotation2.prototype.setDefaultAppearance = function(appearance) {
          this.dict.set(PDFName_1.default.of("DA"), PDFString_1.default.of(appearance));
        };
        PDFWidgetAnnotation2.prototype.getDefaultAppearance = function() {
          var DA = this.DA();
          if (DA instanceof PDFHexString_1.default) {
            return DA.decodeText();
          }
          return DA === null || DA === void 0 ? void 0 : DA.asString();
        };
        PDFWidgetAnnotation2.prototype.getAppearanceCharacteristics = function() {
          var MK = this.MK();
          if (MK)
            return AppearanceCharacteristics_1.default.fromDict(MK);
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.getOrCreateAppearanceCharacteristics = function() {
          var MK = this.MK();
          if (MK)
            return AppearanceCharacteristics_1.default.fromDict(MK);
          var ac = AppearanceCharacteristics_1.default.fromDict(this.dict.context.obj({}));
          this.dict.set(PDFName_1.default.of("MK"), ac.dict);
          return ac;
        };
        PDFWidgetAnnotation2.prototype.getBorderStyle = function() {
          var BS = this.BS();
          if (BS)
            return BorderStyle_1.default.fromDict(BS);
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.getOrCreateBorderStyle = function() {
          var BS = this.BS();
          if (BS)
            return BorderStyle_1.default.fromDict(BS);
          var bs = BorderStyle_1.default.fromDict(this.dict.context.obj({}));
          this.dict.set(PDFName_1.default.of("BS"), bs.dict);
          return bs;
        };
        PDFWidgetAnnotation2.prototype.getOnValue = function() {
          var _a;
          var normal = (_a = this.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
          if (normal instanceof PDFDict_1.default) {
            var keys = normal.keys();
            for (var idx = 0, len = keys.length; idx < len; idx++) {
              var key = keys[idx];
              if (key !== PDFName_1.default.of("Off"))
                return key;
            }
          }
          return void 0;
        };
        PDFWidgetAnnotation2.fromDict = function(dict) {
          return new PDFWidgetAnnotation2(dict);
        };
        PDFWidgetAnnotation2.create = function(context, parent) {
          var dict = context.obj({
            Type: "Annot",
            Subtype: "Widget",
            Rect: [0, 0, 0, 0],
            Parent: parent
          });
          return new PDFWidgetAnnotation2(dict);
        };
        return PDFWidgetAnnotation2;
      }(PDFAnnotation_1.default)
    );
    exports.default = PDFWidgetAnnotation;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroTerminal.js
var require_PDFAcroTerminal = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroTerminal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroField_1 = tslib_1.__importDefault(require_PDFAcroField());
    var PDFWidgetAnnotation_1 = tslib_1.__importDefault(require_PDFWidgetAnnotation());
    var errors_1 = require_errors2();
    var PDFAcroTerminal = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroTerminal2, _super);
        function PDFAcroTerminal2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroTerminal2.prototype.FT = function() {
          var nameOrRef = this.getInheritableAttribute(PDFName_1.default.of("FT"));
          return this.dict.context.lookup(nameOrRef, PDFName_1.default);
        };
        PDFAcroTerminal2.prototype.getWidgets = function() {
          var kidDicts = this.Kids();
          if (!kidDicts)
            return [PDFWidgetAnnotation_1.default.fromDict(this.dict)];
          var widgets = new Array(kidDicts.size());
          for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
            var dict = kidDicts.lookup(idx, PDFDict_1.default);
            widgets[idx] = PDFWidgetAnnotation_1.default.fromDict(dict);
          }
          return widgets;
        };
        PDFAcroTerminal2.prototype.addWidget = function(ref) {
          var Kids = this.normalizedEntries().Kids;
          Kids.push(ref);
        };
        PDFAcroTerminal2.prototype.removeWidget = function(idx) {
          var kidDicts = this.Kids();
          if (!kidDicts) {
            if (idx !== 0)
              throw new errors_1.IndexOutOfBoundsError(idx, 0, 0);
            this.setKids([]);
          } else {
            if (idx < 0 || idx > kidDicts.size()) {
              throw new errors_1.IndexOutOfBoundsError(idx, 0, kidDicts.size());
            }
            kidDicts.remove(idx);
          }
        };
        PDFAcroTerminal2.prototype.normalizedEntries = function() {
          var Kids = this.Kids();
          if (!Kids) {
            Kids = this.dict.context.obj([this.ref]);
            this.dict.set(PDFName_1.default.of("Kids"), Kids);
          }
          return { Kids };
        };
        PDFAcroTerminal2.fromDict = function(dict, ref) {
          return new PDFAcroTerminal2(dict, ref);
        };
        return PDFAcroTerminal2;
      }(PDFAcroField_1.default)
    );
    exports.default = PDFAcroTerminal;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroButton.js
var require_PDFAcroButton = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var errors_1 = require_errors2();
    var PDFAcroButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroButton2, _super);
        function PDFAcroButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroButton2.prototype.Opt = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("Opt"), PDFString_1.default, PDFHexString_1.default, PDFArray_1.default);
        };
        PDFAcroButton2.prototype.setOpt = function(opt) {
          this.dict.set(PDFName_1.default.of("Opt"), this.dict.context.obj(opt));
        };
        PDFAcroButton2.prototype.getExportValues = function() {
          var opt = this.Opt();
          if (!opt)
            return void 0;
          if (opt instanceof PDFString_1.default || opt instanceof PDFHexString_1.default) {
            return [opt];
          }
          var values = [];
          for (var idx = 0, len = opt.size(); idx < len; idx++) {
            var value = opt.lookup(idx);
            if (value instanceof PDFString_1.default || value instanceof PDFHexString_1.default) {
              values.push(value);
            }
          }
          return values;
        };
        PDFAcroButton2.prototype.removeExportValue = function(idx) {
          var opt = this.Opt();
          if (!opt)
            return;
          if (opt instanceof PDFString_1.default || opt instanceof PDFHexString_1.default) {
            if (idx !== 0)
              throw new errors_1.IndexOutOfBoundsError(idx, 0, 0);
            this.setOpt([]);
          } else {
            if (idx < 0 || idx > opt.size()) {
              throw new errors_1.IndexOutOfBoundsError(idx, 0, opt.size());
            }
            opt.remove(idx);
          }
        };
        PDFAcroButton2.prototype.normalizeExportValues = function() {
          var _a, _b, _c, _d;
          var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
          var Opt = [];
          var widgets = this.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var exportVal = (_b = exportValues[idx]) !== null && _b !== void 0 ? _b : PDFHexString_1.default.fromText((_d = (_c = widget.getOnValue()) === null || _c === void 0 ? void 0 : _c.decodeText()) !== null && _d !== void 0 ? _d : "");
            Opt.push(exportVal);
          }
          this.setOpt(Opt);
        };
        PDFAcroButton2.prototype.addOpt = function(opt, useExistingOptIdx) {
          var _a;
          this.normalizeExportValues();
          var optText = opt.decodeText();
          var existingIdx;
          if (useExistingOptIdx) {
            var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
            for (var idx = 0, len = exportValues.length; idx < len; idx++) {
              var exportVal = exportValues[idx];
              if (exportVal.decodeText() === optText)
                existingIdx = idx;
            }
          }
          var Opt = this.Opt();
          Opt.push(opt);
          return existingIdx !== null && existingIdx !== void 0 ? existingIdx : Opt.size() - 1;
        };
        PDFAcroButton2.prototype.addWidgetWithOpt = function(widget, opt, useExistingOptIdx) {
          var optIdx = this.addOpt(opt, useExistingOptIdx);
          var apStateValue = PDFName_1.default.of(String(optIdx));
          this.addWidget(widget);
          return apStateValue;
        };
        return PDFAcroButton2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroButton;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroCheckBox.js
var require_PDFAcroCheckBox = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroCheckBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroButton_1 = tslib_1.__importDefault(require_PDFAcroButton());
    var errors_1 = require_errors2();
    var PDFAcroCheckBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroCheckBox2, _super);
        function PDFAcroCheckBox2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroCheckBox2.prototype.setValue = function(value) {
          var _a;
          var onValue = (_a = this.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_1.default.of("Yes");
          if (value !== onValue && value !== PDFName_1.default.of("Off")) {
            throw new errors_1.InvalidAcroFieldValueError();
          }
          this.dict.set(PDFName_1.default.of("V"), value);
          var widgets = this.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getOnValue() === value ? value : PDFName_1.default.of("Off");
            widget.setAppearanceState(state);
          }
        };
        PDFAcroCheckBox2.prototype.getValue = function() {
          var v = this.V();
          if (v instanceof PDFName_1.default)
            return v;
          return PDFName_1.default.of("Off");
        };
        PDFAcroCheckBox2.prototype.getOnValue = function() {
          var widget = this.getWidgets()[0];
          return widget === null || widget === void 0 ? void 0 : widget.getOnValue();
        };
        PDFAcroCheckBox2.fromDict = function(dict, ref) {
          return new PDFAcroCheckBox2(dict, ref);
        };
        PDFAcroCheckBox2.create = function(context) {
          var dict = context.obj({
            FT: "Btn",
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroCheckBox2(dict, ref);
        };
        return PDFAcroCheckBox2;
      }(PDFAcroButton_1.default)
    );
    exports.default = PDFAcroCheckBox;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/flags.js
var require_flags = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AcroChoiceFlags = exports.AcroTextFlags = exports.AcroButtonFlags = exports.AcroFieldFlags = void 0;
    var flag = function(bitIndex) {
      return 1 << bitIndex;
    };
    var AcroFieldFlags;
    (function(AcroFieldFlags2) {
      AcroFieldFlags2[AcroFieldFlags2["ReadOnly"] = flag(1 - 1)] = "ReadOnly";
      AcroFieldFlags2[AcroFieldFlags2["Required"] = flag(2 - 1)] = "Required";
      AcroFieldFlags2[AcroFieldFlags2["NoExport"] = flag(3 - 1)] = "NoExport";
    })(AcroFieldFlags = exports.AcroFieldFlags || (exports.AcroFieldFlags = {}));
    var AcroButtonFlags;
    (function(AcroButtonFlags2) {
      AcroButtonFlags2[AcroButtonFlags2["NoToggleToOff"] = flag(15 - 1)] = "NoToggleToOff";
      AcroButtonFlags2[AcroButtonFlags2["Radio"] = flag(16 - 1)] = "Radio";
      AcroButtonFlags2[AcroButtonFlags2["PushButton"] = flag(17 - 1)] = "PushButton";
      AcroButtonFlags2[AcroButtonFlags2["RadiosInUnison"] = flag(26 - 1)] = "RadiosInUnison";
    })(AcroButtonFlags = exports.AcroButtonFlags || (exports.AcroButtonFlags = {}));
    var AcroTextFlags;
    (function(AcroTextFlags2) {
      AcroTextFlags2[AcroTextFlags2["Multiline"] = flag(13 - 1)] = "Multiline";
      AcroTextFlags2[AcroTextFlags2["Password"] = flag(14 - 1)] = "Password";
      AcroTextFlags2[AcroTextFlags2["FileSelect"] = flag(21 - 1)] = "FileSelect";
      AcroTextFlags2[AcroTextFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
      AcroTextFlags2[AcroTextFlags2["DoNotScroll"] = flag(24 - 1)] = "DoNotScroll";
      AcroTextFlags2[AcroTextFlags2["Comb"] = flag(25 - 1)] = "Comb";
      AcroTextFlags2[AcroTextFlags2["RichText"] = flag(26 - 1)] = "RichText";
    })(AcroTextFlags = exports.AcroTextFlags || (exports.AcroTextFlags = {}));
    var AcroChoiceFlags;
    (function(AcroChoiceFlags2) {
      AcroChoiceFlags2[AcroChoiceFlags2["Combo"] = flag(18 - 1)] = "Combo";
      AcroChoiceFlags2[AcroChoiceFlags2["Edit"] = flag(19 - 1)] = "Edit";
      AcroChoiceFlags2[AcroChoiceFlags2["Sort"] = flag(20 - 1)] = "Sort";
      AcroChoiceFlags2[AcroChoiceFlags2["MultiSelect"] = flag(22 - 1)] = "MultiSelect";
      AcroChoiceFlags2[AcroChoiceFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
      AcroChoiceFlags2[AcroChoiceFlags2["CommitOnSelChange"] = flag(27 - 1)] = "CommitOnSelChange";
    })(AcroChoiceFlags = exports.AcroChoiceFlags || (exports.AcroChoiceFlags = {}));
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroChoice.js
var require_PDFAcroChoice = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroChoice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var flags_1 = require_flags();
    var errors_1 = require_errors2();
    var PDFAcroChoice = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroChoice2, _super);
        function PDFAcroChoice2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroChoice2.prototype.setValues = function(values) {
          if (this.hasFlag(flags_1.AcroChoiceFlags.Combo) && !this.hasFlag(flags_1.AcroChoiceFlags.Edit) && !this.valuesAreValid(values)) {
            throw new errors_1.InvalidAcroFieldValueError();
          }
          if (values.length === 0) {
            this.dict.delete(PDFName_1.default.of("V"));
          }
          if (values.length === 1) {
            this.dict.set(PDFName_1.default.of("V"), values[0]);
          }
          if (values.length > 1) {
            if (!this.hasFlag(flags_1.AcroChoiceFlags.MultiSelect)) {
              throw new errors_1.MultiSelectValueError();
            }
            this.dict.set(PDFName_1.default.of("V"), this.dict.context.obj(values));
          }
          this.updateSelectedIndices(values);
        };
        PDFAcroChoice2.prototype.valuesAreValid = function(values) {
          var options = this.getOptions();
          var _loop_1 = function(idx2, len2) {
            var val = values[idx2].decodeText();
            if (!options.find(function(o) {
              return val === (o.display || o.value).decodeText();
            })) {
              return { value: false };
            }
          };
          for (var idx = 0, len = values.length; idx < len; idx++) {
            var state_1 = _loop_1(idx, len);
            if (typeof state_1 === "object")
              return state_1.value;
          }
          return true;
        };
        PDFAcroChoice2.prototype.updateSelectedIndices = function(values) {
          if (values.length > 1) {
            var indices = new Array(values.length);
            var options = this.getOptions();
            var _loop_2 = function(idx2, len2) {
              var val = values[idx2].decodeText();
              indices[idx2] = options.findIndex(function(o) {
                return val === (o.display || o.value).decodeText();
              });
            };
            for (var idx = 0, len = values.length; idx < len; idx++) {
              _loop_2(idx, len);
            }
            this.dict.set(PDFName_1.default.of("I"), this.dict.context.obj(indices.sort()));
          } else {
            this.dict.delete(PDFName_1.default.of("I"));
          }
        };
        PDFAcroChoice2.prototype.getValues = function() {
          var v = this.V();
          if (v instanceof PDFString_1.default || v instanceof PDFHexString_1.default)
            return [v];
          if (v instanceof PDFArray_1.default) {
            var values = [];
            for (var idx = 0, len = v.size(); idx < len; idx++) {
              var value = v.lookup(idx);
              if (value instanceof PDFString_1.default || value instanceof PDFHexString_1.default) {
                values.push(value);
              }
            }
            return values;
          }
          return [];
        };
        PDFAcroChoice2.prototype.Opt = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("Opt"), PDFString_1.default, PDFHexString_1.default, PDFArray_1.default);
        };
        PDFAcroChoice2.prototype.setOptions = function(options) {
          var newOpt = new Array(options.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            var _a = options[idx], value = _a.value, display = _a.display;
            newOpt[idx] = this.dict.context.obj([value, display || value]);
          }
          this.dict.set(PDFName_1.default.of("Opt"), this.dict.context.obj(newOpt));
        };
        PDFAcroChoice2.prototype.getOptions = function() {
          var Opt = this.Opt();
          if (Opt instanceof PDFString_1.default || Opt instanceof PDFHexString_1.default) {
            return [{ value: Opt, display: Opt }];
          }
          if (Opt instanceof PDFArray_1.default) {
            var res = [];
            for (var idx = 0, len = Opt.size(); idx < len; idx++) {
              var item = Opt.lookup(idx);
              if (item instanceof PDFString_1.default || item instanceof PDFHexString_1.default) {
                res.push({ value: item, display: item });
              }
              if (item instanceof PDFArray_1.default) {
                if (item.size() > 0) {
                  var first = item.lookup(0, PDFString_1.default, PDFHexString_1.default);
                  var second = item.lookupMaybe(1, PDFString_1.default, PDFHexString_1.default);
                  res.push({ value: first, display: second || first });
                }
              }
            }
            return res;
          }
          return [];
        };
        return PDFAcroChoice2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroChoice;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroComboBox.js
var require_PDFAcroComboBox = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroComboBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroChoice_1 = tslib_1.__importDefault(require_PDFAcroChoice());
    var flags_1 = require_flags();
    var PDFAcroComboBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroComboBox2, _super);
        function PDFAcroComboBox2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroComboBox2.fromDict = function(dict, ref) {
          return new PDFAcroComboBox2(dict, ref);
        };
        PDFAcroComboBox2.create = function(context) {
          var dict = context.obj({
            FT: "Ch",
            Ff: flags_1.AcroChoiceFlags.Combo,
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroComboBox2(dict, ref);
        };
        return PDFAcroComboBox2;
      }(PDFAcroChoice_1.default)
    );
    exports.default = PDFAcroComboBox;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroNonTerminal.js
var require_PDFAcroNonTerminal = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroNonTerminal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroField_1 = tslib_1.__importDefault(require_PDFAcroField());
    var PDFAcroNonTerminal = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroNonTerminal2, _super);
        function PDFAcroNonTerminal2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroNonTerminal2.prototype.addField = function(field) {
          var Kids = this.normalizedEntries().Kids;
          Kids === null || Kids === void 0 ? void 0 : Kids.push(field);
        };
        PDFAcroNonTerminal2.prototype.normalizedEntries = function() {
          var Kids = this.Kids();
          if (!Kids) {
            Kids = this.dict.context.obj([]);
            this.dict.set(PDFName_1.default.of("Kids"), Kids);
          }
          return { Kids };
        };
        PDFAcroNonTerminal2.fromDict = function(dict, ref) {
          return new PDFAcroNonTerminal2(dict, ref);
        };
        PDFAcroNonTerminal2.create = function(context) {
          var dict = context.obj({});
          var ref = context.register(dict);
          return new PDFAcroNonTerminal2(dict, ref);
        };
        return PDFAcroNonTerminal2;
      }(PDFAcroField_1.default)
    );
    exports.default = PDFAcroNonTerminal;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroSignature.js
var require_PDFAcroSignature = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFAcroSignature = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroSignature2, _super);
        function PDFAcroSignature2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroSignature2.fromDict = function(dict, ref) {
          return new PDFAcroSignature2(dict, ref);
        };
        return PDFAcroSignature2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroSignature;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroText.js
var require_PDFAcroText = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFAcroText = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroText2, _super);
        function PDFAcroText2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroText2.prototype.MaxLen = function() {
          var maxLen = this.dict.lookup(PDFName_1.default.of("MaxLen"));
          if (maxLen instanceof PDFNumber_1.default)
            return maxLen;
          return void 0;
        };
        PDFAcroText2.prototype.Q = function() {
          var q = this.dict.lookup(PDFName_1.default.of("Q"));
          if (q instanceof PDFNumber_1.default)
            return q;
          return void 0;
        };
        PDFAcroText2.prototype.setMaxLength = function(maxLength) {
          this.dict.set(PDFName_1.default.of("MaxLen"), PDFNumber_1.default.of(maxLength));
        };
        PDFAcroText2.prototype.removeMaxLength = function() {
          this.dict.delete(PDFName_1.default.of("MaxLen"));
        };
        PDFAcroText2.prototype.getMaxLength = function() {
          var _a;
          return (_a = this.MaxLen()) === null || _a === void 0 ? void 0 : _a.asNumber();
        };
        PDFAcroText2.prototype.setQuadding = function(quadding) {
          this.dict.set(PDFName_1.default.of("Q"), PDFNumber_1.default.of(quadding));
        };
        PDFAcroText2.prototype.getQuadding = function() {
          var _a;
          return (_a = this.Q()) === null || _a === void 0 ? void 0 : _a.asNumber();
        };
        PDFAcroText2.prototype.setValue = function(value) {
          this.dict.set(PDFName_1.default.of("V"), value);
        };
        PDFAcroText2.prototype.removeValue = function() {
          this.dict.delete(PDFName_1.default.of("V"));
        };
        PDFAcroText2.prototype.getValue = function() {
          var v = this.V();
          if (v instanceof PDFString_1.default || v instanceof PDFHexString_1.default)
            return v;
          return void 0;
        };
        PDFAcroText2.fromDict = function(dict, ref) {
          return new PDFAcroText2(dict, ref);
        };
        PDFAcroText2.create = function(context) {
          var dict = context.obj({
            FT: "Tx",
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroText2(dict, ref);
        };
        return PDFAcroText2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroText;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroPushButton.js
var require_PDFAcroPushButton = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroPushButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroButton_1 = tslib_1.__importDefault(require_PDFAcroButton());
    var flags_1 = require_flags();
    var PDFAcroPushButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroPushButton2, _super);
        function PDFAcroPushButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroPushButton2.fromDict = function(dict, ref) {
          return new PDFAcroPushButton2(dict, ref);
        };
        PDFAcroPushButton2.create = function(context) {
          var dict = context.obj({
            FT: "Btn",
            Ff: flags_1.AcroButtonFlags.PushButton,
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroPushButton2(dict, ref);
        };
        return PDFAcroPushButton2;
      }(PDFAcroButton_1.default)
    );
    exports.default = PDFAcroPushButton;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroRadioButton.js
var require_PDFAcroRadioButton = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroRadioButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroButton_1 = tslib_1.__importDefault(require_PDFAcroButton());
    var flags_1 = require_flags();
    var errors_1 = require_errors2();
    var PDFAcroRadioButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroRadioButton2, _super);
        function PDFAcroRadioButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroRadioButton2.prototype.setValue = function(value) {
          var onValues = this.getOnValues();
          if (!onValues.includes(value) && value !== PDFName_1.default.of("Off")) {
            throw new errors_1.InvalidAcroFieldValueError();
          }
          this.dict.set(PDFName_1.default.of("V"), value);
          var widgets = this.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getOnValue() === value ? value : PDFName_1.default.of("Off");
            widget.setAppearanceState(state);
          }
        };
        PDFAcroRadioButton2.prototype.getValue = function() {
          var v = this.V();
          if (v instanceof PDFName_1.default)
            return v;
          return PDFName_1.default.of("Off");
        };
        PDFAcroRadioButton2.prototype.getOnValues = function() {
          var widgets = this.getWidgets();
          var onValues = [];
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var onValue = widgets[idx].getOnValue();
            if (onValue)
              onValues.push(onValue);
          }
          return onValues;
        };
        PDFAcroRadioButton2.fromDict = function(dict, ref) {
          return new PDFAcroRadioButton2(dict, ref);
        };
        PDFAcroRadioButton2.create = function(context) {
          var dict = context.obj({
            FT: "Btn",
            Ff: flags_1.AcroButtonFlags.Radio,
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroRadioButton2(dict, ref);
        };
        return PDFAcroRadioButton2;
      }(PDFAcroButton_1.default)
    );
    exports.default = PDFAcroRadioButton;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroListBox.js
var require_PDFAcroListBox = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroListBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroChoice_1 = tslib_1.__importDefault(require_PDFAcroChoice());
    var PDFAcroListBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroListBox2, _super);
        function PDFAcroListBox2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroListBox2.fromDict = function(dict, ref) {
          return new PDFAcroListBox2(dict, ref);
        };
        PDFAcroListBox2.create = function(context) {
          var dict = context.obj({
            FT: "Ch",
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroListBox2(dict, ref);
        };
        return PDFAcroListBox2;
      }(PDFAcroChoice_1.default)
    );
    exports.default = PDFAcroListBox;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/utils.js
var require_utils3 = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPDFAcroField = exports.createPDFAcroFields = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFAcroNonTerminal_1 = tslib_1.__importDefault(require_PDFAcroNonTerminal());
    var PDFAcroSignature_1 = tslib_1.__importDefault(require_PDFAcroSignature());
    var PDFAcroText_1 = tslib_1.__importDefault(require_PDFAcroText());
    var PDFAcroPushButton_1 = tslib_1.__importDefault(require_PDFAcroPushButton());
    var PDFAcroRadioButton_1 = tslib_1.__importDefault(require_PDFAcroRadioButton());
    var PDFAcroCheckBox_1 = tslib_1.__importDefault(require_PDFAcroCheckBox());
    var PDFAcroComboBox_1 = tslib_1.__importDefault(require_PDFAcroComboBox());
    var PDFAcroListBox_1 = tslib_1.__importDefault(require_PDFAcroListBox());
    var flags_1 = require_flags();
    exports.createPDFAcroFields = function(kidDicts) {
      if (!kidDicts)
        return [];
      var kids = [];
      for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
        var ref = kidDicts.get(idx);
        var dict = kidDicts.lookup(idx);
        if (ref instanceof PDFRef_1.default && dict instanceof PDFDict_1.default) {
          kids.push([exports.createPDFAcroField(dict, ref), ref]);
        }
      }
      return kids;
    };
    exports.createPDFAcroField = function(dict, ref) {
      var isNonTerminal = isNonTerminalAcroField(dict);
      if (isNonTerminal)
        return PDFAcroNonTerminal_1.default.fromDict(dict, ref);
      return createPDFAcroTerminal(dict, ref);
    };
    var isNonTerminalAcroField = function(dict) {
      var kids = dict.lookup(PDFName_1.default.of("Kids"));
      if (kids instanceof PDFArray_1.default) {
        for (var idx = 0, len = kids.size(); idx < len; idx++) {
          var kid = kids.lookup(idx);
          var kidIsField = kid instanceof PDFDict_1.default && kid.has(PDFName_1.default.of("T"));
          if (kidIsField)
            return true;
        }
      }
      return false;
    };
    var createPDFAcroTerminal = function(dict, ref) {
      var ftNameOrRef = getInheritableAttribute(dict, PDFName_1.default.of("FT"));
      var type = dict.context.lookup(ftNameOrRef, PDFName_1.default);
      if (type === PDFName_1.default.of("Btn"))
        return createPDFAcroButton(dict, ref);
      if (type === PDFName_1.default.of("Ch"))
        return createPDFAcroChoice(dict, ref);
      if (type === PDFName_1.default.of("Tx"))
        return PDFAcroText_1.default.fromDict(dict, ref);
      if (type === PDFName_1.default.of("Sig"))
        return PDFAcroSignature_1.default.fromDict(dict, ref);
      return PDFAcroTerminal_1.default.fromDict(dict, ref);
    };
    var createPDFAcroButton = function(dict, ref) {
      var _a;
      var ffNumberOrRef = getInheritableAttribute(dict, PDFName_1.default.of("Ff"));
      var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_1.default);
      var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
      if (flagIsSet(flags, flags_1.AcroButtonFlags.PushButton)) {
        return PDFAcroPushButton_1.default.fromDict(dict, ref);
      } else if (flagIsSet(flags, flags_1.AcroButtonFlags.Radio)) {
        return PDFAcroRadioButton_1.default.fromDict(dict, ref);
      } else {
        return PDFAcroCheckBox_1.default.fromDict(dict, ref);
      }
    };
    var createPDFAcroChoice = function(dict, ref) {
      var _a;
      var ffNumberOrRef = getInheritableAttribute(dict, PDFName_1.default.of("Ff"));
      var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_1.default);
      var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
      if (flagIsSet(flags, flags_1.AcroChoiceFlags.Combo)) {
        return PDFAcroComboBox_1.default.fromDict(dict, ref);
      } else {
        return PDFAcroListBox_1.default.fromDict(dict, ref);
      }
    };
    var flagIsSet = function(flags, flag) {
      return (flags & flag) !== 0;
    };
    var getInheritableAttribute = function(startNode, name) {
      var attribute;
      ascend(startNode, function(node) {
        if (!attribute)
          attribute = node.get(name);
      });
      return attribute;
    };
    var ascend = function(startNode, visitor) {
      visitor(startNode);
      var Parent = startNode.lookupMaybe(PDFName_1.default.of("Parent"), PDFDict_1.default);
      if (Parent)
        ascend(Parent, visitor);
    };
  }
});

// node_modules/pdf-lib/cjs/core/acroform/PDFAcroForm.js
var require_PDFAcroForm = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/PDFAcroForm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroNonTerminal_1 = tslib_1.__importDefault(require_PDFAcroNonTerminal());
    var utils_1 = require_utils3();
    var PDFAcroForm = (
      /** @class */
      function() {
        function PDFAcroForm2(dict) {
          this.dict = dict;
        }
        PDFAcroForm2.prototype.Fields = function() {
          var fields = this.dict.lookup(PDFName_1.default.of("Fields"));
          if (fields instanceof PDFArray_1.default)
            return fields;
          return void 0;
        };
        PDFAcroForm2.prototype.getFields = function() {
          var Fields = this.normalizedEntries().Fields;
          var fields = new Array(Fields.size());
          for (var idx = 0, len = Fields.size(); idx < len; idx++) {
            var ref = Fields.get(idx);
            var dict = Fields.lookup(idx, PDFDict_1.default);
            fields[idx] = [utils_1.createPDFAcroField(dict, ref), ref];
          }
          return fields;
        };
        PDFAcroForm2.prototype.getAllFields = function() {
          var allFields = [];
          var pushFields = function(fields) {
            if (!fields)
              return;
            for (var idx = 0, len = fields.length; idx < len; idx++) {
              var field = fields[idx];
              allFields.push(field);
              var fieldModel = field[0];
              if (fieldModel instanceof PDFAcroNonTerminal_1.default) {
                pushFields(utils_1.createPDFAcroFields(fieldModel.Kids()));
              }
            }
          };
          pushFields(this.getFields());
          return allFields;
        };
        PDFAcroForm2.prototype.addField = function(field) {
          var Fields = this.normalizedEntries().Fields;
          Fields === null || Fields === void 0 ? void 0 : Fields.push(field);
        };
        PDFAcroForm2.prototype.removeField = function(field) {
          var parent = field.getParent();
          var fields = parent === void 0 ? this.normalizedEntries().Fields : parent.Kids();
          var index = fields === null || fields === void 0 ? void 0 : fields.indexOf(field.ref);
          if (fields === void 0 || index === void 0) {
            throw new Error("Tried to remove inexistent field " + field.getFullyQualifiedName());
          }
          fields.remove(index);
          if (parent !== void 0 && fields.size() === 0) {
            this.removeField(parent);
          }
        };
        PDFAcroForm2.prototype.normalizedEntries = function() {
          var Fields = this.Fields();
          if (!Fields) {
            Fields = this.dict.context.obj([]);
            this.dict.set(PDFName_1.default.of("Fields"), Fields);
          }
          return { Fields };
        };
        PDFAcroForm2.fromDict = function(dict) {
          return new PDFAcroForm2(dict);
        };
        PDFAcroForm2.create = function(context) {
          var dict = context.obj({ Fields: [] });
          return new PDFAcroForm2(dict);
        };
        return PDFAcroForm2;
      }()
    );
    exports.default = PDFAcroForm;
  }
});

// node_modules/pdf-lib/cjs/core/acroform/index.js
var require_acroform = __commonJS({
  "node_modules/pdf-lib/cjs/core/acroform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroButton_1 = require_PDFAcroButton();
    Object.defineProperty(exports, "PDFAcroButton", { enumerable: true, get: function() {
      return PDFAcroButton_1.default;
    } });
    var PDFAcroCheckBox_1 = require_PDFAcroCheckBox();
    Object.defineProperty(exports, "PDFAcroCheckBox", { enumerable: true, get: function() {
      return PDFAcroCheckBox_1.default;
    } });
    var PDFAcroChoice_1 = require_PDFAcroChoice();
    Object.defineProperty(exports, "PDFAcroChoice", { enumerable: true, get: function() {
      return PDFAcroChoice_1.default;
    } });
    var PDFAcroComboBox_1 = require_PDFAcroComboBox();
    Object.defineProperty(exports, "PDFAcroComboBox", { enumerable: true, get: function() {
      return PDFAcroComboBox_1.default;
    } });
    var PDFAcroField_1 = require_PDFAcroField();
    Object.defineProperty(exports, "PDFAcroField", { enumerable: true, get: function() {
      return PDFAcroField_1.default;
    } });
    var PDFAcroForm_1 = require_PDFAcroForm();
    Object.defineProperty(exports, "PDFAcroForm", { enumerable: true, get: function() {
      return PDFAcroForm_1.default;
    } });
    var PDFAcroListBox_1 = require_PDFAcroListBox();
    Object.defineProperty(exports, "PDFAcroListBox", { enumerable: true, get: function() {
      return PDFAcroListBox_1.default;
    } });
    var PDFAcroNonTerminal_1 = require_PDFAcroNonTerminal();
    Object.defineProperty(exports, "PDFAcroNonTerminal", { enumerable: true, get: function() {
      return PDFAcroNonTerminal_1.default;
    } });
    var PDFAcroPushButton_1 = require_PDFAcroPushButton();
    Object.defineProperty(exports, "PDFAcroPushButton", { enumerable: true, get: function() {
      return PDFAcroPushButton_1.default;
    } });
    var PDFAcroRadioButton_1 = require_PDFAcroRadioButton();
    Object.defineProperty(exports, "PDFAcroRadioButton", { enumerable: true, get: function() {
      return PDFAcroRadioButton_1.default;
    } });
    var PDFAcroSignature_1 = require_PDFAcroSignature();
    Object.defineProperty(exports, "PDFAcroSignature", { enumerable: true, get: function() {
      return PDFAcroSignature_1.default;
    } });
    var PDFAcroTerminal_1 = require_PDFAcroTerminal();
    Object.defineProperty(exports, "PDFAcroTerminal", { enumerable: true, get: function() {
      return PDFAcroTerminal_1.default;
    } });
    var PDFAcroText_1 = require_PDFAcroText();
    Object.defineProperty(exports, "PDFAcroText", { enumerable: true, get: function() {
      return PDFAcroText_1.default;
    } });
    tslib_1.__exportStar(require_flags(), exports);
    tslib_1.__exportStar(require_utils3(), exports);
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFCatalog.js
var require_PDFCatalog = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFCatalog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var acroform_1 = require_acroform();
    var ViewerPreferences_1 = tslib_1.__importDefault(require_ViewerPreferences());
    var PDFCatalog = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFCatalog2, _super);
        function PDFCatalog2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFCatalog2.prototype.Pages = function() {
          return this.lookup(PDFName_1.default.of("Pages"), PDFDict_1.default);
        };
        PDFCatalog2.prototype.AcroForm = function() {
          return this.lookupMaybe(PDFName_1.default.of("AcroForm"), PDFDict_1.default);
        };
        PDFCatalog2.prototype.getAcroForm = function() {
          var dict = this.AcroForm();
          if (!dict)
            return void 0;
          return acroform_1.PDFAcroForm.fromDict(dict);
        };
        PDFCatalog2.prototype.getOrCreateAcroForm = function() {
          var acroForm = this.getAcroForm();
          if (!acroForm) {
            acroForm = acroform_1.PDFAcroForm.create(this.context);
            var acroFormRef = this.context.register(acroForm.dict);
            this.set(PDFName_1.default.of("AcroForm"), acroFormRef);
          }
          return acroForm;
        };
        PDFCatalog2.prototype.ViewerPreferences = function() {
          return this.lookupMaybe(PDFName_1.default.of("ViewerPreferences"), PDFDict_1.default);
        };
        PDFCatalog2.prototype.getViewerPreferences = function() {
          var dict = this.ViewerPreferences();
          if (!dict)
            return void 0;
          return ViewerPreferences_1.default.fromDict(dict);
        };
        PDFCatalog2.prototype.getOrCreateViewerPreferences = function() {
          var viewerPrefs = this.getViewerPreferences();
          if (!viewerPrefs) {
            viewerPrefs = ViewerPreferences_1.default.create(this.context);
            var viewerPrefsRef = this.context.register(viewerPrefs.dict);
            this.set(PDFName_1.default.of("ViewerPreferences"), viewerPrefsRef);
          }
          return viewerPrefs;
        };
        PDFCatalog2.prototype.insertLeafNode = function(leafRef, index) {
          var pagesRef = this.get(PDFName_1.default.of("Pages"));
          var maybeParentRef = this.Pages().insertLeafNode(leafRef, index);
          return maybeParentRef || pagesRef;
        };
        PDFCatalog2.prototype.removeLeafNode = function(index) {
          this.Pages().removeLeafNode(index);
        };
        PDFCatalog2.withContextAndPages = function(context, pages) {
          var dict = /* @__PURE__ */ new Map();
          dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("Catalog"));
          dict.set(PDFName_1.default.of("Pages"), pages);
          return new PDFCatalog2(dict, context);
        };
        PDFCatalog2.fromMapWithContext = function(map, context) {
          return new PDFCatalog2(map, context);
        };
        return PDFCatalog2;
      }(PDFDict_1.default)
    );
    exports.default = PDFCatalog;
  }
});

// node_modules/pdf-lib/cjs/core/structures/PDFPageTree.js
var require_PDFPageTree = __commonJS({
  "node_modules/pdf-lib/cjs/core/structures/PDFPageTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFPageLeaf_1 = tslib_1.__importDefault(require_PDFPageLeaf());
    var errors_1 = require_errors2();
    var PDFPageTree = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFPageTree2, _super);
        function PDFPageTree2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFPageTree2.prototype.Parent = function() {
          return this.lookup(PDFName_1.default.of("Parent"));
        };
        PDFPageTree2.prototype.Kids = function() {
          return this.lookup(PDFName_1.default.of("Kids"), PDFArray_1.default);
        };
        PDFPageTree2.prototype.Count = function() {
          return this.lookup(PDFName_1.default.of("Count"), PDFNumber_1.default);
        };
        PDFPageTree2.prototype.pushTreeNode = function(treeRef) {
          var Kids = this.Kids();
          Kids.push(treeRef);
        };
        PDFPageTree2.prototype.pushLeafNode = function(leafRef) {
          var Kids = this.Kids();
          this.insertLeafKid(Kids.size(), leafRef);
        };
        PDFPageTree2.prototype.insertLeafNode = function(leafRef, targetIndex) {
          var Kids = this.Kids();
          var Count = this.Count().asNumber();
          if (targetIndex > Count) {
            throw new errors_1.InvalidTargetIndexError(targetIndex, Count);
          }
          var leafsRemainingUntilTarget = targetIndex;
          for (var idx = 0, len = Kids.size(); idx < len; idx++) {
            if (leafsRemainingUntilTarget === 0) {
              this.insertLeafKid(idx, leafRef);
              return void 0;
            }
            var kidRef = Kids.get(idx);
            var kid = this.context.lookup(kidRef);
            if (kid instanceof PDFPageTree2) {
              if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
                return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;
              } else {
                leafsRemainingUntilTarget -= kid.Count().asNumber();
              }
            }
            if (kid instanceof PDFPageLeaf_1.default) {
              leafsRemainingUntilTarget -= 1;
            }
          }
          if (leafsRemainingUntilTarget === 0) {
            this.insertLeafKid(Kids.size(), leafRef);
            return void 0;
          }
          throw new errors_1.CorruptPageTreeError(targetIndex, "insertLeafNode");
        };
        PDFPageTree2.prototype.removeLeafNode = function(targetIndex, prune) {
          if (prune === void 0) {
            prune = true;
          }
          var Kids = this.Kids();
          var Count = this.Count().asNumber();
          if (targetIndex >= Count) {
            throw new errors_1.InvalidTargetIndexError(targetIndex, Count);
          }
          var leafsRemainingUntilTarget = targetIndex;
          for (var idx = 0, len = Kids.size(); idx < len; idx++) {
            var kidRef = Kids.get(idx);
            var kid = this.context.lookup(kidRef);
            if (kid instanceof PDFPageTree2) {
              if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
                kid.removeLeafNode(leafsRemainingUntilTarget, prune);
                if (prune && kid.Kids().size() === 0)
                  Kids.remove(idx);
                return;
              } else {
                leafsRemainingUntilTarget -= kid.Count().asNumber();
              }
            }
            if (kid instanceof PDFPageLeaf_1.default) {
              if (leafsRemainingUntilTarget === 0) {
                this.removeKid(idx);
                return;
              } else {
                leafsRemainingUntilTarget -= 1;
              }
            }
          }
          throw new errors_1.CorruptPageTreeError(targetIndex, "removeLeafNode");
        };
        PDFPageTree2.prototype.ascend = function(visitor) {
          visitor(this);
          var Parent = this.Parent();
          if (Parent)
            Parent.ascend(visitor);
        };
        PDFPageTree2.prototype.traverse = function(visitor) {
          var Kids = this.Kids();
          for (var idx = 0, len = Kids.size(); idx < len; idx++) {
            var kidRef = Kids.get(idx);
            var kid = this.context.lookup(kidRef);
            if (kid instanceof PDFPageTree2)
              kid.traverse(visitor);
            visitor(kid, kidRef);
          }
        };
        PDFPageTree2.prototype.insertLeafKid = function(kidIdx, leafRef) {
          var Kids = this.Kids();
          this.ascend(function(node) {
            var newCount = node.Count().asNumber() + 1;
            node.set(PDFName_1.default.of("Count"), PDFNumber_1.default.of(newCount));
          });
          Kids.insert(kidIdx, leafRef);
        };
        PDFPageTree2.prototype.removeKid = function(kidIdx) {
          var Kids = this.Kids();
          var kid = Kids.lookup(kidIdx);
          if (kid instanceof PDFPageLeaf_1.default) {
            this.ascend(function(node) {
              var newCount = node.Count().asNumber() - 1;
              node.set(PDFName_1.default.of("Count"), PDFNumber_1.default.of(newCount));
            });
          }
          Kids.remove(kidIdx);
        };
        PDFPageTree2.withContext = function(context, parent) {
          var dict = /* @__PURE__ */ new Map();
          dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("Pages"));
          dict.set(PDFName_1.default.of("Kids"), context.obj([]));
          dict.set(PDFName_1.default.of("Count"), context.obj(0));
          if (parent)
            dict.set(PDFName_1.default.of("Parent"), parent);
          return new PDFPageTree2(dict, context);
        };
        PDFPageTree2.fromMapWithContext = function(map, context) {
          return new PDFPageTree2(map, context);
        };
        return PDFPageTree2;
      }(PDFDict_1.default)
    );
    exports.default = PDFPageTree;
  }
});

// node_modules/pdf-lib/cjs/core/syntax/Numeric.js
var require_Numeric = __commonJS({
  "node_modules/pdf-lib/cjs/core/syntax/Numeric.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsNumeric = exports.IsNumericPrefix = exports.IsDigit = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    exports.IsDigit = new Uint8Array(256);
    exports.IsDigit[CharCodes_1.default.Zero] = 1;
    exports.IsDigit[CharCodes_1.default.One] = 1;
    exports.IsDigit[CharCodes_1.default.Two] = 1;
    exports.IsDigit[CharCodes_1.default.Three] = 1;
    exports.IsDigit[CharCodes_1.default.Four] = 1;
    exports.IsDigit[CharCodes_1.default.Five] = 1;
    exports.IsDigit[CharCodes_1.default.Six] = 1;
    exports.IsDigit[CharCodes_1.default.Seven] = 1;
    exports.IsDigit[CharCodes_1.default.Eight] = 1;
    exports.IsDigit[CharCodes_1.default.Nine] = 1;
    exports.IsNumericPrefix = new Uint8Array(256);
    exports.IsNumericPrefix[CharCodes_1.default.Period] = 1;
    exports.IsNumericPrefix[CharCodes_1.default.Plus] = 1;
    exports.IsNumericPrefix[CharCodes_1.default.Minus] = 1;
    exports.IsNumeric = new Uint8Array(256);
    for (idx = 0, len = 256; idx < len; idx++) {
      exports.IsNumeric[idx] = exports.IsDigit[idx] || exports.IsNumericPrefix[idx] ? 1 : 0;
    }
    var idx;
    var len;
  }
});

// node_modules/pdf-lib/cjs/core/parser/BaseParser.js
var require_BaseParser = __commonJS({
  "node_modules/pdf-lib/cjs/core/parser/BaseParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Numeric_1 = require_Numeric();
    var Whitespace_1 = require_Whitespace();
    var utils_1 = require_utils2();
    var Newline = CharCodes_1.default.Newline;
    var CarriageReturn = CharCodes_1.default.CarriageReturn;
    var BaseParser = (
      /** @class */
      function() {
        function BaseParser2(bytes, capNumbers) {
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          this.bytes = bytes;
          this.capNumbers = capNumbers;
        }
        BaseParser2.prototype.parseRawInt = function() {
          var value = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (!Numeric_1.IsDigit[byte])
              break;
            value += utils_1.charFromCode(this.bytes.next());
          }
          var numberValue = Number(value);
          if (!value || !isFinite(numberValue)) {
            throw new errors_1.NumberParsingError(this.bytes.position(), value);
          }
          return numberValue;
        };
        BaseParser2.prototype.parseRawNumber = function() {
          var value = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (!Numeric_1.IsNumeric[byte])
              break;
            value += utils_1.charFromCode(this.bytes.next());
            if (byte === CharCodes_1.default.Period)
              break;
          }
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (!Numeric_1.IsDigit[byte])
              break;
            value += utils_1.charFromCode(this.bytes.next());
          }
          var numberValue = Number(value);
          if (!value || !isFinite(numberValue)) {
            throw new errors_1.NumberParsingError(this.bytes.position(), value);
          }
          if (numberValue > Number.MAX_SAFE_INTEGER) {
            if (this.capNumbers) {
              var msg = "Parsed number that is too large for some PDF readers: " + value + ", using Number.MAX_SAFE_INTEGER instead.";
              console.warn(msg);
              return Number.MAX_SAFE_INTEGER;
            } else {
              var msg = "Parsed number that is too large for some PDF readers: " + value + ", not capping.";
              console.warn(msg);
            }
          }
          return numberValue;
        };
        BaseParser2.prototype.skipWhitespace = function() {
          while (!this.bytes.done() && Whitespace_1.IsWhitespace[this.bytes.peek()]) {
            this.bytes.next();
          }
        };
        BaseParser2.prototype.skipLine = function() {
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (byte === Newline || byte === CarriageReturn)
              return;
            this.bytes.next();
          }
        };
        BaseParser2.prototype.skipComment = function() {
          if (this.bytes.peek() !== CharCodes_1.default.Percent)
            return false;
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (byte === Newline || byte === CarriageReturn)
              return true;
            this.bytes.next();
          }
          return true;
        };
        BaseParser2.prototype.skipWhitespaceAndComments = function() {
          this.skipWhitespace();
          while (this.skipComment())
            this.skipWhitespace();
        };
        BaseParser2.prototype.matchKeyword = function(keyword) {
          var initialOffset = this.bytes.offset();
          for (var idx = 0, len = keyword.length; idx < len; idx++) {
            if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {
              this.bytes.moveTo(initialOffset);
              return false;
            }
          }
          return true;
        };
        return BaseParser2;
      }()
    );
    exports.default = BaseParser;
  }
});

// node_modules/pdf-lib/cjs/core/parser/ByteStream.js
var require_ByteStream = __commonJS({
  "node_modules/pdf-lib/cjs/core/parser/ByteStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var decode_1 = require_decode();
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var ByteStream = (
      /** @class */
      function() {
        function ByteStream2(bytes) {
          this.idx = 0;
          this.line = 0;
          this.column = 0;
          this.bytes = bytes;
          this.length = this.bytes.length;
        }
        ByteStream2.prototype.moveTo = function(offset2) {
          this.idx = offset2;
        };
        ByteStream2.prototype.next = function() {
          var byte = this.bytes[this.idx++];
          if (byte === CharCodes_1.default.Newline) {
            this.line += 1;
            this.column = 0;
          } else {
            this.column += 1;
          }
          return byte;
        };
        ByteStream2.prototype.assertNext = function(expected) {
          if (this.peek() !== expected) {
            throw new errors_1.NextByteAssertionError(this.position(), expected, this.peek());
          }
          return this.next();
        };
        ByteStream2.prototype.peek = function() {
          return this.bytes[this.idx];
        };
        ByteStream2.prototype.peekAhead = function(steps) {
          return this.bytes[this.idx + steps];
        };
        ByteStream2.prototype.peekAt = function(offset2) {
          return this.bytes[offset2];
        };
        ByteStream2.prototype.done = function() {
          return this.idx >= this.length;
        };
        ByteStream2.prototype.offset = function() {
          return this.idx;
        };
        ByteStream2.prototype.slice = function(start2, end2) {
          return this.bytes.slice(start2, end2);
        };
        ByteStream2.prototype.position = function() {
          return { line: this.line, column: this.column, offset: this.idx };
        };
        ByteStream2.of = function(bytes) {
          return new ByteStream2(bytes);
        };
        ByteStream2.fromPDFRawStream = function(rawStream) {
          return ByteStream2.of(decode_1.decodePDFRawStream(rawStream).decode());
        };
        return ByteStream2;
      }()
    );
    exports.default = ByteStream;
  }
});

// node_modules/pdf-lib/cjs/core/syntax/Keywords.js
var require_Keywords = __commonJS({
  "node_modules/pdf-lib/cjs/core/syntax/Keywords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Keywords = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Space = CharCodes_1.default.Space;
    var CarriageReturn = CharCodes_1.default.CarriageReturn;
    var Newline = CharCodes_1.default.Newline;
    var stream = [
      CharCodes_1.default.s,
      CharCodes_1.default.t,
      CharCodes_1.default.r,
      CharCodes_1.default.e,
      CharCodes_1.default.a,
      CharCodes_1.default.m
    ];
    var endstream = [
      CharCodes_1.default.e,
      CharCodes_1.default.n,
      CharCodes_1.default.d,
      CharCodes_1.default.s,
      CharCodes_1.default.t,
      CharCodes_1.default.r,
      CharCodes_1.default.e,
      CharCodes_1.default.a,
      CharCodes_1.default.m
    ];
    exports.Keywords = {
      header: [
        CharCodes_1.default.Percent,
        CharCodes_1.default.P,
        CharCodes_1.default.D,
        CharCodes_1.default.F,
        CharCodes_1.default.Dash
      ],
      eof: [
        CharCodes_1.default.Percent,
        CharCodes_1.default.Percent,
        CharCodes_1.default.E,
        CharCodes_1.default.O,
        CharCodes_1.default.F
      ],
      obj: [CharCodes_1.default.o, CharCodes_1.default.b, CharCodes_1.default.j],
      endobj: [
        CharCodes_1.default.e,
        CharCodes_1.default.n,
        CharCodes_1.default.d,
        CharCodes_1.default.o,
        CharCodes_1.default.b,
        CharCodes_1.default.j
      ],
      xref: [CharCodes_1.default.x, CharCodes_1.default.r, CharCodes_1.default.e, CharCodes_1.default.f],
      trailer: [
        CharCodes_1.default.t,
        CharCodes_1.default.r,
        CharCodes_1.default.a,
        CharCodes_1.default.i,
        CharCodes_1.default.l,
        CharCodes_1.default.e,
        CharCodes_1.default.r
      ],
      startxref: [
        CharCodes_1.default.s,
        CharCodes_1.default.t,
        CharCodes_1.default.a,
        CharCodes_1.default.r,
        CharCodes_1.default.t,
        CharCodes_1.default.x,
        CharCodes_1.default.r,
        CharCodes_1.default.e,
        CharCodes_1.default.f
      ],
      true: [CharCodes_1.default.t, CharCodes_1.default.r, CharCodes_1.default.u, CharCodes_1.default.e],
      false: [CharCodes_1.default.f, CharCodes_1.default.a, CharCodes_1.default.l, CharCodes_1.default.s, CharCodes_1.default.e],
      null: [CharCodes_1.default.n, CharCodes_1.default.u, CharCodes_1.default.l, CharCodes_1.default.l],
      stream,
      streamEOF1: tslib_1.__spreadArrays(stream, [Space, CarriageReturn, Newline]),
      streamEOF2: tslib_1.__spreadArrays(stream, [CarriageReturn, Newline]),
      streamEOF3: tslib_1.__spreadArrays(stream, [CarriageReturn]),
      streamEOF4: tslib_1.__spreadArrays(stream, [Newline]),
      endstream,
      EOF1endstream: tslib_1.__spreadArrays([CarriageReturn, Newline], endstream),
      EOF2endstream: tslib_1.__spreadArrays([CarriageReturn], endstream),
      EOF3endstream: tslib_1.__spreadArrays([Newline], endstream)
    };
  }
});

// node_modules/pdf-lib/cjs/core/parser/PDFObjectParser.js
var require_PDFObjectParser = __commonJS({
  "node_modules/pdf-lib/cjs/core/parser/PDFObjectParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFBool_1 = tslib_1.__importDefault(require_PDFBool());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNull_1 = tslib_1.__importDefault(require_PDFNull());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var BaseParser_1 = tslib_1.__importDefault(require_BaseParser());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFCatalog_1 = tslib_1.__importDefault(require_PDFCatalog());
    var PDFPageLeaf_1 = tslib_1.__importDefault(require_PDFPageLeaf());
    var PDFPageTree_1 = tslib_1.__importDefault(require_PDFPageTree());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Delimiters_1 = require_Delimiters();
    var Keywords_1 = require_Keywords();
    var Numeric_1 = require_Numeric();
    var Whitespace_1 = require_Whitespace();
    var utils_1 = require_utils2();
    var PDFObjectParser = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectParser2, _super);
        function PDFObjectParser2(byteStream, context, capNumbers) {
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          var _this = _super.call(this, byteStream, capNumbers) || this;
          _this.context = context;
          return _this;
        }
        PDFObjectParser2.prototype.parseObject = function() {
          this.skipWhitespaceAndComments();
          if (this.matchKeyword(Keywords_1.Keywords.true))
            return PDFBool_1.default.True;
          if (this.matchKeyword(Keywords_1.Keywords.false))
            return PDFBool_1.default.False;
          if (this.matchKeyword(Keywords_1.Keywords.null))
            return PDFNull_1.default;
          var byte = this.bytes.peek();
          if (byte === CharCodes_1.default.LessThan && this.bytes.peekAhead(1) === CharCodes_1.default.LessThan) {
            return this.parseDictOrStream();
          }
          if (byte === CharCodes_1.default.LessThan)
            return this.parseHexString();
          if (byte === CharCodes_1.default.LeftParen)
            return this.parseString();
          if (byte === CharCodes_1.default.ForwardSlash)
            return this.parseName();
          if (byte === CharCodes_1.default.LeftSquareBracket)
            return this.parseArray();
          if (Numeric_1.IsNumeric[byte])
            return this.parseNumberOrRef();
          throw new errors_1.PDFObjectParsingError(this.bytes.position(), byte);
        };
        PDFObjectParser2.prototype.parseNumberOrRef = function() {
          var firstNum = this.parseRawNumber();
          this.skipWhitespaceAndComments();
          var lookaheadStart = this.bytes.offset();
          if (Numeric_1.IsDigit[this.bytes.peek()]) {
            var secondNum = this.parseRawNumber();
            this.skipWhitespaceAndComments();
            if (this.bytes.peek() === CharCodes_1.default.R) {
              this.bytes.assertNext(CharCodes_1.default.R);
              return PDFRef_1.default.of(firstNum, secondNum);
            }
          }
          this.bytes.moveTo(lookaheadStart);
          return PDFNumber_1.default.of(firstNum);
        };
        PDFObjectParser2.prototype.parseHexString = function() {
          var value = "";
          this.bytes.assertNext(CharCodes_1.default.LessThan);
          while (!this.bytes.done() && this.bytes.peek() !== CharCodes_1.default.GreaterThan) {
            value += utils_1.charFromCode(this.bytes.next());
          }
          this.bytes.assertNext(CharCodes_1.default.GreaterThan);
          return PDFHexString_1.default.of(value);
        };
        PDFObjectParser2.prototype.parseString = function() {
          var nestingLvl = 0;
          var isEscaped = false;
          var value = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.next();
            value += utils_1.charFromCode(byte);
            if (!isEscaped) {
              if (byte === CharCodes_1.default.LeftParen)
                nestingLvl += 1;
              if (byte === CharCodes_1.default.RightParen)
                nestingLvl -= 1;
            }
            if (byte === CharCodes_1.default.BackSlash) {
              isEscaped = !isEscaped;
            } else if (isEscaped) {
              isEscaped = false;
            }
            if (nestingLvl === 0) {
              return PDFString_1.default.of(value.substring(1, value.length - 1));
            }
          }
          throw new errors_1.UnbalancedParenthesisError(this.bytes.position());
        };
        PDFObjectParser2.prototype.parseName = function() {
          this.bytes.assertNext(CharCodes_1.default.ForwardSlash);
          var name = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (Whitespace_1.IsWhitespace[byte] || Delimiters_1.IsDelimiter[byte])
              break;
            name += utils_1.charFromCode(byte);
            this.bytes.next();
          }
          return PDFName_1.default.of(name);
        };
        PDFObjectParser2.prototype.parseArray = function() {
          this.bytes.assertNext(CharCodes_1.default.LeftSquareBracket);
          this.skipWhitespaceAndComments();
          var pdfArray = PDFArray_1.default.withContext(this.context);
          while (this.bytes.peek() !== CharCodes_1.default.RightSquareBracket) {
            var element = this.parseObject();
            pdfArray.push(element);
            this.skipWhitespaceAndComments();
          }
          this.bytes.assertNext(CharCodes_1.default.RightSquareBracket);
          return pdfArray;
        };
        PDFObjectParser2.prototype.parseDict = function() {
          this.bytes.assertNext(CharCodes_1.default.LessThan);
          this.bytes.assertNext(CharCodes_1.default.LessThan);
          this.skipWhitespaceAndComments();
          var dict = /* @__PURE__ */ new Map();
          while (!this.bytes.done() && this.bytes.peek() !== CharCodes_1.default.GreaterThan && this.bytes.peekAhead(1) !== CharCodes_1.default.GreaterThan) {
            var key = this.parseName();
            var value = this.parseObject();
            dict.set(key, value);
            this.skipWhitespaceAndComments();
          }
          this.skipWhitespaceAndComments();
          this.bytes.assertNext(CharCodes_1.default.GreaterThan);
          this.bytes.assertNext(CharCodes_1.default.GreaterThan);
          var Type = dict.get(PDFName_1.default.of("Type"));
          if (Type === PDFName_1.default.of("Catalog")) {
            return PDFCatalog_1.default.fromMapWithContext(dict, this.context);
          } else if (Type === PDFName_1.default.of("Pages")) {
            return PDFPageTree_1.default.fromMapWithContext(dict, this.context);
          } else if (Type === PDFName_1.default.of("Page")) {
            return PDFPageLeaf_1.default.fromMapWithContext(dict, this.context);
          } else {
            return PDFDict_1.default.fromMapWithContext(dict, this.context);
          }
        };
        PDFObjectParser2.prototype.parseDictOrStream = function() {
          var startPos = this.bytes.position();
          var dict = this.parseDict();
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.streamEOF1) && !this.matchKeyword(Keywords_1.Keywords.streamEOF2) && !this.matchKeyword(Keywords_1.Keywords.streamEOF3) && !this.matchKeyword(Keywords_1.Keywords.streamEOF4) && !this.matchKeyword(Keywords_1.Keywords.stream)) {
            return dict;
          }
          var start2 = this.bytes.offset();
          var end2;
          var Length = dict.get(PDFName_1.default.of("Length"));
          if (Length instanceof PDFNumber_1.default) {
            end2 = start2 + Length.asNumber();
            this.bytes.moveTo(end2);
            this.skipWhitespaceAndComments();
            if (!this.matchKeyword(Keywords_1.Keywords.endstream)) {
              this.bytes.moveTo(start2);
              end2 = this.findEndOfStreamFallback(startPos);
            }
          } else {
            end2 = this.findEndOfStreamFallback(startPos);
          }
          var contents = this.bytes.slice(start2, end2);
          return PDFRawStream_1.default.of(dict, contents);
        };
        PDFObjectParser2.prototype.findEndOfStreamFallback = function(startPos) {
          var nestingLvl = 1;
          var end2 = this.bytes.offset();
          while (!this.bytes.done()) {
            end2 = this.bytes.offset();
            if (this.matchKeyword(Keywords_1.Keywords.stream)) {
              nestingLvl += 1;
            } else if (this.matchKeyword(Keywords_1.Keywords.EOF1endstream) || this.matchKeyword(Keywords_1.Keywords.EOF2endstream) || this.matchKeyword(Keywords_1.Keywords.EOF3endstream) || this.matchKeyword(Keywords_1.Keywords.endstream)) {
              nestingLvl -= 1;
            } else {
              this.bytes.next();
            }
            if (nestingLvl === 0)
              break;
          }
          if (nestingLvl !== 0)
            throw new errors_1.PDFStreamParsingError(startPos);
          return end2;
        };
        PDFObjectParser2.forBytes = function(bytes, context, capNumbers) {
          return new PDFObjectParser2(ByteStream_1.default.of(bytes), context, capNumbers);
        };
        PDFObjectParser2.forByteStream = function(byteStream, context, capNumbers) {
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          return new PDFObjectParser2(byteStream, context, capNumbers);
        };
        return PDFObjectParser2;
      }(BaseParser_1.default)
    );
    exports.default = PDFObjectParser;
  }
});

// node_modules/pdf-lib/cjs/core/parser/PDFObjectStreamParser.js
var require_PDFObjectStreamParser = __commonJS({
  "node_modules/pdf-lib/cjs/core/parser/PDFObjectStreamParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFObjectParser_1 = tslib_1.__importDefault(require_PDFObjectParser());
    var utils_1 = require_utils2();
    var PDFObjectStreamParser = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectStreamParser2, _super);
        function PDFObjectStreamParser2(rawStream, shouldWaitForTick) {
          var _this = _super.call(this, ByteStream_1.default.fromPDFRawStream(rawStream), rawStream.dict.context) || this;
          var dict = rawStream.dict;
          _this.alreadyParsed = false;
          _this.shouldWaitForTick = shouldWaitForTick || function() {
            return false;
          };
          _this.firstOffset = dict.lookup(PDFName_1.default.of("First"), PDFNumber_1.default).asNumber();
          _this.objectCount = dict.lookup(PDFName_1.default.of("N"), PDFNumber_1.default).asNumber();
          return _this;
        }
        PDFObjectStreamParser2.prototype.parseIntoContext = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var offsetsAndObjectNumbers, idx, len, _a, objectNumber, offset2, object, ref;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this.alreadyParsed) {
                    throw new errors_1.ReparseError("PDFObjectStreamParser", "parseIntoContext");
                  }
                  this.alreadyParsed = true;
                  offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();
                  idx = 0, len = offsetsAndObjectNumbers.length;
                  _b.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  _a = offsetsAndObjectNumbers[idx], objectNumber = _a.objectNumber, offset2 = _a.offset;
                  this.bytes.moveTo(this.firstOffset + offset2);
                  object = this.parseObject();
                  ref = PDFRef_1.default.of(objectNumber, 0);
                  this.context.assign(ref, object);
                  if (!this.shouldWaitForTick())
                    return [3, 3];
                  return [4, utils_1.waitForTick()];
                case 2:
                  _b.sent();
                  _b.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFObjectStreamParser2.prototype.parseOffsetsAndObjectNumbers = function() {
          var offsetsAndObjectNumbers = [];
          for (var idx = 0, len = this.objectCount; idx < len; idx++) {
            this.skipWhitespaceAndComments();
            var objectNumber = this.parseRawInt();
            this.skipWhitespaceAndComments();
            var offset2 = this.parseRawInt();
            offsetsAndObjectNumbers.push({ objectNumber, offset: offset2 });
          }
          return offsetsAndObjectNumbers;
        };
        PDFObjectStreamParser2.forStream = function(rawStream, shouldWaitForTick) {
          return new PDFObjectStreamParser2(rawStream, shouldWaitForTick);
        };
        return PDFObjectStreamParser2;
      }(PDFObjectParser_1.default)
    );
    exports.default = PDFObjectStreamParser;
  }
});

// node_modules/pdf-lib/cjs/core/parser/PDFXRefStreamParser.js
var require_PDFXRefStreamParser = __commonJS({
  "node_modules/pdf-lib/cjs/core/parser/PDFXRefStreamParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFXRefStreamParser = (
      /** @class */
      function() {
        function PDFXRefStreamParser2(rawStream) {
          this.alreadyParsed = false;
          this.dict = rawStream.dict;
          this.bytes = ByteStream_1.default.fromPDFRawStream(rawStream);
          this.context = this.dict.context;
          var Size = this.dict.lookup(PDFName_1.default.of("Size"), PDFNumber_1.default);
          var Index = this.dict.lookup(PDFName_1.default.of("Index"));
          if (Index instanceof PDFArray_1.default) {
            this.subsections = [];
            for (var idx = 0, len = Index.size(); idx < len; idx += 2) {
              var firstObjectNumber = Index.lookup(idx + 0, PDFNumber_1.default).asNumber();
              var length_1 = Index.lookup(idx + 1, PDFNumber_1.default).asNumber();
              this.subsections.push({ firstObjectNumber, length: length_1 });
            }
          } else {
            this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];
          }
          var W = this.dict.lookup(PDFName_1.default.of("W"), PDFArray_1.default);
          this.byteWidths = [-1, -1, -1];
          for (var idx = 0, len = W.size(); idx < len; idx++) {
            this.byteWidths[idx] = W.lookup(idx, PDFNumber_1.default).asNumber();
          }
        }
        PDFXRefStreamParser2.prototype.parseIntoContext = function() {
          if (this.alreadyParsed) {
            throw new errors_1.ReparseError("PDFXRefStreamParser", "parseIntoContext");
          }
          this.alreadyParsed = true;
          this.context.trailerInfo = {
            Root: this.dict.get(PDFName_1.default.of("Root")),
            Encrypt: this.dict.get(PDFName_1.default.of("Encrypt")),
            Info: this.dict.get(PDFName_1.default.of("Info")),
            ID: this.dict.get(PDFName_1.default.of("ID"))
          };
          var entries = this.parseEntries();
          return entries;
        };
        PDFXRefStreamParser2.prototype.parseEntries = function() {
          var entries = [];
          var _a = this.byteWidths, typeFieldWidth = _a[0], offsetFieldWidth = _a[1], genFieldWidth = _a[2];
          for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {
            var _b = this.subsections[subsectionIdx], firstObjectNumber = _b.firstObjectNumber, length_2 = _b.length;
            for (var objIdx = 0; objIdx < length_2; objIdx++) {
              var type = 0;
              for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {
                type = type << 8 | this.bytes.next();
              }
              var offset2 = 0;
              for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {
                offset2 = offset2 << 8 | this.bytes.next();
              }
              var generationNumber = 0;
              for (var idx = 0, len = genFieldWidth; idx < len; idx++) {
                generationNumber = generationNumber << 8 | this.bytes.next();
              }
              if (typeFieldWidth === 0)
                type = 1;
              var objectNumber = firstObjectNumber + objIdx;
              var entry = {
                ref: PDFRef_1.default.of(objectNumber, generationNumber),
                offset: offset2,
                deleted: type === 0,
                inObjectStream: type === 2
              };
              entries.push(entry);
            }
          }
          return entries;
        };
        PDFXRefStreamParser2.forStream = function(rawStream) {
          return new PDFXRefStreamParser2(rawStream);
        };
        return PDFXRefStreamParser2;
      }()
    );
    exports.default = PDFXRefStreamParser;
  }
});

// node_modules/pdf-lib/cjs/core/parser/PDFParser.js
var require_PDFParser = __commonJS({
  "node_modules/pdf-lib/cjs/core/parser/PDFParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFCrossRefSection_1 = tslib_1.__importDefault(require_PDFCrossRefSection());
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var PDFTrailer_1 = tslib_1.__importDefault(require_PDFTrailer());
    var errors_1 = require_errors2();
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFInvalidObject_1 = tslib_1.__importDefault(require_PDFInvalidObject());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFObjectParser_1 = tslib_1.__importDefault(require_PDFObjectParser());
    var PDFObjectStreamParser_1 = tslib_1.__importDefault(require_PDFObjectStreamParser());
    var PDFXRefStreamParser_1 = tslib_1.__importDefault(require_PDFXRefStreamParser());
    var PDFContext_1 = tslib_1.__importDefault(require_PDFContext());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Keywords_1 = require_Keywords();
    var Numeric_1 = require_Numeric();
    var utils_1 = require_utils2();
    var PDFParser = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFParser2, _super);
        function PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
          if (objectsPerTick === void 0) {
            objectsPerTick = Infinity;
          }
          if (throwOnInvalidObject === void 0) {
            throwOnInvalidObject = false;
          }
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          var _this = _super.call(this, ByteStream_1.default.of(pdfBytes), PDFContext_1.default.create(), capNumbers) || this;
          _this.alreadyParsed = false;
          _this.parsedObjects = 0;
          _this.shouldWaitForTick = function() {
            _this.parsedObjects += 1;
            return _this.parsedObjects % _this.objectsPerTick === 0;
          };
          _this.objectsPerTick = objectsPerTick;
          _this.throwOnInvalidObject = throwOnInvalidObject;
          return _this;
        }
        PDFParser2.prototype.parseDocument = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var prevOffset, offset2;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (this.alreadyParsed) {
                    throw new errors_1.ReparseError("PDFParser", "parseDocument");
                  }
                  this.alreadyParsed = true;
                  this.context.header = this.parseHeader();
                  _a.label = 1;
                case 1:
                  if (!!this.bytes.done())
                    return [3, 3];
                  return [4, this.parseDocumentSection()];
                case 2:
                  _a.sent();
                  offset2 = this.bytes.offset();
                  if (offset2 === prevOffset) {
                    throw new errors_1.StalledParserError(this.bytes.position());
                  }
                  prevOffset = offset2;
                  return [3, 1];
                case 3:
                  this.maybeRecoverRoot();
                  if (this.context.lookup(PDFRef_1.default.of(0))) {
                    console.warn("Removing parsed object: 0 0 R");
                    this.context.delete(PDFRef_1.default.of(0));
                  }
                  return [2, this.context];
              }
            });
          });
        };
        PDFParser2.prototype.maybeRecoverRoot = function() {
          var isValidCatalog = function(obj) {
            return obj instanceof PDFDict_1.default && obj.lookup(PDFName_1.default.of("Type")) === PDFName_1.default.of("Catalog");
          };
          var catalog = this.context.lookup(this.context.trailerInfo.Root);
          if (!isValidCatalog(catalog)) {
            var indirectObjects = this.context.enumerateIndirectObjects();
            for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {
              var _a = indirectObjects[idx], ref = _a[0], object = _a[1];
              if (isValidCatalog(object)) {
                this.context.trailerInfo.Root = ref;
              }
            }
          }
        };
        PDFParser2.prototype.parseHeader = function() {
          while (!this.bytes.done()) {
            if (this.matchKeyword(Keywords_1.Keywords.header)) {
              var major = this.parseRawInt();
              this.bytes.assertNext(CharCodes_1.default.Period);
              var minor = this.parseRawInt();
              var header = PDFHeader_1.default.forVersion(major, minor);
              this.skipBinaryHeaderComment();
              return header;
            }
            this.bytes.next();
          }
          throw new errors_1.MissingPDFHeaderError(this.bytes.position());
        };
        PDFParser2.prototype.parseIndirectObjectHeader = function() {
          this.skipWhitespaceAndComments();
          var objectNumber = this.parseRawInt();
          this.skipWhitespaceAndComments();
          var generationNumber = this.parseRawInt();
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.obj)) {
            throw new errors_1.MissingKeywordError(this.bytes.position(), Keywords_1.Keywords.obj);
          }
          return PDFRef_1.default.of(objectNumber, generationNumber);
        };
        PDFParser2.prototype.matchIndirectObjectHeader = function() {
          var initialOffset = this.bytes.offset();
          try {
            this.parseIndirectObjectHeader();
            return true;
          } catch (e) {
            this.bytes.moveTo(initialOffset);
            return false;
          }
        };
        PDFParser2.prototype.parseIndirectObject = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var ref, object;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  ref = this.parseIndirectObjectHeader();
                  this.skipWhitespaceAndComments();
                  object = this.parseObject();
                  this.skipWhitespaceAndComments();
                  this.matchKeyword(Keywords_1.Keywords.endobj);
                  if (!(object instanceof PDFRawStream_1.default && object.dict.lookup(PDFName_1.default.of("Type")) === PDFName_1.default.of("ObjStm")))
                    return [3, 2];
                  return [4, PDFObjectStreamParser_1.default.forStream(object, this.shouldWaitForTick).parseIntoContext()];
                case 1:
                  _a.sent();
                  return [3, 3];
                case 2:
                  if (object instanceof PDFRawStream_1.default && object.dict.lookup(PDFName_1.default.of("Type")) === PDFName_1.default.of("XRef")) {
                    PDFXRefStreamParser_1.default.forStream(object).parseIntoContext();
                  } else {
                    this.context.assign(ref, object);
                  }
                  _a.label = 3;
                case 3:
                  return [2, ref];
              }
            });
          });
        };
        PDFParser2.prototype.tryToParseInvalidIndirectObject = function() {
          var startPos = this.bytes.position();
          var msg = "Trying to parse invalid object: " + JSON.stringify(startPos) + ")";
          if (this.throwOnInvalidObject)
            throw new Error(msg);
          console.warn(msg);
          var ref = this.parseIndirectObjectHeader();
          console.warn("Invalid object ref: " + ref);
          this.skipWhitespaceAndComments();
          var start2 = this.bytes.offset();
          var failed = true;
          while (!this.bytes.done()) {
            if (this.matchKeyword(Keywords_1.Keywords.endobj)) {
              failed = false;
            }
            if (!failed)
              break;
            this.bytes.next();
          }
          if (failed)
            throw new errors_1.PDFInvalidObjectParsingError(startPos);
          var end2 = this.bytes.offset() - Keywords_1.Keywords.endobj.length;
          var object = PDFInvalidObject_1.default.of(this.bytes.slice(start2, end2));
          this.context.assign(ref, object);
          return ref;
        };
        PDFParser2.prototype.parseIndirectObjects = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var initialOffset, e_1;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.skipWhitespaceAndComments();
                  _a.label = 1;
                case 1:
                  if (!(!this.bytes.done() && Numeric_1.IsDigit[this.bytes.peek()]))
                    return [3, 8];
                  initialOffset = this.bytes.offset();
                  _a.label = 2;
                case 2:
                  _a.trys.push([2, 4, , 5]);
                  return [4, this.parseIndirectObject()];
                case 3:
                  _a.sent();
                  return [3, 5];
                case 4:
                  e_1 = _a.sent();
                  this.bytes.moveTo(initialOffset);
                  this.tryToParseInvalidIndirectObject();
                  return [3, 5];
                case 5:
                  this.skipWhitespaceAndComments();
                  this.skipJibberish();
                  if (!this.shouldWaitForTick())
                    return [3, 7];
                  return [4, utils_1.waitForTick()];
                case 6:
                  _a.sent();
                  _a.label = 7;
                case 7:
                  return [3, 1];
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFParser2.prototype.maybeParseCrossRefSection = function() {
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.xref))
            return;
          this.skipWhitespaceAndComments();
          var objectNumber = -1;
          var xref = PDFCrossRefSection_1.default.createEmpty();
          while (!this.bytes.done() && Numeric_1.IsDigit[this.bytes.peek()]) {
            var firstInt = this.parseRawInt();
            this.skipWhitespaceAndComments();
            var secondInt = this.parseRawInt();
            this.skipWhitespaceAndComments();
            var byte = this.bytes.peek();
            if (byte === CharCodes_1.default.n || byte === CharCodes_1.default.f) {
              var ref = PDFRef_1.default.of(objectNumber, secondInt);
              if (this.bytes.next() === CharCodes_1.default.n) {
                xref.addEntry(ref, firstInt);
              } else {
                xref.addDeletedEntry(ref, firstInt);
              }
              objectNumber += 1;
            } else {
              objectNumber = firstInt;
            }
            this.skipWhitespaceAndComments();
          }
          return xref;
        };
        PDFParser2.prototype.maybeParseTrailerDict = function() {
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.trailer))
            return;
          this.skipWhitespaceAndComments();
          var dict = this.parseDict();
          var context = this.context;
          context.trailerInfo = {
            Root: dict.get(PDFName_1.default.of("Root")) || context.trailerInfo.Root,
            Encrypt: dict.get(PDFName_1.default.of("Encrypt")) || context.trailerInfo.Encrypt,
            Info: dict.get(PDFName_1.default.of("Info")) || context.trailerInfo.Info,
            ID: dict.get(PDFName_1.default.of("ID")) || context.trailerInfo.ID
          };
        };
        PDFParser2.prototype.maybeParseTrailer = function() {
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.startxref))
            return;
          this.skipWhitespaceAndComments();
          var offset2 = this.parseRawInt();
          this.skipWhitespace();
          this.matchKeyword(Keywords_1.Keywords.eof);
          this.skipWhitespaceAndComments();
          this.matchKeyword(Keywords_1.Keywords.eof);
          this.skipWhitespaceAndComments();
          return PDFTrailer_1.default.forLastCrossRefSectionOffset(offset2);
        };
        PDFParser2.prototype.parseDocumentSection = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.parseIndirectObjects()];
                case 1:
                  _a.sent();
                  this.maybeParseCrossRefSection();
                  this.maybeParseTrailerDict();
                  this.maybeParseTrailer();
                  this.skipJibberish();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFParser2.prototype.skipJibberish = function() {
          this.skipWhitespaceAndComments();
          while (!this.bytes.done()) {
            var initialOffset = this.bytes.offset();
            var byte = this.bytes.peek();
            var isAlphaNumeric = byte >= CharCodes_1.default.Space && byte <= CharCodes_1.default.Tilde;
            if (isAlphaNumeric) {
              if (this.matchKeyword(Keywords_1.Keywords.xref) || this.matchKeyword(Keywords_1.Keywords.trailer) || this.matchKeyword(Keywords_1.Keywords.startxref) || this.matchIndirectObjectHeader()) {
                this.bytes.moveTo(initialOffset);
                break;
              }
            }
            this.bytes.next();
          }
        };
        PDFParser2.prototype.skipBinaryHeaderComment = function() {
          this.skipWhitespaceAndComments();
          try {
            var initialOffset = this.bytes.offset();
            this.parseIndirectObjectHeader();
            this.bytes.moveTo(initialOffset);
          } catch (e) {
            this.bytes.next();
            this.skipWhitespaceAndComments();
          }
        };
        PDFParser2.forBytesWithOptions = function(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
          return new PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);
        };
        return PDFParser2;
      }(PDFObjectParser_1.default)
    );
    exports.default = PDFParser;
  }
});

// node_modules/pdf-lib/cjs/core/annotation/flags.js
var require_flags2 = __commonJS({
  "node_modules/pdf-lib/cjs/core/annotation/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnnotationFlags = void 0;
    var flag = function(bitIndex) {
      return 1 << bitIndex;
    };
    var AnnotationFlags;
    (function(AnnotationFlags2) {
      AnnotationFlags2[AnnotationFlags2["Invisible"] = flag(1 - 1)] = "Invisible";
      AnnotationFlags2[AnnotationFlags2["Hidden"] = flag(2 - 1)] = "Hidden";
      AnnotationFlags2[AnnotationFlags2["Print"] = flag(3 - 1)] = "Print";
      AnnotationFlags2[AnnotationFlags2["NoZoom"] = flag(4 - 1)] = "NoZoom";
      AnnotationFlags2[AnnotationFlags2["NoRotate"] = flag(5 - 1)] = "NoRotate";
      AnnotationFlags2[AnnotationFlags2["NoView"] = flag(6 - 1)] = "NoView";
      AnnotationFlags2[AnnotationFlags2["ReadOnly"] = flag(7 - 1)] = "ReadOnly";
      AnnotationFlags2[AnnotationFlags2["Locked"] = flag(8 - 1)] = "Locked";
      AnnotationFlags2[AnnotationFlags2["ToggleNoView"] = flag(9 - 1)] = "ToggleNoView";
      AnnotationFlags2[AnnotationFlags2["LockedContents"] = flag(10 - 1)] = "LockedContents";
    })(AnnotationFlags = exports.AnnotationFlags || (exports.AnnotationFlags = {}));
  }
});

// node_modules/pdf-lib/cjs/core/annotation/index.js
var require_annotation = __commonJS({
  "node_modules/pdf-lib/cjs/core/annotation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAnnotation_1 = require_PDFAnnotation();
    Object.defineProperty(exports, "PDFAnnotation", { enumerable: true, get: function() {
      return PDFAnnotation_1.default;
    } });
    var PDFWidgetAnnotation_1 = require_PDFWidgetAnnotation();
    Object.defineProperty(exports, "PDFWidgetAnnotation", { enumerable: true, get: function() {
      return PDFWidgetAnnotation_1.default;
    } });
    var AppearanceCharacteristics_1 = require_AppearanceCharacteristics();
    Object.defineProperty(exports, "AppearanceCharacteristics", { enumerable: true, get: function() {
      return AppearanceCharacteristics_1.default;
    } });
    tslib_1.__exportStar(require_flags2(), exports);
  }
});

// node_modules/pdf-lib/cjs/core/index.js
var require_core = __commonJS({
  "node_modules/pdf-lib/cjs/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_errors2(), exports);
    var CharCodes_1 = require_CharCodes();
    Object.defineProperty(exports, "CharCodes", { enumerable: true, get: function() {
      return CharCodes_1.default;
    } });
    var PDFContext_1 = require_PDFContext();
    Object.defineProperty(exports, "PDFContext", { enumerable: true, get: function() {
      return PDFContext_1.default;
    } });
    var PDFObjectCopier_1 = require_PDFObjectCopier();
    Object.defineProperty(exports, "PDFObjectCopier", { enumerable: true, get: function() {
      return PDFObjectCopier_1.default;
    } });
    var PDFWriter_1 = require_PDFWriter();
    Object.defineProperty(exports, "PDFWriter", { enumerable: true, get: function() {
      return PDFWriter_1.default;
    } });
    var PDFStreamWriter_1 = require_PDFStreamWriter();
    Object.defineProperty(exports, "PDFStreamWriter", { enumerable: true, get: function() {
      return PDFStreamWriter_1.default;
    } });
    var PDFHeader_1 = require_PDFHeader();
    Object.defineProperty(exports, "PDFHeader", { enumerable: true, get: function() {
      return PDFHeader_1.default;
    } });
    var PDFTrailer_1 = require_PDFTrailer();
    Object.defineProperty(exports, "PDFTrailer", { enumerable: true, get: function() {
      return PDFTrailer_1.default;
    } });
    var PDFTrailerDict_1 = require_PDFTrailerDict();
    Object.defineProperty(exports, "PDFTrailerDict", { enumerable: true, get: function() {
      return PDFTrailerDict_1.default;
    } });
    var PDFCrossRefSection_1 = require_PDFCrossRefSection();
    Object.defineProperty(exports, "PDFCrossRefSection", { enumerable: true, get: function() {
      return PDFCrossRefSection_1.default;
    } });
    var StandardFontEmbedder_1 = require_StandardFontEmbedder();
    Object.defineProperty(exports, "StandardFontEmbedder", { enumerable: true, get: function() {
      return StandardFontEmbedder_1.default;
    } });
    var CustomFontEmbedder_1 = require_CustomFontEmbedder();
    Object.defineProperty(exports, "CustomFontEmbedder", { enumerable: true, get: function() {
      return CustomFontEmbedder_1.default;
    } });
    var CustomFontSubsetEmbedder_1 = require_CustomFontSubsetEmbedder();
    Object.defineProperty(exports, "CustomFontSubsetEmbedder", { enumerable: true, get: function() {
      return CustomFontSubsetEmbedder_1.default;
    } });
    var FileEmbedder_1 = require_FileEmbedder();
    Object.defineProperty(exports, "FileEmbedder", { enumerable: true, get: function() {
      return FileEmbedder_1.default;
    } });
    Object.defineProperty(exports, "AFRelationship", { enumerable: true, get: function() {
      return FileEmbedder_1.AFRelationship;
    } });
    var JpegEmbedder_1 = require_JpegEmbedder();
    Object.defineProperty(exports, "JpegEmbedder", { enumerable: true, get: function() {
      return JpegEmbedder_1.default;
    } });
    var PngEmbedder_1 = require_PngEmbedder();
    Object.defineProperty(exports, "PngEmbedder", { enumerable: true, get: function() {
      return PngEmbedder_1.default;
    } });
    var PDFPageEmbedder_1 = require_PDFPageEmbedder();
    Object.defineProperty(exports, "PDFPageEmbedder", { enumerable: true, get: function() {
      return PDFPageEmbedder_1.default;
    } });
    var ViewerPreferences_1 = require_ViewerPreferences();
    Object.defineProperty(exports, "ViewerPreferences", { enumerable: true, get: function() {
      return ViewerPreferences_1.default;
    } });
    Object.defineProperty(exports, "NonFullScreenPageMode", { enumerable: true, get: function() {
      return ViewerPreferences_1.NonFullScreenPageMode;
    } });
    Object.defineProperty(exports, "ReadingDirection", { enumerable: true, get: function() {
      return ViewerPreferences_1.ReadingDirection;
    } });
    Object.defineProperty(exports, "PrintScaling", { enumerable: true, get: function() {
      return ViewerPreferences_1.PrintScaling;
    } });
    Object.defineProperty(exports, "Duplex", { enumerable: true, get: function() {
      return ViewerPreferences_1.Duplex;
    } });
    var PDFObject_1 = require_PDFObject();
    Object.defineProperty(exports, "PDFObject", { enumerable: true, get: function() {
      return PDFObject_1.default;
    } });
    var PDFBool_1 = require_PDFBool();
    Object.defineProperty(exports, "PDFBool", { enumerable: true, get: function() {
      return PDFBool_1.default;
    } });
    var PDFNumber_1 = require_PDFNumber();
    Object.defineProperty(exports, "PDFNumber", { enumerable: true, get: function() {
      return PDFNumber_1.default;
    } });
    var PDFString_1 = require_PDFString();
    Object.defineProperty(exports, "PDFString", { enumerable: true, get: function() {
      return PDFString_1.default;
    } });
    var PDFHexString_1 = require_PDFHexString();
    Object.defineProperty(exports, "PDFHexString", { enumerable: true, get: function() {
      return PDFHexString_1.default;
    } });
    var PDFName_1 = require_PDFName();
    Object.defineProperty(exports, "PDFName", { enumerable: true, get: function() {
      return PDFName_1.default;
    } });
    var PDFNull_1 = require_PDFNull();
    Object.defineProperty(exports, "PDFNull", { enumerable: true, get: function() {
      return PDFNull_1.default;
    } });
    var PDFArray_1 = require_PDFArray();
    Object.defineProperty(exports, "PDFArray", { enumerable: true, get: function() {
      return PDFArray_1.default;
    } });
    var PDFDict_1 = require_PDFDict();
    Object.defineProperty(exports, "PDFDict", { enumerable: true, get: function() {
      return PDFDict_1.default;
    } });
    var PDFRef_1 = require_PDFRef();
    Object.defineProperty(exports, "PDFRef", { enumerable: true, get: function() {
      return PDFRef_1.default;
    } });
    var PDFInvalidObject_1 = require_PDFInvalidObject();
    Object.defineProperty(exports, "PDFInvalidObject", { enumerable: true, get: function() {
      return PDFInvalidObject_1.default;
    } });
    var PDFStream_1 = require_PDFStream();
    Object.defineProperty(exports, "PDFStream", { enumerable: true, get: function() {
      return PDFStream_1.default;
    } });
    var PDFRawStream_1 = require_PDFRawStream();
    Object.defineProperty(exports, "PDFRawStream", { enumerable: true, get: function() {
      return PDFRawStream_1.default;
    } });
    var PDFCatalog_1 = require_PDFCatalog();
    Object.defineProperty(exports, "PDFCatalog", { enumerable: true, get: function() {
      return PDFCatalog_1.default;
    } });
    var PDFContentStream_1 = require_PDFContentStream();
    Object.defineProperty(exports, "PDFContentStream", { enumerable: true, get: function() {
      return PDFContentStream_1.default;
    } });
    var PDFCrossRefStream_1 = require_PDFCrossRefStream();
    Object.defineProperty(exports, "PDFCrossRefStream", { enumerable: true, get: function() {
      return PDFCrossRefStream_1.default;
    } });
    var PDFObjectStream_1 = require_PDFObjectStream();
    Object.defineProperty(exports, "PDFObjectStream", { enumerable: true, get: function() {
      return PDFObjectStream_1.default;
    } });
    var PDFPageTree_1 = require_PDFPageTree();
    Object.defineProperty(exports, "PDFPageTree", { enumerable: true, get: function() {
      return PDFPageTree_1.default;
    } });
    var PDFPageLeaf_1 = require_PDFPageLeaf();
    Object.defineProperty(exports, "PDFPageLeaf", { enumerable: true, get: function() {
      return PDFPageLeaf_1.default;
    } });
    var PDFFlateStream_1 = require_PDFFlateStream();
    Object.defineProperty(exports, "PDFFlateStream", { enumerable: true, get: function() {
      return PDFFlateStream_1.default;
    } });
    var PDFOperator_1 = require_PDFOperator();
    Object.defineProperty(exports, "PDFOperator", { enumerable: true, get: function() {
      return PDFOperator_1.default;
    } });
    var PDFOperatorNames_1 = require_PDFOperatorNames();
    Object.defineProperty(exports, "PDFOperatorNames", { enumerable: true, get: function() {
      return PDFOperatorNames_1.default;
    } });
    var PDFObjectParser_1 = require_PDFObjectParser();
    Object.defineProperty(exports, "PDFObjectParser", { enumerable: true, get: function() {
      return PDFObjectParser_1.default;
    } });
    var PDFObjectStreamParser_1 = require_PDFObjectStreamParser();
    Object.defineProperty(exports, "PDFObjectStreamParser", { enumerable: true, get: function() {
      return PDFObjectStreamParser_1.default;
    } });
    var PDFParser_1 = require_PDFParser();
    Object.defineProperty(exports, "PDFParser", { enumerable: true, get: function() {
      return PDFParser_1.default;
    } });
    var PDFXRefStreamParser_1 = require_PDFXRefStreamParser();
    Object.defineProperty(exports, "PDFXRefStreamParser", { enumerable: true, get: function() {
      return PDFXRefStreamParser_1.default;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decodePDFRawStream", { enumerable: true, get: function() {
      return decode_1.decodePDFRawStream;
    } });
    tslib_1.__exportStar(require_annotation(), exports);
    tslib_1.__exportStar(require_acroform(), exports);
  }
});

// node_modules/pdf-lib/cjs/api/objects.js
var require_objects2 = __commonJS({
  "node_modules/pdf-lib/cjs/api/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asNumber = exports.asPDFNumber = exports.asPDFName = void 0;
    var core_1 = require_core();
    exports.asPDFName = function(name) {
      return name instanceof core_1.PDFName ? name : core_1.PDFName.of(name);
    };
    exports.asPDFNumber = function(num) {
      return num instanceof core_1.PDFNumber ? num : core_1.PDFNumber.of(num);
    };
    exports.asNumber = function(num) {
      return num instanceof core_1.PDFNumber ? num.asNumber() : num;
    };
  }
});

// node_modules/pdf-lib/cjs/api/rotations.js
var require_rotations = __commonJS({
  "node_modules/pdf-lib/cjs/api/rotations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rotateRectangle = exports.adjustDimsForRotation = exports.reduceRotation = exports.toDegrees = exports.toRadians = exports.radiansToDegrees = exports.degreesToRadians = exports.degrees = exports.radians = exports.RotationTypes = void 0;
    var utils_1 = require_utils2();
    var RotationTypes;
    (function(RotationTypes2) {
      RotationTypes2["Degrees"] = "degrees";
      RotationTypes2["Radians"] = "radians";
    })(RotationTypes = exports.RotationTypes || (exports.RotationTypes = {}));
    exports.radians = function(radianAngle) {
      utils_1.assertIs(radianAngle, "radianAngle", ["number"]);
      return { type: RotationTypes.Radians, angle: radianAngle };
    };
    exports.degrees = function(degreeAngle) {
      utils_1.assertIs(degreeAngle, "degreeAngle", ["number"]);
      return { type: RotationTypes.Degrees, angle: degreeAngle };
    };
    var Radians = RotationTypes.Radians;
    var Degrees = RotationTypes.Degrees;
    exports.degreesToRadians = function(degree) {
      return degree * Math.PI / 180;
    };
    exports.radiansToDegrees = function(radian) {
      return radian * 180 / Math.PI;
    };
    exports.toRadians = function(rotation) {
      return rotation.type === Radians ? rotation.angle : rotation.type === Degrees ? exports.degreesToRadians(rotation.angle) : utils_1.error("Invalid rotation: " + JSON.stringify(rotation));
    };
    exports.toDegrees = function(rotation) {
      return rotation.type === Radians ? exports.radiansToDegrees(rotation.angle) : rotation.type === Degrees ? rotation.angle : utils_1.error("Invalid rotation: " + JSON.stringify(rotation));
    };
    exports.reduceRotation = function(degreeAngle) {
      if (degreeAngle === void 0) {
        degreeAngle = 0;
      }
      var quadrants = degreeAngle / 90 % 4;
      if (quadrants === 0)
        return 0;
      if (quadrants === 1)
        return 90;
      if (quadrants === 2)
        return 180;
      if (quadrants === 3)
        return 270;
      return 0;
    };
    exports.adjustDimsForRotation = function(dims, degreeAngle) {
      if (degreeAngle === void 0) {
        degreeAngle = 0;
      }
      var rotation = exports.reduceRotation(degreeAngle);
      return rotation === 90 || rotation === 270 ? { width: dims.height, height: dims.width } : { width: dims.width, height: dims.height };
    };
    exports.rotateRectangle = function(rectangle, borderWidth, degreeAngle) {
      if (borderWidth === void 0) {
        borderWidth = 0;
      }
      if (degreeAngle === void 0) {
        degreeAngle = 0;
      }
      var x = rectangle.x, y = rectangle.y, w = rectangle.width, h = rectangle.height;
      var r = exports.reduceRotation(degreeAngle);
      var b = borderWidth / 2;
      if (r === 0)
        return { x: x - b, y: y - b, width: w, height: h };
      else if (r === 90)
        return { x: x - h + b, y: y - b, width: h, height: w };
      else if (r === 180)
        return { x: x - w + b, y: y - h + b, width: w, height: h };
      else if (r === 270)
        return { x: x - b, y: y - w + b, width: h, height: w };
      else
        return { x: x - b, y: y - b, width: w, height: h };
    };
  }
});

// node_modules/pdf-lib/cjs/api/operators.js
var require_operators = __commonJS({
  "node_modules/pdf-lib/cjs/api/operators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endMarkedContent = exports.beginMarkedContent = exports.setStrokingCmykColor = exports.setFillingCmykColor = exports.setStrokingRgbColor = exports.setFillingRgbColor = exports.setStrokingGrayscaleColor = exports.setFillingGrayscaleColor = exports.drawObject = exports.rotateAndSkewTextDegreesAndTranslate = exports.rotateAndSkewTextRadiansAndTranslate = exports.setTextMatrix = exports.setTextRenderingMode = exports.TextRenderingMode = exports.setTextRise = exports.setLineHeight = exports.setCharacterSqueeze = exports.setWordSpacing = exports.setCharacterSpacing = exports.setFontAndSize = exports.endText = exports.beginText = exports.showText = exports.moveText = exports.nextLine = exports.endPath = exports.fillAndStroke = exports.fill = exports.stroke = exports.square = exports.rectangle = exports.lineTo = exports.moveTo = exports.closePath = exports.appendQuadraticCurve = exports.appendBezierCurve = exports.setLineWidth = exports.popGraphicsState = exports.pushGraphicsState = exports.setGraphicsState = exports.setLineJoin = exports.LineJoinStyle = exports.setLineCap = exports.LineCapStyle = exports.restoreDashPattern = exports.setDashPattern = exports.skewDegrees = exports.skewRadians = exports.rotateDegrees = exports.rotateRadians = exports.scale = exports.translate = exports.concatTransformationMatrix = exports.clipEvenOdd = exports.clip = void 0;
    var objects_1 = require_objects2();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    exports.clip = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ClipNonZero);
    };
    exports.clipEvenOdd = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ClipEvenOdd);
    };
    var cos = Math.cos;
    var sin = Math.sin;
    var tan = Math.tan;
    exports.concatTransformationMatrix = function(a, b, c, d, e, f) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ConcatTransformationMatrix, [
        objects_1.asPDFNumber(a),
        objects_1.asPDFNumber(b),
        objects_1.asPDFNumber(c),
        objects_1.asPDFNumber(d),
        objects_1.asPDFNumber(e),
        objects_1.asPDFNumber(f)
      ]);
    };
    exports.translate = function(xPos, yPos) {
      return exports.concatTransformationMatrix(1, 0, 0, 1, xPos, yPos);
    };
    exports.scale = function(xPos, yPos) {
      return exports.concatTransformationMatrix(xPos, 0, 0, yPos, 0, 0);
    };
    exports.rotateRadians = function(angle) {
      return exports.concatTransformationMatrix(cos(objects_1.asNumber(angle)), sin(objects_1.asNumber(angle)), -sin(objects_1.asNumber(angle)), cos(objects_1.asNumber(angle)), 0, 0);
    };
    exports.rotateDegrees = function(angle) {
      return exports.rotateRadians(rotations_1.degreesToRadians(objects_1.asNumber(angle)));
    };
    exports.skewRadians = function(xSkewAngle, ySkewAngle) {
      return exports.concatTransformationMatrix(1, tan(objects_1.asNumber(xSkewAngle)), tan(objects_1.asNumber(ySkewAngle)), 1, 0, 0);
    };
    exports.skewDegrees = function(xSkewAngle, ySkewAngle) {
      return exports.skewRadians(rotations_1.degreesToRadians(objects_1.asNumber(xSkewAngle)), rotations_1.degreesToRadians(objects_1.asNumber(ySkewAngle)));
    };
    exports.setDashPattern = function(dashArray, dashPhase) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineDashPattern, [
        "[" + dashArray.map(objects_1.asPDFNumber).join(" ") + "]",
        objects_1.asPDFNumber(dashPhase)
      ]);
    };
    exports.restoreDashPattern = function() {
      return exports.setDashPattern([], 0);
    };
    var LineCapStyle;
    (function(LineCapStyle2) {
      LineCapStyle2[LineCapStyle2["Butt"] = 0] = "Butt";
      LineCapStyle2[LineCapStyle2["Round"] = 1] = "Round";
      LineCapStyle2[LineCapStyle2["Projecting"] = 2] = "Projecting";
    })(LineCapStyle = exports.LineCapStyle || (exports.LineCapStyle = {}));
    exports.setLineCap = function(style) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineCapStyle, [objects_1.asPDFNumber(style)]);
    };
    var LineJoinStyle;
    (function(LineJoinStyle2) {
      LineJoinStyle2[LineJoinStyle2["Miter"] = 0] = "Miter";
      LineJoinStyle2[LineJoinStyle2["Round"] = 1] = "Round";
      LineJoinStyle2[LineJoinStyle2["Bevel"] = 2] = "Bevel";
    })(LineJoinStyle = exports.LineJoinStyle || (exports.LineJoinStyle = {}));
    exports.setLineJoin = function(style) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineJoinStyle, [objects_1.asPDFNumber(style)]);
    };
    exports.setGraphicsState = function(state) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetGraphicsStateParams, [objects_1.asPDFName(state)]);
    };
    exports.pushGraphicsState = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.PushGraphicsState);
    };
    exports.popGraphicsState = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.PopGraphicsState);
    };
    exports.setLineWidth = function(width) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineWidth, [objects_1.asPDFNumber(width)]);
    };
    exports.appendBezierCurve = function(x1, y1, x2, y2, x3, y3) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.AppendBezierCurve, [
        objects_1.asPDFNumber(x1),
        objects_1.asPDFNumber(y1),
        objects_1.asPDFNumber(x2),
        objects_1.asPDFNumber(y2),
        objects_1.asPDFNumber(x3),
        objects_1.asPDFNumber(y3)
      ]);
    };
    exports.appendQuadraticCurve = function(x1, y1, x2, y2) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.CurveToReplicateInitialPoint, [
        objects_1.asPDFNumber(x1),
        objects_1.asPDFNumber(y1),
        objects_1.asPDFNumber(x2),
        objects_1.asPDFNumber(y2)
      ]);
    };
    exports.closePath = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ClosePath);
    };
    exports.moveTo = function(xPos, yPos) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.MoveTo, [objects_1.asPDFNumber(xPos), objects_1.asPDFNumber(yPos)]);
    };
    exports.lineTo = function(xPos, yPos) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.LineTo, [objects_1.asPDFNumber(xPos), objects_1.asPDFNumber(yPos)]);
    };
    exports.rectangle = function(xPos, yPos, width, height) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.AppendRectangle, [
        objects_1.asPDFNumber(xPos),
        objects_1.asPDFNumber(yPos),
        objects_1.asPDFNumber(width),
        objects_1.asPDFNumber(height)
      ]);
    };
    exports.square = function(xPos, yPos, size) {
      return exports.rectangle(xPos, yPos, size, size);
    };
    exports.stroke = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokePath);
    };
    exports.fill = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.FillNonZero);
    };
    exports.fillAndStroke = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.FillNonZeroAndStroke);
    };
    exports.endPath = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.EndPath);
    };
    exports.nextLine = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NextLine);
    };
    exports.moveText = function(x, y) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.MoveText, [objects_1.asPDFNumber(x), objects_1.asPDFNumber(y)]);
    };
    exports.showText = function(text) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ShowText, [text]);
    };
    exports.beginText = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.BeginText);
    };
    exports.endText = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.EndText);
    };
    exports.setFontAndSize = function(name, size) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetFontAndSize, [objects_1.asPDFName(name), objects_1.asPDFNumber(size)]);
    };
    exports.setCharacterSpacing = function(spacing) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetCharacterSpacing, [objects_1.asPDFNumber(spacing)]);
    };
    exports.setWordSpacing = function(spacing) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetWordSpacing, [objects_1.asPDFNumber(spacing)]);
    };
    exports.setCharacterSqueeze = function(squeeze) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextHorizontalScaling, [objects_1.asPDFNumber(squeeze)]);
    };
    exports.setLineHeight = function(lineHeight) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextLineHeight, [objects_1.asPDFNumber(lineHeight)]);
    };
    exports.setTextRise = function(rise) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextRise, [objects_1.asPDFNumber(rise)]);
    };
    var TextRenderingMode;
    (function(TextRenderingMode2) {
      TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
      TextRenderingMode2[TextRenderingMode2["Outline"] = 1] = "Outline";
      TextRenderingMode2[TextRenderingMode2["FillAndOutline"] = 2] = "FillAndOutline";
      TextRenderingMode2[TextRenderingMode2["Invisible"] = 3] = "Invisible";
      TextRenderingMode2[TextRenderingMode2["FillAndClip"] = 4] = "FillAndClip";
      TextRenderingMode2[TextRenderingMode2["OutlineAndClip"] = 5] = "OutlineAndClip";
      TextRenderingMode2[TextRenderingMode2["FillAndOutlineAndClip"] = 6] = "FillAndOutlineAndClip";
      TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
    })(TextRenderingMode = exports.TextRenderingMode || (exports.TextRenderingMode = {}));
    exports.setTextRenderingMode = function(mode) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextRenderingMode, [objects_1.asPDFNumber(mode)]);
    };
    exports.setTextMatrix = function(a, b, c, d, e, f) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextMatrix, [
        objects_1.asPDFNumber(a),
        objects_1.asPDFNumber(b),
        objects_1.asPDFNumber(c),
        objects_1.asPDFNumber(d),
        objects_1.asPDFNumber(e),
        objects_1.asPDFNumber(f)
      ]);
    };
    exports.rotateAndSkewTextRadiansAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
      return exports.setTextMatrix(cos(objects_1.asNumber(rotationAngle)), sin(objects_1.asNumber(rotationAngle)) + tan(objects_1.asNumber(xSkewAngle)), -sin(objects_1.asNumber(rotationAngle)) + tan(objects_1.asNumber(ySkewAngle)), cos(objects_1.asNumber(rotationAngle)), x, y);
    };
    exports.rotateAndSkewTextDegreesAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
      return exports.rotateAndSkewTextRadiansAndTranslate(rotations_1.degreesToRadians(objects_1.asNumber(rotationAngle)), rotations_1.degreesToRadians(objects_1.asNumber(xSkewAngle)), rotations_1.degreesToRadians(objects_1.asNumber(ySkewAngle)), x, y);
    };
    exports.drawObject = function(name) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.DrawObject, [objects_1.asPDFName(name)]);
    };
    exports.setFillingGrayscaleColor = function(gray) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NonStrokingColorGray, [objects_1.asPDFNumber(gray)]);
    };
    exports.setStrokingGrayscaleColor = function(gray) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokingColorGray, [objects_1.asPDFNumber(gray)]);
    };
    exports.setFillingRgbColor = function(red, green, blue) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NonStrokingColorRgb, [
        objects_1.asPDFNumber(red),
        objects_1.asPDFNumber(green),
        objects_1.asPDFNumber(blue)
      ]);
    };
    exports.setStrokingRgbColor = function(red, green, blue) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokingColorRgb, [
        objects_1.asPDFNumber(red),
        objects_1.asPDFNumber(green),
        objects_1.asPDFNumber(blue)
      ]);
    };
    exports.setFillingCmykColor = function(cyan, magenta, yellow, key) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NonStrokingColorCmyk, [
        objects_1.asPDFNumber(cyan),
        objects_1.asPDFNumber(magenta),
        objects_1.asPDFNumber(yellow),
        objects_1.asPDFNumber(key)
      ]);
    };
    exports.setStrokingCmykColor = function(cyan, magenta, yellow, key) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokingColorCmyk, [
        objects_1.asPDFNumber(cyan),
        objects_1.asPDFNumber(magenta),
        objects_1.asPDFNumber(yellow),
        objects_1.asPDFNumber(key)
      ]);
    };
    exports.beginMarkedContent = function(tag) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.BeginMarkedContent, [objects_1.asPDFName(tag)]);
    };
    exports.endMarkedContent = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.EndMarkedContent);
    };
  }
});

// node_modules/pdf-lib/cjs/api/colors.js
var require_colors = __commonJS({
  "node_modules/pdf-lib/cjs/api/colors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.colorToComponents = exports.componentsToColor = exports.setStrokingColor = exports.setFillingColor = exports.cmyk = exports.rgb = exports.grayscale = exports.ColorTypes = void 0;
    var operators_1 = require_operators();
    var utils_1 = require_utils2();
    var ColorTypes;
    (function(ColorTypes2) {
      ColorTypes2["Grayscale"] = "Grayscale";
      ColorTypes2["RGB"] = "RGB";
      ColorTypes2["CMYK"] = "CMYK";
    })(ColorTypes = exports.ColorTypes || (exports.ColorTypes = {}));
    exports.grayscale = function(gray) {
      utils_1.assertRange(gray, "gray", 0, 1);
      return { type: ColorTypes.Grayscale, gray };
    };
    exports.rgb = function(red, green, blue) {
      utils_1.assertRange(red, "red", 0, 1);
      utils_1.assertRange(green, "green", 0, 1);
      utils_1.assertRange(blue, "blue", 0, 1);
      return { type: ColorTypes.RGB, red, green, blue };
    };
    exports.cmyk = function(cyan, magenta, yellow, key) {
      utils_1.assertRange(cyan, "cyan", 0, 1);
      utils_1.assertRange(magenta, "magenta", 0, 1);
      utils_1.assertRange(yellow, "yellow", 0, 1);
      utils_1.assertRange(key, "key", 0, 1);
      return { type: ColorTypes.CMYK, cyan, magenta, yellow, key };
    };
    var Grayscale = ColorTypes.Grayscale;
    var RGB = ColorTypes.RGB;
    var CMYK = ColorTypes.CMYK;
    exports.setFillingColor = function(color) {
      return color.type === Grayscale ? operators_1.setFillingGrayscaleColor(color.gray) : color.type === RGB ? operators_1.setFillingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? operators_1.setFillingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : utils_1.error("Invalid color: " + JSON.stringify(color));
    };
    exports.setStrokingColor = function(color) {
      return color.type === Grayscale ? operators_1.setStrokingGrayscaleColor(color.gray) : color.type === RGB ? operators_1.setStrokingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? operators_1.setStrokingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : utils_1.error("Invalid color: " + JSON.stringify(color));
    };
    exports.componentsToColor = function(comps, scale) {
      if (scale === void 0) {
        scale = 1;
      }
      return (comps === null || comps === void 0 ? void 0 : comps.length) === 1 ? exports.grayscale(comps[0] * scale) : (comps === null || comps === void 0 ? void 0 : comps.length) === 3 ? exports.rgb(comps[0] * scale, comps[1] * scale, comps[2] * scale) : (comps === null || comps === void 0 ? void 0 : comps.length) === 4 ? exports.cmyk(comps[0] * scale, comps[1] * scale, comps[2] * scale, comps[3] * scale) : void 0;
    };
    exports.colorToComponents = function(color) {
      return color.type === Grayscale ? [color.gray] : color.type === RGB ? [color.red, color.green, color.blue] : color.type === CMYK ? [color.cyan, color.magenta, color.yellow, color.key] : utils_1.error("Invalid color: " + JSON.stringify(color));
    };
  }
});

// node_modules/pdf-lib/cjs/api/svgPath.js
var require_svgPath = __commonJS({
  "node_modules/pdf-lib/cjs/api/svgPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.svgPathToOperators = void 0;
    var operators_1 = require_operators();
    var cx = 0;
    var cy = 0;
    var px = 0;
    var py = 0;
    var sx = 0;
    var sy = 0;
    var parameters = /* @__PURE__ */ new Map([
      ["A", 7],
      ["a", 7],
      ["C", 6],
      ["c", 6],
      ["H", 1],
      ["h", 1],
      ["L", 2],
      ["l", 2],
      ["M", 2],
      ["m", 2],
      ["Q", 4],
      ["q", 4],
      ["S", 4],
      ["s", 4],
      ["T", 2],
      ["t", 2],
      ["V", 1],
      ["v", 1],
      ["Z", 0],
      ["z", 0]
    ]);
    var parse = function(path) {
      var cmd;
      var ret = [];
      var args = [];
      var curArg = "";
      var foundDecimal = false;
      var params = 0;
      for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
        var c = path_1[_i];
        if (parameters.has(c)) {
          params = parameters.get(c);
          if (cmd) {
            if (curArg.length > 0) {
              args[args.length] = +curArg;
            }
            ret[ret.length] = { cmd, args };
            args = [];
            curArg = "";
            foundDecimal = false;
          }
          cmd = c;
        } else if ([" ", ","].includes(c) || c === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c === "." && foundDecimal) {
          if (curArg.length === 0) {
            continue;
          }
          if (args.length === params) {
            ret[ret.length] = { cmd, args };
            args = [+curArg];
            if (cmd === "M") {
              cmd = "L";
            }
            if (cmd === "m") {
              cmd = "l";
            }
          } else {
            args[args.length] = +curArg;
          }
          foundDecimal = c === ".";
          curArg = ["-", "."].includes(c) ? c : "";
        } else {
          curArg += c;
          if (c === ".") {
            foundDecimal = true;
          }
        }
      }
      if (curArg.length > 0) {
        if (args.length === params) {
          ret[ret.length] = { cmd, args };
          args = [+curArg];
          if (cmd === "M") {
            cmd = "L";
          }
          if (cmd === "m") {
            cmd = "l";
          }
        } else {
          args[args.length] = +curArg;
        }
      }
      ret[ret.length] = { cmd, args };
      return ret;
    };
    var apply = function(commands) {
      cx = cy = px = py = sx = sy = 0;
      var cmds = [];
      for (var i = 0; i < commands.length; i++) {
        var c = commands[i];
        if (c.cmd && typeof runners[c.cmd] === "function") {
          var cmd = runners[c.cmd](c.args);
          if (Array.isArray(cmd)) {
            cmds = cmds.concat(cmd);
          } else {
            cmds.push(cmd);
          }
        }
      }
      return cmds;
    };
    var runners = {
      M: function(a) {
        cx = a[0];
        cy = a[1];
        px = py = null;
        sx = cx;
        sy = cy;
        return operators_1.moveTo(cx, cy);
      },
      m: function(a) {
        cx += a[0];
        cy += a[1];
        px = py = null;
        sx = cx;
        sy = cy;
        return operators_1.moveTo(cx, cy);
      },
      C: function(a) {
        cx = a[4];
        cy = a[5];
        px = a[2];
        py = a[3];
        return operators_1.appendBezierCurve(a[0], a[1], a[2], a[3], a[4], a[5]);
      },
      c: function(a) {
        var cmd = operators_1.appendBezierCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
        px = cx + a[2];
        py = cy + a[3];
        cx += a[4];
        cy += a[5];
        return cmd;
      },
      S: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        }
        var cmd = operators_1.appendBezierCurve(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
        px = a[0];
        py = a[1];
        cx = a[2];
        cy = a[3];
        return cmd;
      },
      s: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        }
        var cmd = operators_1.appendBezierCurve(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
        px = cx + a[0];
        py = cy + a[1];
        cx += a[2];
        cy += a[3];
        return cmd;
      },
      Q: function(a) {
        px = a[0];
        py = a[1];
        cx = a[2];
        cy = a[3];
        return operators_1.appendQuadraticCurve(a[0], a[1], cx, cy);
      },
      q: function(a) {
        var cmd = operators_1.appendQuadraticCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
        px = cx + a[0];
        py = cy + a[1];
        cx += a[2];
        cy += a[3];
        return cmd;
      },
      T: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        } else {
          px = cx - (px - cx);
          py = cy - (py - cy);
        }
        var cmd = operators_1.appendQuadraticCurve(px, py, a[0], a[1]);
        px = cx - (px - cx);
        py = cy - (py - cy);
        cx = a[0];
        cy = a[1];
        return cmd;
      },
      t: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        } else {
          px = cx - (px - cx);
          py = cy - (py - cy);
        }
        var cmd = operators_1.appendQuadraticCurve(px, py, cx + a[0], cy + a[1]);
        cx += a[0];
        cy += a[1];
        return cmd;
      },
      A: function(a) {
        var cmds = solveArc(cx, cy, a);
        cx = a[5];
        cy = a[6];
        return cmds;
      },
      a: function(a) {
        a[5] += cx;
        a[6] += cy;
        var cmds = solveArc(cx, cy, a);
        cx = a[5];
        cy = a[6];
        return cmds;
      },
      L: function(a) {
        cx = a[0];
        cy = a[1];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      l: function(a) {
        cx += a[0];
        cy += a[1];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      H: function(a) {
        cx = a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      h: function(a) {
        cx += a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      V: function(a) {
        cy = a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      v: function(a) {
        cy += a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      Z: function() {
        var cmd = operators_1.closePath();
        cx = sx;
        cy = sy;
        return cmd;
      },
      z: function() {
        var cmd = operators_1.closePath();
        cx = sx;
        cy = sy;
        return cmd;
      }
    };
    var solveArc = function(x, y, coords) {
      var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
      var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
      var cmds = [];
      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        var bez = segmentToBezier.apply(void 0, seg);
        cmds.push(operators_1.appendBezierCurve.apply(void 0, bez));
      }
      return cmds;
    };
    var arcToSegments = function(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
      var th = rotateX * (Math.PI / 180);
      var sinTh = Math.sin(th);
      var cosTh = Math.cos(th);
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      px = cosTh * (ox - x) * 0.5 + sinTh * (oy - y) * 0.5;
      py = cosTh * (oy - y) * 0.5 - sinTh * (ox - x) * 0.5;
      var pl = px * px / (rx * rx) + py * py / (ry * ry);
      if (pl > 1) {
        pl = Math.sqrt(pl);
        rx *= pl;
        ry *= pl;
      }
      var a00 = cosTh / rx;
      var a01 = sinTh / rx;
      var a10 = -sinTh / ry;
      var a11 = cosTh / ry;
      var x0 = a00 * ox + a01 * oy;
      var y0 = a10 * ox + a11 * oy;
      var x1 = a00 * x + a01 * y;
      var y1 = a10 * x + a11 * y;
      var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
      var sfactorSq = 1 / d - 0.25;
      if (sfactorSq < 0) {
        sfactorSq = 0;
      }
      var sfactor = Math.sqrt(sfactorSq);
      if (sweep === large) {
        sfactor = -sfactor;
      }
      var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
      var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
      var th0 = Math.atan2(y0 - yc, x0 - xc);
      var th1 = Math.atan2(y1 - yc, x1 - xc);
      var thArc = th1 - th0;
      if (thArc < 0 && sweep === 1) {
        thArc += 2 * Math.PI;
      } else if (thArc > 0 && sweep === 0) {
        thArc -= 2 * Math.PI;
      }
      var segments = Math.ceil(Math.abs(thArc / (Math.PI * 0.5 + 1e-3)));
      var result = [];
      for (var i = 0; i < segments; i++) {
        var th2 = th0 + i * thArc / segments;
        var th3 = th0 + (i + 1) * thArc / segments;
        result[i] = [xc, yc, th2, th3, rx, ry, sinTh, cosTh];
      }
      return result;
    };
    var segmentToBezier = function(cx1, cy1, th0, th1, rx, ry, sinTh, cosTh) {
      var a00 = cosTh * rx;
      var a01 = -sinTh * ry;
      var a10 = sinTh * rx;
      var a11 = cosTh * ry;
      var thHalf = 0.5 * (th1 - th0);
      var t = 8 / 3 * Math.sin(thHalf * 0.5) * Math.sin(thHalf * 0.5) / Math.sin(thHalf);
      var x1 = cx1 + Math.cos(th0) - t * Math.sin(th0);
      var y1 = cy1 + Math.sin(th0) + t * Math.cos(th0);
      var x3 = cx1 + Math.cos(th1);
      var y3 = cy1 + Math.sin(th1);
      var x2 = x3 + t * Math.sin(th1);
      var y2 = y3 - t * Math.cos(th1);
      var result = [
        a00 * x1 + a01 * y1,
        a10 * x1 + a11 * y1,
        a00 * x2 + a01 * y2,
        a10 * x2 + a11 * y2,
        a00 * x3 + a01 * y3,
        a10 * x3 + a11 * y3
      ];
      return result;
    };
    exports.svgPathToOperators = function(path) {
      return apply(parse(path));
    };
  }
});

// node_modules/pdf-lib/cjs/api/operations.js
var require_operations = __commonJS({
  "node_modules/pdf-lib/cjs/api/operations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.drawOptionList = exports.drawTextField = exports.drawTextLines = exports.drawButton = exports.drawRadioButton = exports.drawCheckBox = exports.rotateInPlace = exports.drawCheckMark = exports.drawSvgPath = exports.drawEllipse = exports.drawEllipsePath = exports.drawRectangle = exports.drawLine = exports.drawPage = exports.drawImage = exports.drawLinesOfText = exports.drawText = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var colors_1 = require_colors();
    var operators_1 = require_operators();
    var rotations_1 = require_rotations();
    var svgPath_1 = require_svgPath();
    var objects_1 = require_objects2();
    exports.drawText = function(line, options) {
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.beginText(),
        colors_1.setFillingColor(options.color),
        operators_1.setFontAndSize(options.font, options.size),
        operators_1.rotateAndSkewTextRadiansAndTranslate(rotations_1.toRadians(options.rotate), rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew), options.x, options.y),
        operators_1.showText(line),
        operators_1.endText(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawLinesOfText = function(lines, options) {
      var operators = [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.beginText(),
        colors_1.setFillingColor(options.color),
        operators_1.setFontAndSize(options.font, options.size),
        operators_1.setLineHeight(options.lineHeight),
        operators_1.rotateAndSkewTextRadiansAndTranslate(rotations_1.toRadians(options.rotate), rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew), options.x, options.y)
      ].filter(Boolean);
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        operators.push(operators_1.showText(lines[idx]), operators_1.nextLine());
      }
      operators.push(operators_1.endText(), operators_1.popGraphicsState());
      return operators;
    };
    exports.drawImage = function(name, options) {
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians(options.rotate)),
        operators_1.scale(options.width, options.height),
        operators_1.skewRadians(rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew)),
        operators_1.drawObject(name),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawPage = function(name, options) {
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians(options.rotate)),
        operators_1.scale(options.xScale, options.yScale),
        operators_1.skewRadians(rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew)),
        operators_1.drawObject(name),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawLine = function(options) {
      var _a, _b;
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        options.color && colors_1.setStrokingColor(options.color),
        operators_1.setLineWidth(options.thickness),
        operators_1.setDashPattern((_a = options.dashArray) !== null && _a !== void 0 ? _a : [], (_b = options.dashPhase) !== null && _b !== void 0 ? _b : 0),
        operators_1.moveTo(options.start.x, options.start.y),
        options.lineCap && operators_1.setLineCap(options.lineCap),
        operators_1.moveTo(options.start.x, options.start.y),
        operators_1.lineTo(options.end.x, options.end.y),
        operators_1.stroke(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawRectangle = function(options) {
      var _a, _b;
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        options.color && colors_1.setFillingColor(options.color),
        options.borderColor && colors_1.setStrokingColor(options.borderColor),
        operators_1.setLineWidth(options.borderWidth),
        options.borderLineCap && operators_1.setLineCap(options.borderLineCap),
        operators_1.setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians(options.rotate)),
        operators_1.skewRadians(rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew)),
        operators_1.moveTo(0, 0),
        operators_1.lineTo(0, options.height),
        operators_1.lineTo(options.width, options.height),
        operators_1.lineTo(options.width, 0),
        operators_1.closePath(),
        // prettier-ignore
        options.color && options.borderWidth ? operators_1.fillAndStroke() : options.color ? operators_1.fill() : options.borderColor ? operators_1.stroke() : operators_1.closePath(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
    exports.drawEllipsePath = function(config) {
      var x = objects_1.asNumber(config.x);
      var y = objects_1.asNumber(config.y);
      var xScale = objects_1.asNumber(config.xScale);
      var yScale = objects_1.asNumber(config.yScale);
      x -= xScale;
      y -= yScale;
      var ox = xScale * KAPPA;
      var oy = yScale * KAPPA;
      var xe = x + xScale * 2;
      var ye = y + yScale * 2;
      var xm = x + xScale;
      var ym = y + yScale;
      return [
        operators_1.pushGraphicsState(),
        operators_1.moveTo(x, ym),
        operators_1.appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
        operators_1.appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
        operators_1.appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
        operators_1.appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym),
        operators_1.popGraphicsState()
      ];
    };
    var drawEllipseCurves = function(config) {
      var centerX = objects_1.asNumber(config.x);
      var centerY = objects_1.asNumber(config.y);
      var xScale = objects_1.asNumber(config.xScale);
      var yScale = objects_1.asNumber(config.yScale);
      var x = -xScale;
      var y = -yScale;
      var ox = xScale * KAPPA;
      var oy = yScale * KAPPA;
      var xe = x + xScale * 2;
      var ye = y + yScale * 2;
      var xm = x + xScale;
      var ym = y + yScale;
      return [
        operators_1.translate(centerX, centerY),
        operators_1.rotateRadians(rotations_1.toRadians(config.rotate)),
        operators_1.moveTo(x, ym),
        operators_1.appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
        operators_1.appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
        operators_1.appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
        operators_1.appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym)
      ];
    };
    exports.drawEllipse = function(options) {
      var _a, _b, _c;
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        options.color && colors_1.setFillingColor(options.color),
        options.borderColor && colors_1.setStrokingColor(options.borderColor),
        operators_1.setLineWidth(options.borderWidth),
        options.borderLineCap && operators_1.setLineCap(options.borderLineCap),
        operators_1.setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0)
      ], options.rotate === void 0 ? exports.drawEllipsePath({
        x: options.x,
        y: options.y,
        xScale: options.xScale,
        yScale: options.yScale
      }) : drawEllipseCurves({
        x: options.x,
        y: options.y,
        xScale: options.xScale,
        yScale: options.yScale,
        rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : rotations_1.degrees(0)
      }), [
        // prettier-ignore
        options.color && options.borderWidth ? operators_1.fillAndStroke() : options.color ? operators_1.fill() : options.borderColor ? operators_1.stroke() : operators_1.closePath(),
        operators_1.popGraphicsState()
      ]).filter(Boolean);
    };
    exports.drawSvgPath = function(path, options) {
      var _a, _b, _c;
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians((_a = options.rotate) !== null && _a !== void 0 ? _a : rotations_1.degrees(0))),
        // SVG path Y axis is opposite pdf-lib's
        options.scale ? operators_1.scale(options.scale, -options.scale) : operators_1.scale(1, -1),
        options.color && colors_1.setFillingColor(options.color),
        options.borderColor && colors_1.setStrokingColor(options.borderColor),
        options.borderWidth && operators_1.setLineWidth(options.borderWidth),
        options.borderLineCap && operators_1.setLineCap(options.borderLineCap),
        operators_1.setDashPattern((_b = options.borderDashArray) !== null && _b !== void 0 ? _b : [], (_c = options.borderDashPhase) !== null && _c !== void 0 ? _c : 0)
      ], svgPath_1.svgPathToOperators(path), [
        // prettier-ignore
        options.color && options.borderWidth ? operators_1.fillAndStroke() : options.color ? operators_1.fill() : options.borderColor ? operators_1.stroke() : operators_1.closePath(),
        operators_1.popGraphicsState()
      ]).filter(Boolean);
    };
    exports.drawCheckMark = function(options) {
      var size = objects_1.asNumber(options.size);
      var p2x = -1 + 0.75;
      var p2y = -1 + 0.51;
      var p3y = 1 - 0.525;
      var p3x = 1 - 0.31;
      var p1x = -1 + 0.325;
      var p1y = -((p1x - p2x) * (p3x - p2x)) / (p3y - p2y) + p2y;
      return [
        operators_1.pushGraphicsState(),
        options.color && colors_1.setStrokingColor(options.color),
        operators_1.setLineWidth(options.thickness),
        operators_1.translate(options.x, options.y),
        operators_1.moveTo(p1x * size, p1y * size),
        operators_1.lineTo(p2x * size, p2y * size),
        operators_1.lineTo(p3x * size, p3y * size),
        operators_1.stroke(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.rotateInPlace = function(options) {
      return options.rotation === 0 ? [
        operators_1.translate(0, 0),
        operators_1.rotateDegrees(0)
      ] : options.rotation === 90 ? [
        operators_1.translate(options.width, 0),
        operators_1.rotateDegrees(90)
      ] : options.rotation === 180 ? [
        operators_1.translate(options.width, options.height),
        operators_1.rotateDegrees(180)
      ] : options.rotation === 270 ? [
        operators_1.translate(0, options.height),
        operators_1.rotateDegrees(270)
      ] : [];
    };
    exports.drawCheckBox = function(options) {
      var outline = exports.drawRectangle({
        x: options.x,
        y: options.y,
        width: options.width,
        height: options.height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      if (!options.filled)
        return outline;
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var checkMarkSize = Math.min(width, height) / 2;
      var checkMark = exports.drawCheckMark({
        x: width / 2,
        y: height / 2,
        size: checkMarkSize,
        thickness: options.thickness,
        color: options.markColor
      });
      return tslib_1.__spreadArrays([operators_1.pushGraphicsState()], outline, checkMark, [operators_1.popGraphicsState()]);
    };
    exports.drawRadioButton = function(options) {
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var outlineScale = Math.min(width, height) / 2;
      var outline = exports.drawEllipse({
        x: options.x,
        y: options.y,
        xScale: outlineScale,
        yScale: outlineScale,
        color: options.color,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth
      });
      if (!options.filled)
        return outline;
      var dot = exports.drawEllipse({
        x: options.x,
        y: options.y,
        xScale: outlineScale * 0.45,
        yScale: outlineScale * 0.45,
        color: options.dotColor,
        borderColor: void 0,
        borderWidth: 0
      });
      return tslib_1.__spreadArrays([operators_1.pushGraphicsState()], outline, dot, [operators_1.popGraphicsState()]);
    };
    exports.drawButton = function(options) {
      var x = objects_1.asNumber(options.x);
      var y = objects_1.asNumber(options.y);
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var background = exports.drawRectangle({
        x,
        y,
        width,
        height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var lines = exports.drawTextLines(options.textLines, {
        color: options.textColor,
        font: options.font,
        size: options.fontSize,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      return tslib_1.__spreadArrays([operators_1.pushGraphicsState()], background, lines, [operators_1.popGraphicsState()]);
    };
    exports.drawTextLines = function(lines, options) {
      var operators = [
        operators_1.beginText(),
        colors_1.setFillingColor(options.color),
        operators_1.setFontAndSize(options.font, options.size)
      ];
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        var _a = lines[idx], encoded = _a.encoded, x = _a.x, y = _a.y;
        operators.push(operators_1.rotateAndSkewTextRadiansAndTranslate(rotations_1.toRadians(options.rotate), rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew), x, y), operators_1.showText(encoded));
      }
      operators.push(operators_1.endText());
      return operators;
    };
    exports.drawTextField = function(options) {
      var x = objects_1.asNumber(options.x);
      var y = objects_1.asNumber(options.y);
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var borderWidth = objects_1.asNumber(options.borderWidth);
      var padding = objects_1.asNumber(options.padding);
      var clipX = x + borderWidth / 2 + padding;
      var clipY = y + borderWidth / 2 + padding;
      var clipWidth = width - (borderWidth / 2 + padding) * 2;
      var clipHeight = height - (borderWidth / 2 + padding) * 2;
      var clippingArea = [
        operators_1.moveTo(clipX, clipY),
        operators_1.lineTo(clipX, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY),
        operators_1.closePath(),
        operators_1.clip(),
        operators_1.endPath()
      ];
      var background = exports.drawRectangle({
        x,
        y,
        width,
        height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var lines = exports.drawTextLines(options.textLines, {
        color: options.textColor,
        font: options.font,
        size: options.fontSize,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var markedContent = tslib_1.__spreadArrays([
        operators_1.beginMarkedContent("Tx"),
        operators_1.pushGraphicsState()
      ], lines, [
        operators_1.popGraphicsState(),
        operators_1.endMarkedContent()
      ]);
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState()
      ], background, clippingArea, markedContent, [
        operators_1.popGraphicsState()
      ]);
    };
    exports.drawOptionList = function(options) {
      var x = objects_1.asNumber(options.x);
      var y = objects_1.asNumber(options.y);
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var lineHeight = objects_1.asNumber(options.lineHeight);
      var borderWidth = objects_1.asNumber(options.borderWidth);
      var padding = objects_1.asNumber(options.padding);
      var clipX = x + borderWidth / 2 + padding;
      var clipY = y + borderWidth / 2 + padding;
      var clipWidth = width - (borderWidth / 2 + padding) * 2;
      var clipHeight = height - (borderWidth / 2 + padding) * 2;
      var clippingArea = [
        operators_1.moveTo(clipX, clipY),
        operators_1.lineTo(clipX, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY),
        operators_1.closePath(),
        operators_1.clip(),
        operators_1.endPath()
      ];
      var background = exports.drawRectangle({
        x,
        y,
        width,
        height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var highlights = [];
      for (var idx = 0, len = options.selectedLines.length; idx < len; idx++) {
        var line = options.textLines[options.selectedLines[idx]];
        highlights.push.apply(highlights, exports.drawRectangle({
          x: line.x - padding,
          y: line.y - (lineHeight - line.height) / 2,
          width: width - borderWidth,
          height: line.height + (lineHeight - line.height) / 2,
          borderWidth: 0,
          color: options.selectedColor,
          borderColor: void 0,
          rotate: rotations_1.degrees(0),
          xSkew: rotations_1.degrees(0),
          ySkew: rotations_1.degrees(0)
        }));
      }
      var lines = exports.drawTextLines(options.textLines, {
        color: options.textColor,
        font: options.font,
        size: options.fontSize,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var markedContent = tslib_1.__spreadArrays([
        operators_1.beginMarkedContent("Tx"),
        operators_1.pushGraphicsState()
      ], lines, [
        operators_1.popGraphicsState(),
        operators_1.endMarkedContent()
      ]);
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState()
      ], background, highlights, clippingArea, markedContent, [
        operators_1.popGraphicsState()
      ]);
    };
  }
});

// node_modules/pdf-lib/cjs/api/errors.js
var require_errors3 = __commonJS({
  "node_modules/pdf-lib/cjs/api/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidMaxLengthError = exports.ExceededMaxLengthError = exports.CombedTextLayoutError = exports.RichTextFieldReadError = exports.FieldExistsAsNonTerminalError = exports.InvalidFieldNamePartError = exports.FieldAlreadyExistsError = exports.MissingOnValueCheckError = exports.UnexpectedFieldTypeError = exports.NoSuchFieldError = exports.RemovePageFromEmptyDocumentError = exports.ForeignPageError = exports.FontkitNotRegisteredError = exports.EncryptedPDFError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var EncryptedPDFError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(EncryptedPDFError2, _super);
        function EncryptedPDFError2() {
          var _this = this;
          var msg = "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return EncryptedPDFError2;
      }(Error)
    );
    exports.EncryptedPDFError = EncryptedPDFError;
    var FontkitNotRegisteredError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FontkitNotRegisteredError2, _super);
        function FontkitNotRegisteredError2() {
          var _this = this;
          var msg = "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return FontkitNotRegisteredError2;
      }(Error)
    );
    exports.FontkitNotRegisteredError = FontkitNotRegisteredError;
    var ForeignPageError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ForeignPageError2, _super);
        function ForeignPageError2() {
          var _this = this;
          var msg = "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return ForeignPageError2;
      }(Error)
    );
    exports.ForeignPageError = ForeignPageError;
    var RemovePageFromEmptyDocumentError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(RemovePageFromEmptyDocumentError2, _super);
        function RemovePageFromEmptyDocumentError2() {
          var _this = this;
          var msg = "PDFDocument has no pages so `PDFDocument.removePage` cannot be called";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return RemovePageFromEmptyDocumentError2;
      }(Error)
    );
    exports.RemovePageFromEmptyDocumentError = RemovePageFromEmptyDocumentError;
    var NoSuchFieldError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(NoSuchFieldError2, _super);
        function NoSuchFieldError2(name) {
          var _this = this;
          var msg = 'PDFDocument has no form field with the name "' + name + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return NoSuchFieldError2;
      }(Error)
    );
    exports.NoSuchFieldError = NoSuchFieldError;
    var UnexpectedFieldTypeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnexpectedFieldTypeError2, _super);
        function UnexpectedFieldTypeError2(name, expected, actual) {
          var _a, _b;
          var _this = this;
          var expectedType = expected === null || expected === void 0 ? void 0 : expected.name;
          var actualType = (_b = (_a = actual === null || actual === void 0 ? void 0 : actual.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : actual;
          var msg = 'Expected field "' + name + '" to be of type ' + expectedType + ", " + ("but it is actually of type " + actualType);
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnexpectedFieldTypeError2;
      }(Error)
    );
    exports.UnexpectedFieldTypeError = UnexpectedFieldTypeError;
    var MissingOnValueCheckError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingOnValueCheckError2, _super);
        function MissingOnValueCheckError2(onValue) {
          var _this = this;
          var msg = 'Failed to select check box due to missing onValue: "' + onValue + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingOnValueCheckError2;
      }(Error)
    );
    exports.MissingOnValueCheckError = MissingOnValueCheckError;
    var FieldAlreadyExistsError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FieldAlreadyExistsError2, _super);
        function FieldAlreadyExistsError2(name) {
          var _this = this;
          var msg = 'A field already exists with the specified name: "' + name + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return FieldAlreadyExistsError2;
      }(Error)
    );
    exports.FieldAlreadyExistsError = FieldAlreadyExistsError;
    var InvalidFieldNamePartError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidFieldNamePartError2, _super);
        function InvalidFieldNamePartError2(namePart) {
          var _this = this;
          var msg = 'Field name contains invalid component: "' + namePart + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidFieldNamePartError2;
      }(Error)
    );
    exports.InvalidFieldNamePartError = InvalidFieldNamePartError;
    var FieldExistsAsNonTerminalError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FieldExistsAsNonTerminalError2, _super);
        function FieldExistsAsNonTerminalError2(name) {
          var _this = this;
          var msg = 'A non-terminal field already exists with the specified name: "' + name + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return FieldExistsAsNonTerminalError2;
      }(Error)
    );
    exports.FieldExistsAsNonTerminalError = FieldExistsAsNonTerminalError;
    var RichTextFieldReadError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(RichTextFieldReadError2, _super);
        function RichTextFieldReadError2(fieldName) {
          var _this = this;
          var msg = "Reading rich text fields is not supported: Attempted to read rich text field: " + fieldName;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return RichTextFieldReadError2;
      }(Error)
    );
    exports.RichTextFieldReadError = RichTextFieldReadError;
    var CombedTextLayoutError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(CombedTextLayoutError2, _super);
        function CombedTextLayoutError2(lineLength, cellCount) {
          var _this = this;
          var msg = "Failed to layout combed text as lineLength=" + lineLength + " is greater than cellCount=" + cellCount;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return CombedTextLayoutError2;
      }(Error)
    );
    exports.CombedTextLayoutError = CombedTextLayoutError;
    var ExceededMaxLengthError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ExceededMaxLengthError2, _super);
        function ExceededMaxLengthError2(textLength, maxLength, name) {
          var _this = this;
          var msg = "Attempted to set text with length=" + textLength + " for TextField with maxLength=" + maxLength + " and name=" + name;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return ExceededMaxLengthError2;
      }(Error)
    );
    exports.ExceededMaxLengthError = ExceededMaxLengthError;
    var InvalidMaxLengthError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidMaxLengthError2, _super);
        function InvalidMaxLengthError2(textLength, maxLength, name) {
          var _this = this;
          var msg = "Attempted to set maxLength=" + maxLength + ", which is less than " + textLength + ", the length of this field's current value (name=" + name + ")";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidMaxLengthError2;
      }(Error)
    );
    exports.InvalidMaxLengthError = InvalidMaxLengthError;
  }
});

// node_modules/pdf-lib/cjs/api/text/alignment.js
var require_alignment = __commonJS({
  "node_modules/pdf-lib/cjs/api/text/alignment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextAlignment = void 0;
    var TextAlignment;
    (function(TextAlignment2) {
      TextAlignment2[TextAlignment2["Left"] = 0] = "Left";
      TextAlignment2[TextAlignment2["Center"] = 1] = "Center";
      TextAlignment2[TextAlignment2["Right"] = 2] = "Right";
    })(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
  }
});

// node_modules/pdf-lib/cjs/api/text/layout.js
var require_layout = __commonJS({
  "node_modules/pdf-lib/cjs/api/text/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.layoutSinglelineText = exports.layoutCombedText = exports.layoutMultilineText = void 0;
    var errors_1 = require_errors3();
    var alignment_1 = require_alignment();
    var utils_1 = require_utils2();
    var MIN_FONT_SIZE = 4;
    var MAX_FONT_SIZE = 500;
    var computeFontSize = function(lines, font, bounds, multiline) {
      if (multiline === void 0) {
        multiline = false;
      }
      var fontSize = MIN_FONT_SIZE;
      while (fontSize < MAX_FONT_SIZE) {
        var linesUsed = 0;
        for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {
          linesUsed += 1;
          var line = lines[lineIdx];
          var words = line.split(" ");
          var spaceInLineRemaining = bounds.width;
          for (var idx = 0, len = words.length; idx < len; idx++) {
            var isLastWord = idx === len - 1;
            var word = isLastWord ? words[idx] : words[idx] + " ";
            var widthOfWord = font.widthOfTextAtSize(word, fontSize);
            spaceInLineRemaining -= widthOfWord;
            if (spaceInLineRemaining <= 0) {
              linesUsed += 1;
              spaceInLineRemaining = bounds.width - widthOfWord;
            }
          }
        }
        if (!multiline && linesUsed > lines.length)
          return fontSize - 1;
        var height = font.heightAtSize(fontSize);
        var lineHeight = height + height * 0.2;
        var totalHeight = lineHeight * linesUsed;
        if (totalHeight > Math.abs(bounds.height))
          return fontSize - 1;
        fontSize += 1;
      }
      return fontSize;
    };
    var computeCombedFontSize = function(line, font, bounds, cellCount) {
      var cellWidth = bounds.width / cellCount;
      var cellHeight = bounds.height;
      var fontSize = MIN_FONT_SIZE;
      var chars = utils_1.charSplit(line);
      while (fontSize < MAX_FONT_SIZE) {
        for (var idx = 0, len = chars.length; idx < len; idx++) {
          var c = chars[idx];
          var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;
          if (tooLong)
            return fontSize - 1;
        }
        var height = font.heightAtSize(fontSize, { descender: false });
        if (height > cellHeight)
          return fontSize - 1;
        fontSize += 1;
      }
      return fontSize;
    };
    var lastIndexOfWhitespace = function(line) {
      for (var idx = line.length; idx > 0; idx--) {
        if (/\s/.test(line[idx]))
          return idx;
      }
      return void 0;
    };
    var splitOutLines = function(input, maxWidth, font, fontSize) {
      var _a;
      var lastWhitespaceIdx = input.length;
      while (lastWhitespaceIdx > 0) {
        var line = input.substring(0, lastWhitespaceIdx);
        var encoded = font.encodeText(line);
        var width = font.widthOfTextAtSize(line, fontSize);
        if (width < maxWidth) {
          var remainder = input.substring(lastWhitespaceIdx) || void 0;
          return { line, encoded, width, remainder };
        }
        lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;
      }
      return {
        line: input,
        encoded: font.encodeText(input),
        width: font.widthOfTextAtSize(input, fontSize),
        remainder: void 0
      };
    };
    exports.layoutMultilineText = function(text, _a) {
      var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
      var lines = utils_1.lineSplit(utils_1.cleanText(text));
      if (fontSize === void 0 || fontSize === 0) {
        fontSize = computeFontSize(lines, font, bounds, true);
      }
      var height = font.heightAtSize(fontSize);
      var lineHeight = height + height * 0.2;
      var textLines = [];
      var minX = bounds.x;
      var minY = bounds.y;
      var maxX = bounds.x + bounds.width;
      var maxY = bounds.y + bounds.height;
      var y = bounds.y + bounds.height;
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        var prevRemainder = lines[idx];
        while (prevRemainder !== void 0) {
          var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;
          var x = alignment === alignment_1.TextAlignment.Left ? bounds.x : alignment === alignment_1.TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === alignment_1.TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
          y -= lineHeight;
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x + width > maxX)
            maxX = x + width;
          if (y + height > maxY)
            maxY = y + height;
          textLines.push({ text: line, encoded, width, height, x, y });
          prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();
        }
      }
      return {
        fontSize,
        lineHeight,
        lines: textLines,
        bounds: {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        }
      };
    };
    exports.layoutCombedText = function(text, _a) {
      var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;
      var line = utils_1.mergeLines(utils_1.cleanText(text));
      if (line.length > cellCount) {
        throw new errors_1.CombedTextLayoutError(line.length, cellCount);
      }
      if (fontSize === void 0 || fontSize === 0) {
        fontSize = computeCombedFontSize(line, font, bounds, cellCount);
      }
      var cellWidth = bounds.width / cellCount;
      var height = font.heightAtSize(fontSize, { descender: false });
      var y = bounds.y + (bounds.height / 2 - height / 2);
      var cells = [];
      var minX = bounds.x;
      var minY = bounds.y;
      var maxX = bounds.x + bounds.width;
      var maxY = bounds.y + bounds.height;
      var cellOffset = 0;
      var charOffset = 0;
      while (cellOffset < cellCount) {
        var _b = utils_1.charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];
        var encoded = font.encodeText(char);
        var width = font.widthOfTextAtSize(char, fontSize);
        var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);
        var x = cellCenter - width / 2;
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x + width > maxX)
          maxX = x + width;
        if (y + height > maxY)
          maxY = y + height;
        cells.push({ text: line, encoded, width, height, x, y });
        cellOffset += 1;
        charOffset += charLength;
      }
      return {
        fontSize,
        cells,
        bounds: {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        }
      };
    };
    exports.layoutSinglelineText = function(text, _a) {
      var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
      var line = utils_1.mergeLines(utils_1.cleanText(text));
      if (fontSize === void 0 || fontSize === 0) {
        fontSize = computeFontSize([line], font, bounds);
      }
      var encoded = font.encodeText(line);
      var width = font.widthOfTextAtSize(line, fontSize);
      var height = font.heightAtSize(fontSize, { descender: false });
      var x = alignment === alignment_1.TextAlignment.Left ? bounds.x : alignment === alignment_1.TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === alignment_1.TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
      var y = bounds.y + (bounds.height / 2 - height / 2);
      return {
        fontSize,
        line: { text: line, encoded, width, height, x, y },
        bounds: { x, y, width, height }
      };
    };
  }
});

// node_modules/pdf-lib/cjs/api/form/appearances.js
var require_appearances = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/appearances.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptionListAppearanceProvider = exports.defaultDropdownAppearanceProvider = exports.defaultTextFieldAppearanceProvider = exports.defaultButtonAppearanceProvider = exports.defaultRadioGroupAppearanceProvider = exports.defaultCheckBoxAppearanceProvider = exports.normalizeAppearance = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var operations_1 = require_operations();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var layout_1 = require_layout();
    var alignment_1 = require_alignment();
    var operators_1 = require_operators();
    var utils_1 = require_utils2();
    exports.normalizeAppearance = function(appearance) {
      if ("normal" in appearance)
        return appearance;
      return { normal: appearance };
    };
    var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/;
    var getDefaultFontSize = function(field) {
      var _a, _b;
      var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
      var daMatch = (_b = utils_1.findLastMatch(da, tfRegex).match) !== null && _b !== void 0 ? _b : [];
      var defaultFontSize = Number(daMatch[2]);
      return isFinite(defaultFontSize) ? defaultFontSize : void 0;
    };
    var colorRegex = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/;
    var getDefaultColor = function(field) {
      var _a;
      var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
      var daMatch = utils_1.findLastMatch(da, colorRegex).match;
      var _b = daMatch !== null && daMatch !== void 0 ? daMatch : [], c1 = _b[1], c2 = _b[2], c3 = _b[3], c4 = _b[4], colorSpace = _b[5];
      if (colorSpace === "g" && c1) {
        return colors_1.grayscale(Number(c1));
      }
      if (colorSpace === "rg" && c1 && c2 && c3) {
        return colors_1.rgb(Number(c1), Number(c2), Number(c3));
      }
      if (colorSpace === "k" && c1 && c2 && c3 && c4) {
        return colors_1.cmyk(Number(c1), Number(c2), Number(c3), Number(c4));
      }
      return void 0;
    };
    var updateDefaultAppearance = function(field, color, font, fontSize) {
      var _a;
      if (fontSize === void 0) {
        fontSize = 0;
      }
      var da = [
        colors_1.setFillingColor(color).toString(),
        operators_1.setFontAndSize((_a = font === null || font === void 0 ? void 0 : font.name) !== null && _a !== void 0 ? _a : "dummy__noop", fontSize).toString()
      ].join("\n");
      field.setDefaultAppearance(da);
    };
    exports.defaultCheckBoxAppearanceProvider = function(checkBox, widget) {
      var _a, _b, _c;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(checkBox.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _d = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = (_b = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var downBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
      var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
      if (widgetColor) {
        updateDefaultAppearance(widget, textColor);
      } else {
        updateDefaultAppearance(checkBox.acroField, textColor);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        thickness: 1.5,
        borderWidth,
        borderColor,
        markColor: textColor
      };
      return {
        normal: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: false })))
        },
        down: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: false })))
        }
      };
    };
    exports.defaultRadioGroupAppearanceProvider = function(radioGroup, widget) {
      var _a, _b, _c;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(radioGroup.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _d = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = (_b = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var downBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
      var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
      if (widgetColor) {
        updateDefaultAppearance(widget, textColor);
      } else {
        updateDefaultAppearance(radioGroup.acroField, textColor);
      }
      var options = {
        x: width / 2,
        y: height / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth,
        borderColor,
        dotColor: textColor
      };
      return {
        normal: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: false })))
        },
        down: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: false })))
        }
      };
    };
    exports.defaultButtonAppearanceProvider = function(button, widget, font) {
      var _a, _b, _c, _d, _e;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(button.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(button.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var captions = ap === null || ap === void 0 ? void 0 : ap.getCaptions();
      var normalText = (_a = captions === null || captions === void 0 ? void 0 : captions.normal) !== null && _a !== void 0 ? _a : "";
      var downText = (_c = (_b = captions === null || captions === void 0 ? void 0 : captions.down) !== null && _b !== void 0 ? _b : normalText) !== null && _c !== void 0 ? _c : "";
      var borderWidth = (_d = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _d !== void 0 ? _d : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _f = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _f.width, height = _f.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var downBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
      var bounds = {
        x: borderWidth,
        y: borderWidth,
        width: width - borderWidth * 2,
        height: height - borderWidth * 2
      };
      var normalLayout = layout_1.layoutSinglelineText(normalText, {
        alignment: alignment_1.TextAlignment.Center,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      });
      var downLayout = layout_1.layoutSinglelineText(downText, {
        alignment: alignment_1.TextAlignment.Center,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      });
      var fontSize = Math.min(normalLayout.fontSize, downLayout.fontSize);
      var textColor = (_e = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _e !== void 0 ? _e : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(button.acroField, textColor, font, fontSize);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth,
        borderColor,
        textColor,
        font: font.name,
        fontSize
      };
      return {
        normal: tslib_1.__spreadArrays(rotate, operations_1.drawButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, textLines: [normalLayout.line] }))),
        down: tslib_1.__spreadArrays(rotate, operations_1.drawButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, textLines: [downLayout.line] })))
      };
    };
    exports.defaultTextFieldAppearanceProvider = function(textField, widget, font) {
      var _a, _b, _c, _d;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(textField.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(textField.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var text = (_a = textField.getText()) !== null && _a !== void 0 ? _a : "";
      var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _e = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _e.width, height = _e.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var textLines;
      var fontSize;
      var padding = textField.isCombed() ? 0 : 1;
      var bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2
      };
      if (textField.isMultiline()) {
        var layout = layout_1.layoutMultilineText(text, {
          alignment: textField.getAlignment(),
          fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
          font,
          bounds
        });
        textLines = layout.lines;
        fontSize = layout.fontSize;
      } else if (textField.isCombed()) {
        var layout = layout_1.layoutCombedText(text, {
          fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
          font,
          bounds,
          cellCount: (_c = textField.getMaxLength()) !== null && _c !== void 0 ? _c : 0
        });
        textLines = layout.cells;
        fontSize = layout.fontSize;
      } else {
        var layout = layout_1.layoutSinglelineText(text, {
          alignment: textField.getAlignment(),
          fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
          font,
          bounds
        });
        textLines = [layout.line];
        fontSize = layout.fontSize;
      }
      var textColor = (_d = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _d !== void 0 ? _d : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(textField.acroField, textColor, font, fontSize);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines,
        padding
      };
      return tslib_1.__spreadArrays(rotate, operations_1.drawTextField(options));
    };
    exports.defaultDropdownAppearanceProvider = function(dropdown, widget, font) {
      var _a, _b, _c;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(dropdown.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(dropdown.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var text = (_a = dropdown.getSelected()[0]) !== null && _a !== void 0 ? _a : "";
      var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _d = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var padding = 1;
      var bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2
      };
      var _e = layout_1.layoutSinglelineText(text, {
        alignment: alignment_1.TextAlignment.Left,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      }), line = _e.line, fontSize = _e.fontSize;
      var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(dropdown.acroField, textColor, font, fontSize);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines: [line],
        padding
      };
      return tslib_1.__spreadArrays(rotate, operations_1.drawTextField(options));
    };
    exports.defaultOptionListAppearanceProvider = function(optionList, widget, font) {
      var _a, _b;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(optionList.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(optionList.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _c = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _c.width, height = _c.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var options = optionList.getOptions();
      var selected = optionList.getSelected();
      if (optionList.isSorted())
        options.sort();
      var text = "";
      for (var idx = 0, len = options.length; idx < len; idx++) {
        text += options[idx];
        if (idx < len - 1)
          text += "\n";
      }
      var padding = 1;
      var bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2
      };
      var _d = layout_1.layoutMultilineText(text, {
        alignment: alignment_1.TextAlignment.Left,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      }), lines = _d.lines, fontSize = _d.fontSize, lineHeight = _d.lineHeight;
      var selectedLines = [];
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        var line = lines[idx];
        if (selected.includes(line.text))
          selectedLines.push(idx);
      }
      var blue = colors_1.rgb(153 / 255, 193 / 255, 218 / 255);
      var textColor = (_b = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _b !== void 0 ? _b : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(optionList.acroField, textColor, font, fontSize);
      }
      return tslib_1.__spreadArrays(rotate, operations_1.drawOptionList({
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines: lines,
        lineHeight,
        selectedColor: blue,
        selectedLines,
        padding
      }));
    };
  }
});

// node_modules/pdf-lib/cjs/api/PDFEmbeddedPage.js
var require_PDFEmbeddedPage = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFEmbeddedPage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFEmbeddedPage = (
      /** @class */
      function() {
        function PDFEmbeddedPage2(ref, doc, embedder) {
          this.alreadyEmbedded = false;
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          utils_1.assertIs(embedder, "embedder", [[core_1.PDFPageEmbedder, "PDFPageEmbedder"]]);
          this.ref = ref;
          this.doc = doc;
          this.width = embedder.width;
          this.height = embedder.height;
          this.embedder = embedder;
        }
        PDFEmbeddedPage2.prototype.scale = function(factor) {
          utils_1.assertIs(factor, "factor", ["number"]);
          return { width: this.width * factor, height: this.height * factor };
        };
        PDFEmbeddedPage2.prototype.size = function() {
          return this.scale(1);
        };
        PDFEmbeddedPage2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.alreadyEmbedded)
                    return [3, 2];
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  _a.sent();
                  this.alreadyEmbedded = true;
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFEmbeddedPage2.of = function(ref, doc, embedder) {
          return new PDFEmbeddedPage2(ref, doc, embedder);
        };
        return PDFEmbeddedPage2;
      }()
    );
    exports.default = PDFEmbeddedPage;
  }
});

// node_modules/pdf-lib/cjs/api/PDFFont.js
var require_PDFFont = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFFont.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFFont = (
      /** @class */
      function() {
        function PDFFont2(ref, doc, embedder) {
          this.modified = true;
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          utils_1.assertIs(embedder, "embedder", [
            [core_1.CustomFontEmbedder, "CustomFontEmbedder"],
            [core_1.StandardFontEmbedder, "StandardFontEmbedder"]
          ]);
          this.ref = ref;
          this.doc = doc;
          this.name = embedder.fontName;
          this.embedder = embedder;
        }
        PDFFont2.prototype.encodeText = function(text) {
          utils_1.assertIs(text, "text", ["string"]);
          this.modified = true;
          return this.embedder.encodeText(text);
        };
        PDFFont2.prototype.widthOfTextAtSize = function(text, size) {
          utils_1.assertIs(text, "text", ["string"]);
          utils_1.assertIs(size, "size", ["number"]);
          return this.embedder.widthOfTextAtSize(text, size);
        };
        PDFFont2.prototype.heightAtSize = function(size, options) {
          var _a;
          utils_1.assertIs(size, "size", ["number"]);
          utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.descender, "options.descender", ["boolean"]);
          return this.embedder.heightOfFontAtSize(size, {
            descender: (_a = options === null || options === void 0 ? void 0 : options.descender) !== null && _a !== void 0 ? _a : true
          });
        };
        PDFFont2.prototype.sizeAtHeight = function(height) {
          utils_1.assertIs(height, "height", ["number"]);
          return this.embedder.sizeOfFontAtHeight(height);
        };
        PDFFont2.prototype.getCharacterSet = function() {
          if (this.embedder instanceof core_1.StandardFontEmbedder) {
            return this.embedder.encoding.supportedCodePoints;
          } else {
            return this.embedder.font.characterSet;
          }
        };
        PDFFont2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this.modified)
                    return [3, 2];
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  _a.sent();
                  this.modified = false;
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFFont2.of = function(ref, doc, embedder) {
          return new PDFFont2(ref, doc, embedder);
        };
        return PDFFont2;
      }()
    );
    exports.default = PDFFont;
  }
});

// node_modules/pdf-lib/cjs/api/PDFImage.js
var require_PDFImage = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFImage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFImage = (
      /** @class */
      function() {
        function PDFImage2(ref, doc, embedder) {
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          utils_1.assertIs(embedder, "embedder", [
            [core_1.JpegEmbedder, "JpegEmbedder"],
            [core_1.PngEmbedder, "PngEmbedder"]
          ]);
          this.ref = ref;
          this.doc = doc;
          this.width = embedder.width;
          this.height = embedder.height;
          this.embedder = embedder;
        }
        PDFImage2.prototype.scale = function(factor) {
          utils_1.assertIs(factor, "factor", ["number"]);
          return { width: this.width * factor, height: this.height * factor };
        };
        PDFImage2.prototype.scaleToFit = function(width, height) {
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var imgWidthScale = width / this.width;
          var imgHeightScale = height / this.height;
          var scale = Math.min(imgWidthScale, imgHeightScale);
          return this.scale(scale);
        };
        PDFImage2.prototype.size = function() {
          return this.scale(1);
        };
        PDFImage2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, doc, ref;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!this.embedder)
                    return [
                      2
                      /*return*/
                    ];
                  if (!this.embedTask) {
                    _a = this, doc = _a.doc, ref = _a.ref;
                    this.embedTask = this.embedder.embedIntoContext(doc.context, ref);
                  }
                  return [4, this.embedTask];
                case 1:
                  _b.sent();
                  this.embedder = void 0;
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFImage2.of = function(ref, doc, embedder) {
          return new PDFImage2(ref, doc, embedder);
        };
        return PDFImage2;
      }()
    );
    exports.default = PDFImage;
  }
});

// node_modules/pdf-lib/cjs/api/image/alignment.js
var require_alignment2 = __commonJS({
  "node_modules/pdf-lib/cjs/api/image/alignment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageAlignment = void 0;
    var ImageAlignment;
    (function(ImageAlignment2) {
      ImageAlignment2[ImageAlignment2["Left"] = 0] = "Left";
      ImageAlignment2[ImageAlignment2["Center"] = 1] = "Center";
      ImageAlignment2[ImageAlignment2["Right"] = 2] = "Right";
    })(ImageAlignment = exports.ImageAlignment || (exports.ImageAlignment = {}));
  }
});

// node_modules/pdf-lib/cjs/api/image/index.js
var require_image = __commonJS({
  "node_modules/pdf-lib/cjs/api/image/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_alignment2(), exports);
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFField.js
var require_PDFField = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFField.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertFieldAppearanceOptions = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var image_1 = require_image();
    var operations_1 = require_operations();
    exports.assertFieldAppearanceOptions = function(options) {
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, "options.x", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, "options.y", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, "options.width", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, "options.height", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, "options.textColor", [
        [Object, "Color"]
      ]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, "options.backgroundColor", [
        [Object, "Color"]
      ]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, "options.borderWidth", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, "options.rotate", [[Object, "Rotation"]]);
    };
    var PDFField = (
      /** @class */
      function() {
        function PDFField2(acroField, ref, doc) {
          utils_1.assertIs(acroField, "acroField", [[core_1.PDFAcroTerminal, "PDFAcroTerminal"]]);
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          this.acroField = acroField;
          this.ref = ref;
          this.doc = doc;
        }
        PDFField2.prototype.getName = function() {
          var _a;
          return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
        };
        PDFField2.prototype.isReadOnly = function() {
          return this.acroField.hasFlag(core_1.AcroFieldFlags.ReadOnly);
        };
        PDFField2.prototype.enableReadOnly = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.ReadOnly, true);
        };
        PDFField2.prototype.disableReadOnly = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.ReadOnly, false);
        };
        PDFField2.prototype.isRequired = function() {
          return this.acroField.hasFlag(core_1.AcroFieldFlags.Required);
        };
        PDFField2.prototype.enableRequired = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.Required, true);
        };
        PDFField2.prototype.disableRequired = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.Required, false);
        };
        PDFField2.prototype.isExported = function() {
          return !this.acroField.hasFlag(core_1.AcroFieldFlags.NoExport);
        };
        PDFField2.prototype.enableExporting = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.NoExport, false);
        };
        PDFField2.prototype.disableExporting = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.NoExport, true);
        };
        PDFField2.prototype.needsAppearancesUpdate = function() {
          throw new core_1.MethodNotImplementedError(this.constructor.name, "needsAppearancesUpdate");
        };
        PDFField2.prototype.defaultUpdateAppearances = function(_font) {
          throw new core_1.MethodNotImplementedError(this.constructor.name, "defaultUpdateAppearances");
        };
        PDFField2.prototype.markAsDirty = function() {
          this.doc.getForm().markFieldAsDirty(this.ref);
        };
        PDFField2.prototype.markAsClean = function() {
          this.doc.getForm().markFieldAsClean(this.ref);
        };
        PDFField2.prototype.isDirty = function() {
          return this.doc.getForm().fieldIsDirty(this.ref);
        };
        PDFField2.prototype.createWidget = function(options) {
          var _a;
          var textColor = options.textColor;
          var backgroundColor = options.backgroundColor;
          var borderColor = options.borderColor;
          var borderWidth = options.borderWidth;
          var degreesAngle = rotations_1.toDegrees(options.rotate);
          var caption = options.caption;
          var x = options.x;
          var y = options.y;
          var width = options.width + borderWidth;
          var height = options.height + borderWidth;
          var hidden = Boolean(options.hidden);
          var pageRef = options.page;
          utils_1.assertMultiple(degreesAngle, "degreesAngle", 90);
          var widget = core_1.PDFWidgetAnnotation.create(this.doc.context, this.ref);
          var rect = rotations_1.rotateRectangle({ x, y, width, height }, borderWidth, degreesAngle);
          widget.setRectangle(rect);
          if (pageRef)
            widget.setP(pageRef);
          var ac = widget.getOrCreateAppearanceCharacteristics();
          if (backgroundColor) {
            ac.setBackgroundColor(colors_1.colorToComponents(backgroundColor));
          }
          ac.setRotation(degreesAngle);
          if (caption)
            ac.setCaptions({ normal: caption });
          if (borderColor)
            ac.setBorderColor(colors_1.colorToComponents(borderColor));
          var bs = widget.getOrCreateBorderStyle();
          if (borderWidth !== void 0)
            bs.setWidth(borderWidth);
          widget.setFlagTo(core_1.AnnotationFlags.Print, true);
          widget.setFlagTo(core_1.AnnotationFlags.Hidden, hidden);
          widget.setFlagTo(core_1.AnnotationFlags.Invisible, false);
          if (textColor) {
            var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
            var newDa = da + "\n" + colors_1.setFillingColor(textColor).toString();
            this.acroField.setDefaultAppearance(newDa);
          }
          return widget;
        };
        PDFField2.prototype.updateWidgetAppearanceWithFont = function(widget, font, _a) {
          var normal = _a.normal, rollover = _a.rollover, down = _a.down;
          this.updateWidgetAppearances(widget, {
            normal: this.createAppearanceStream(widget, normal, font),
            rollover: rollover && this.createAppearanceStream(widget, rollover, font),
            down: down && this.createAppearanceStream(widget, down, font)
          });
        };
        PDFField2.prototype.updateOnOffWidgetAppearance = function(widget, onValue, _a) {
          var normal = _a.normal, rollover = _a.rollover, down = _a.down;
          this.updateWidgetAppearances(widget, {
            normal: this.createAppearanceDict(widget, normal, onValue),
            rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),
            down: down && this.createAppearanceDict(widget, down, onValue)
          });
        };
        PDFField2.prototype.updateWidgetAppearances = function(widget, _a) {
          var normal = _a.normal, rollover = _a.rollover, down = _a.down;
          widget.setNormalAppearance(normal);
          if (rollover) {
            widget.setRolloverAppearance(rollover);
          } else {
            widget.removeRolloverAppearance();
          }
          if (down) {
            widget.setDownAppearance(down);
          } else {
            widget.removeDownAppearance();
          }
        };
        PDFField2.prototype.createAppearanceStream = function(widget, appearance, font) {
          var _a;
          var context = this.acroField.dict.context;
          var _b = widget.getRectangle(), width = _b.width, height = _b.height;
          var Resources = font && { Font: (_a = {}, _a[font.name] = font.ref, _a) };
          var stream = context.formXObject(appearance, {
            Resources,
            BBox: context.obj([0, 0, width, height]),
            Matrix: context.obj([1, 0, 0, 1, 0, 0])
          });
          var streamRef = context.register(stream);
          return streamRef;
        };
        PDFField2.prototype.createImageAppearanceStream = function(widget, image, alignment) {
          var _a;
          var _b;
          var context = this.acroField.dict.context;
          var rectangle = widget.getRectangle();
          var ap = widget.getAppearanceCharacteristics();
          var bs = widget.getBorderStyle();
          var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
          var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
          var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
          var adj = rotations_1.adjustDimsForRotation(rectangle, rotation);
          var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);
          var options = {
            x: borderWidth,
            y: borderWidth,
            width: imageDims.width,
            height: imageDims.height,
            //
            rotate: rotations_1.degrees(0),
            xSkew: rotations_1.degrees(0),
            ySkew: rotations_1.degrees(0)
          };
          if (alignment === image_1.ImageAlignment.Center) {
            options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;
            options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;
          } else if (alignment === image_1.ImageAlignment.Right) {
            options.x = adj.width - borderWidth - imageDims.width;
            options.y = adj.height - borderWidth - imageDims.height;
          }
          var imageName = this.doc.context.addRandomSuffix("Image", 10);
          var appearance = tslib_1.__spreadArrays(rotate, operations_1.drawImage(imageName, options));
          var Resources = { XObject: (_a = {}, _a[imageName] = image.ref, _a) };
          var stream = context.formXObject(appearance, {
            Resources,
            BBox: context.obj([0, 0, rectangle.width, rectangle.height]),
            Matrix: context.obj([1, 0, 0, 1, 0, 0])
          });
          return context.register(stream);
        };
        PDFField2.prototype.createAppearanceDict = function(widget, appearance, onValue) {
          var context = this.acroField.dict.context;
          var onStreamRef = this.createAppearanceStream(widget, appearance.on);
          var offStreamRef = this.createAppearanceStream(widget, appearance.off);
          var appearanceDict = context.obj({});
          appearanceDict.set(onValue, onStreamRef);
          appearanceDict.set(core_1.PDFName.of("Off"), offStreamRef);
          return appearanceDict;
        };
        return PDFField2;
      }()
    );
    exports.default = PDFField;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFCheckBox.js
var require_PDFCheckBox = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFCheckBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFCheckBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFCheckBox2, _super);
        function PDFCheckBox2(acroCheckBox, ref, doc) {
          var _this = _super.call(this, acroCheckBox, ref, doc) || this;
          utils_1.assertIs(acroCheckBox, "acroCheckBox", [
            [core_1.PDFAcroCheckBox, "PDFAcroCheckBox"]
          ]);
          _this.acroField = acroCheckBox;
          return _this;
        }
        PDFCheckBox2.prototype.check = function() {
          var _a;
          var onValue = (_a = this.acroField.getOnValue()) !== null && _a !== void 0 ? _a : core_1.PDFName.of("Yes");
          this.markAsDirty();
          this.acroField.setValue(onValue);
        };
        PDFCheckBox2.prototype.uncheck = function() {
          this.markAsDirty();
          this.acroField.setValue(core_1.PDFName.of("Off"));
        };
        PDFCheckBox2.prototype.isChecked = function() {
          var onValue = this.acroField.getOnValue();
          return !!onValue && onValue === this.acroField.getValue();
        };
        PDFCheckBox2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 50,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          widget.setAppearanceState(core_1.PDFName.of("Off"));
          this.updateWidgetAppearance(widget, core_1.PDFName.of("Yes"));
          page.node.addAnnot(widgetRef);
        };
        PDFCheckBox2.prototype.needsAppearancesUpdate = function() {
          var _a;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getAppearanceState();
            var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
            if (!(normal instanceof core_1.PDFDict))
              return true;
            if (state && !normal.has(state))
              return true;
          }
          return false;
        };
        PDFCheckBox2.prototype.defaultUpdateAppearances = function() {
          this.updateAppearances();
        };
        PDFCheckBox2.prototype.updateAppearances = function(provider) {
          var _a;
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var onValue = (_a = widget.getOnValue()) !== null && _a !== void 0 ? _a : core_1.PDFName.of("Yes");
            if (!onValue)
              continue;
            this.updateWidgetAppearance(widget, onValue, provider);
          }
          this.markAsClean();
        };
        PDFCheckBox2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultCheckBoxAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget));
          this.updateOnOffWidgetAppearance(widget, onValue, appearances);
        };
        PDFCheckBox2.of = function(acroCheckBox, ref, doc) {
          return new PDFCheckBox2(acroCheckBox, ref, doc);
        };
        return PDFCheckBox2;
      }(PDFField_1.default)
    );
    exports.default = PDFCheckBox;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFDropdown.js
var require_PDFDropdown = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFDropdown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFDropdown = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFDropdown2, _super);
        function PDFDropdown2(acroComboBox, ref, doc) {
          var _this = _super.call(this, acroComboBox, ref, doc) || this;
          utils_1.assertIs(acroComboBox, "acroComboBox", [
            [core_1.PDFAcroComboBox, "PDFAcroComboBox"]
          ]);
          _this.acroField = acroComboBox;
          return _this;
        }
        PDFDropdown2.prototype.getOptions = function() {
          var rawOptions = this.acroField.getOptions();
          var options = new Array(rawOptions.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            var _a = rawOptions[idx], display = _a.display, value = _a.value;
            options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
          }
          return options;
        };
        PDFDropdown2.prototype.getSelected = function() {
          var values = this.acroField.getValues();
          var selected = new Array(values.length);
          for (var idx = 0, len = values.length; idx < len; idx++) {
            selected[idx] = values[idx].decodeText();
          }
          return selected;
        };
        PDFDropdown2.prototype.setOptions = function(options) {
          utils_1.assertIs(options, "options", [Array]);
          var optionObjects = new Array(options.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            optionObjects[idx] = { value: core_1.PDFHexString.fromText(options[idx]) };
          }
          this.acroField.setOptions(optionObjects);
        };
        PDFDropdown2.prototype.addOptions = function(options) {
          utils_1.assertIs(options, "options", ["string", Array]);
          var optionsArr = Array.isArray(options) ? options : [options];
          var existingOptions = this.acroField.getOptions();
          var newOptions = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            newOptions[idx] = { value: core_1.PDFHexString.fromText(optionsArr[idx]) };
          }
          this.acroField.setOptions(existingOptions.concat(newOptions));
        };
        PDFDropdown2.prototype.select = function(options, merge) {
          if (merge === void 0) {
            merge = false;
          }
          utils_1.assertIs(options, "options", ["string", Array]);
          utils_1.assertIs(merge, "merge", ["boolean"]);
          var optionsArr = Array.isArray(options) ? options : [options];
          var validOptions = this.getOptions();
          var hasCustomOption = optionsArr.find(function(option) {
            return !validOptions.includes(option);
          });
          if (hasCustomOption)
            this.enableEditing();
          this.markAsDirty();
          if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
            this.enableMultiselect();
          }
          var values = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            values[idx] = core_1.PDFHexString.fromText(optionsArr[idx]);
          }
          if (merge) {
            var existingValues = this.acroField.getValues();
            this.acroField.setValues(existingValues.concat(values));
          } else {
            this.acroField.setValues(values);
          }
        };
        PDFDropdown2.prototype.clear = function() {
          this.markAsDirty();
          this.acroField.setValues([]);
        };
        PDFDropdown2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFDropdown2.prototype.isEditable = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.Edit);
        };
        PDFDropdown2.prototype.enableEditing = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Edit, true);
        };
        PDFDropdown2.prototype.disableEditing = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Edit, false);
        };
        PDFDropdown2.prototype.isSorted = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.Sort);
        };
        PDFDropdown2.prototype.enableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, true);
        };
        PDFDropdown2.prototype.disableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, false);
        };
        PDFDropdown2.prototype.isMultiselect = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.MultiSelect);
        };
        PDFDropdown2.prototype.enableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, true);
        };
        PDFDropdown2.prototype.disableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, false);
        };
        PDFDropdown2.prototype.isSpellChecked = function() {
          return !this.acroField.hasFlag(core_1.AcroChoiceFlags.DoNotSpellCheck);
        };
        PDFDropdown2.prototype.enableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.DoNotSpellCheck, false);
        };
        PDFDropdown2.prototype.disableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.DoNotSpellCheck, true);
        };
        PDFDropdown2.prototype.isSelectOnClick = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.CommitOnSelChange);
        };
        PDFDropdown2.prototype.enableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, true);
        };
        PDFDropdown2.prototype.disableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, false);
        };
        PDFDropdown2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFDropdown2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFDropdown2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFDropdown2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
          this.markAsClean();
        };
        PDFDropdown2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultDropdownAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFDropdown2.of = function(acroComboBox, ref, doc) {
          return new PDFDropdown2(acroComboBox, ref, doc);
        };
        return PDFDropdown2;
      }(PDFField_1.default)
    );
    exports.default = PDFDropdown;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFOptionList.js
var require_PDFOptionList = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFOptionList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFOptionList = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFOptionList2, _super);
        function PDFOptionList2(acroListBox, ref, doc) {
          var _this = _super.call(this, acroListBox, ref, doc) || this;
          utils_1.assertIs(acroListBox, "acroListBox", [[core_1.PDFAcroListBox, "PDFAcroListBox"]]);
          _this.acroField = acroListBox;
          return _this;
        }
        PDFOptionList2.prototype.getOptions = function() {
          var rawOptions = this.acroField.getOptions();
          var options = new Array(rawOptions.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            var _a = rawOptions[idx], display = _a.display, value = _a.value;
            options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
          }
          return options;
        };
        PDFOptionList2.prototype.getSelected = function() {
          var values = this.acroField.getValues();
          var selected = new Array(values.length);
          for (var idx = 0, len = values.length; idx < len; idx++) {
            selected[idx] = values[idx].decodeText();
          }
          return selected;
        };
        PDFOptionList2.prototype.setOptions = function(options) {
          utils_1.assertIs(options, "options", [Array]);
          this.markAsDirty();
          var optionObjects = new Array(options.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            optionObjects[idx] = { value: core_1.PDFHexString.fromText(options[idx]) };
          }
          this.acroField.setOptions(optionObjects);
        };
        PDFOptionList2.prototype.addOptions = function(options) {
          utils_1.assertIs(options, "options", ["string", Array]);
          this.markAsDirty();
          var optionsArr = Array.isArray(options) ? options : [options];
          var existingOptions = this.acroField.getOptions();
          var newOptions = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            newOptions[idx] = { value: core_1.PDFHexString.fromText(optionsArr[idx]) };
          }
          this.acroField.setOptions(existingOptions.concat(newOptions));
        };
        PDFOptionList2.prototype.select = function(options, merge) {
          if (merge === void 0) {
            merge = false;
          }
          utils_1.assertIs(options, "options", ["string", Array]);
          utils_1.assertIs(merge, "merge", ["boolean"]);
          var optionsArr = Array.isArray(options) ? options : [options];
          var validOptions = this.getOptions();
          utils_1.assertIsSubset(optionsArr, "option", validOptions);
          this.markAsDirty();
          if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
            this.enableMultiselect();
          }
          var values = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            values[idx] = core_1.PDFHexString.fromText(optionsArr[idx]);
          }
          if (merge) {
            var existingValues = this.acroField.getValues();
            this.acroField.setValues(existingValues.concat(values));
          } else {
            this.acroField.setValues(values);
          }
        };
        PDFOptionList2.prototype.clear = function() {
          this.markAsDirty();
          this.acroField.setValues([]);
        };
        PDFOptionList2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFOptionList2.prototype.isSorted = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.Sort);
        };
        PDFOptionList2.prototype.enableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, true);
        };
        PDFOptionList2.prototype.disableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, false);
        };
        PDFOptionList2.prototype.isMultiselect = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.MultiSelect);
        };
        PDFOptionList2.prototype.enableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, true);
        };
        PDFOptionList2.prototype.disableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, false);
        };
        PDFOptionList2.prototype.isSelectOnClick = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.CommitOnSelChange);
        };
        PDFOptionList2.prototype.enableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, true);
        };
        PDFOptionList2.prototype.disableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, false);
        };
        PDFOptionList2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFOptionList2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFOptionList2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFOptionList2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
          this.markAsClean();
        };
        PDFOptionList2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultOptionListAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFOptionList2.of = function(acroListBox, ref, doc) {
          return new PDFOptionList2(acroListBox, ref, doc);
        };
        return PDFOptionList2;
      }(PDFField_1.default)
    );
    exports.default = PDFOptionList;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFRadioGroup.js
var require_PDFRadioGroup = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFRadioGroup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFRadioGroup = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFRadioGroup2, _super);
        function PDFRadioGroup2(acroRadioButton, ref, doc) {
          var _this = _super.call(this, acroRadioButton, ref, doc) || this;
          utils_1.assertIs(acroRadioButton, "acroRadioButton", [
            [core_1.PDFAcroRadioButton, "PDFAcroRadioButton"]
          ]);
          _this.acroField = acroRadioButton;
          return _this;
        }
        PDFRadioGroup2.prototype.getOptions = function() {
          var exportValues = this.acroField.getExportValues();
          if (exportValues) {
            var exportOptions = new Array(exportValues.length);
            for (var idx = 0, len = exportValues.length; idx < len; idx++) {
              exportOptions[idx] = exportValues[idx].decodeText();
            }
            return exportOptions;
          }
          var onValues = this.acroField.getOnValues();
          var onOptions = new Array(onValues.length);
          for (var idx = 0, len = onOptions.length; idx < len; idx++) {
            onOptions[idx] = onValues[idx].decodeText();
          }
          return onOptions;
        };
        PDFRadioGroup2.prototype.getSelected = function() {
          var value = this.acroField.getValue();
          if (value === core_1.PDFName.of("Off"))
            return void 0;
          var exportValues = this.acroField.getExportValues();
          if (exportValues) {
            var onValues = this.acroField.getOnValues();
            for (var idx = 0, len = onValues.length; idx < len; idx++) {
              if (onValues[idx] === value)
                return exportValues[idx].decodeText();
            }
          }
          return value.decodeText();
        };
        PDFRadioGroup2.prototype.select = function(option) {
          utils_1.assertIs(option, "option", ["string"]);
          var validOptions = this.getOptions();
          utils_1.assertIsOneOf(option, "option", validOptions);
          this.markAsDirty();
          var onValues = this.acroField.getOnValues();
          var exportValues = this.acroField.getExportValues();
          if (exportValues) {
            for (var idx = 0, len = exportValues.length; idx < len; idx++) {
              if (exportValues[idx].decodeText() === option) {
                this.acroField.setValue(onValues[idx]);
              }
            }
          } else {
            for (var idx = 0, len = onValues.length; idx < len; idx++) {
              var value = onValues[idx];
              if (value.decodeText() === option)
                this.acroField.setValue(value);
            }
          }
        };
        PDFRadioGroup2.prototype.clear = function() {
          this.markAsDirty();
          this.acroField.setValue(core_1.PDFName.of("Off"));
        };
        PDFRadioGroup2.prototype.isOffToggleable = function() {
          return !this.acroField.hasFlag(core_1.AcroButtonFlags.NoToggleToOff);
        };
        PDFRadioGroup2.prototype.enableOffToggling = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.NoToggleToOff, false);
        };
        PDFRadioGroup2.prototype.disableOffToggling = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.NoToggleToOff, true);
        };
        PDFRadioGroup2.prototype.isMutuallyExclusive = function() {
          return !this.acroField.hasFlag(core_1.AcroButtonFlags.RadiosInUnison);
        };
        PDFRadioGroup2.prototype.enableMutualExclusion = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.RadiosInUnison, false);
        };
        PDFRadioGroup2.prototype.disableMutualExclusion = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.RadiosInUnison, true);
        };
        PDFRadioGroup2.prototype.addOptionToPage = function(option, page, options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          utils_1.assertIs(option, "option", ["string"]);
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          var widget = this.createWidget({
            x: (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : 50,
            height: (_d = options === null || options === void 0 ? void 0 : options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: (_e = options === null || options === void 0 ? void 0 : options.textColor) !== null && _e !== void 0 ? _e : colors_1.rgb(0, 0, 0),
            backgroundColor: (_f = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _f !== void 0 ? _f : colors_1.rgb(1, 1, 1),
            borderColor: (_g = options === null || options === void 0 ? void 0 : options.borderColor) !== null && _g !== void 0 ? _g : colors_1.rgb(0, 0, 0),
            borderWidth: (_h = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _h !== void 0 ? _h : 1,
            rotate: (_j = options === null || options === void 0 ? void 0 : options.rotate) !== null && _j !== void 0 ? _j : rotations_1.degrees(0),
            hidden: options === null || options === void 0 ? void 0 : options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          var apStateValue = this.acroField.addWidgetWithOpt(widgetRef, core_1.PDFHexString.fromText(option), !this.isMutuallyExclusive());
          widget.setAppearanceState(core_1.PDFName.of("Off"));
          this.updateWidgetAppearance(widget, apStateValue);
          page.node.addAnnot(widgetRef);
        };
        PDFRadioGroup2.prototype.needsAppearancesUpdate = function() {
          var _a;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getAppearanceState();
            var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
            if (!(normal instanceof core_1.PDFDict))
              return true;
            if (state && !normal.has(state))
              return true;
          }
          return false;
        };
        PDFRadioGroup2.prototype.defaultUpdateAppearances = function() {
          this.updateAppearances();
        };
        PDFRadioGroup2.prototype.updateAppearances = function(provider) {
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var onValue = widget.getOnValue();
            if (!onValue)
              continue;
            this.updateWidgetAppearance(widget, onValue, provider);
          }
        };
        PDFRadioGroup2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultRadioGroupAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget));
          this.updateOnOffWidgetAppearance(widget, onValue, appearances);
        };
        PDFRadioGroup2.of = function(acroRadioButton, ref, doc) {
          return new PDFRadioGroup2(acroRadioButton, ref, doc);
        };
        return PDFRadioGroup2;
      }(PDFField_1.default)
    );
    exports.default = PDFRadioGroup;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFSignature.js
var require_PDFSignature = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFField_1 = tslib_1.__importDefault(require_PDFField());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFSignature = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFSignature2, _super);
        function PDFSignature2(acroSignature, ref, doc) {
          var _this = _super.call(this, acroSignature, ref, doc) || this;
          utils_1.assertIs(acroSignature, "acroSignature", [
            [core_1.PDFAcroSignature, "PDFAcroSignature"]
          ]);
          _this.acroField = acroSignature;
          return _this;
        }
        PDFSignature2.prototype.needsAppearancesUpdate = function() {
          return false;
        };
        PDFSignature2.of = function(acroSignature, ref, doc) {
          return new PDFSignature2(acroSignature, ref, doc);
        };
        return PDFSignature2;
      }(PDFField_1.default)
    );
    exports.default = PDFSignature;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFTextField.js
var require_PDFTextField = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFTextField.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var errors_1 = require_errors3();
    var alignment_1 = require_alignment2();
    var alignment_2 = require_alignment();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFTextField = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFTextField2, _super);
        function PDFTextField2(acroText, ref, doc) {
          var _this = _super.call(this, acroText, ref, doc) || this;
          utils_1.assertIs(acroText, "acroText", [[core_1.PDFAcroText, "PDFAcroText"]]);
          _this.acroField = acroText;
          return _this;
        }
        PDFTextField2.prototype.getText = function() {
          var value = this.acroField.getValue();
          if (!value && this.isRichFormatted()) {
            throw new errors_1.RichTextFieldReadError(this.getName());
          }
          return value === null || value === void 0 ? void 0 : value.decodeText();
        };
        PDFTextField2.prototype.setText = function(text) {
          utils_1.assertOrUndefined(text, "text", ["string"]);
          var maxLength = this.getMaxLength();
          if (maxLength !== void 0 && text && text.length > maxLength) {
            throw new errors_1.ExceededMaxLengthError(text.length, maxLength, this.getName());
          }
          this.markAsDirty();
          this.disableRichFormatting();
          if (text) {
            this.acroField.setValue(core_1.PDFHexString.fromText(text));
          } else {
            this.acroField.removeValue();
          }
        };
        PDFTextField2.prototype.getAlignment = function() {
          var quadding = this.acroField.getQuadding();
          return quadding === 0 ? alignment_2.TextAlignment.Left : quadding === 1 ? alignment_2.TextAlignment.Center : quadding === 2 ? alignment_2.TextAlignment.Right : alignment_2.TextAlignment.Left;
        };
        PDFTextField2.prototype.setAlignment = function(alignment) {
          utils_1.assertIsOneOf(alignment, "alignment", alignment_2.TextAlignment);
          this.markAsDirty();
          this.acroField.setQuadding(alignment);
        };
        PDFTextField2.prototype.getMaxLength = function() {
          return this.acroField.getMaxLength();
        };
        PDFTextField2.prototype.setMaxLength = function(maxLength) {
          utils_1.assertRangeOrUndefined(maxLength, "maxLength", 0, Number.MAX_SAFE_INTEGER);
          this.markAsDirty();
          if (maxLength === void 0) {
            this.acroField.removeMaxLength();
          } else {
            var text = this.getText();
            if (text && text.length > maxLength) {
              throw new errors_1.InvalidMaxLengthError(text.length, maxLength, this.getName());
            }
            this.acroField.setMaxLength(maxLength);
          }
        };
        PDFTextField2.prototype.removeMaxLength = function() {
          this.markAsDirty();
          this.acroField.removeMaxLength();
        };
        PDFTextField2.prototype.setImage = function(image) {
          var fieldAlignment = this.getAlignment();
          var alignment = fieldAlignment === alignment_2.TextAlignment.Center ? alignment_1.ImageAlignment.Center : fieldAlignment === alignment_2.TextAlignment.Right ? alignment_1.ImageAlignment.Right : alignment_1.ImageAlignment.Left;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var streamRef = this.createImageAppearanceStream(widget, image, alignment);
            this.updateWidgetAppearances(widget, { normal: streamRef });
          }
          this.markAsClean();
        };
        PDFTextField2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFTextField2.prototype.isMultiline = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.Multiline);
        };
        PDFTextField2.prototype.enableMultiline = function() {
          this.markAsDirty();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Multiline, true);
        };
        PDFTextField2.prototype.disableMultiline = function() {
          this.markAsDirty();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Multiline, false);
        };
        PDFTextField2.prototype.isPassword = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.Password);
        };
        PDFTextField2.prototype.enablePassword = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.Password, true);
        };
        PDFTextField2.prototype.disablePassword = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.Password, false);
        };
        PDFTextField2.prototype.isFileSelector = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.FileSelect);
        };
        PDFTextField2.prototype.enableFileSelection = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.FileSelect, true);
        };
        PDFTextField2.prototype.disableFileSelection = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.FileSelect, false);
        };
        PDFTextField2.prototype.isSpellChecked = function() {
          return !this.acroField.hasFlag(core_1.AcroTextFlags.DoNotSpellCheck);
        };
        PDFTextField2.prototype.enableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotSpellCheck, false);
        };
        PDFTextField2.prototype.disableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotSpellCheck, true);
        };
        PDFTextField2.prototype.isScrollable = function() {
          return !this.acroField.hasFlag(core_1.AcroTextFlags.DoNotScroll);
        };
        PDFTextField2.prototype.enableScrolling = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotScroll, false);
        };
        PDFTextField2.prototype.disableScrolling = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotScroll, true);
        };
        PDFTextField2.prototype.isCombed = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== void 0;
        };
        PDFTextField2.prototype.enableCombing = function() {
          if (this.getMaxLength() === void 0) {
            var msg = "PDFTextFields must have a max length in order to be combed";
            console.warn(msg);
          }
          this.markAsDirty();
          this.disableMultiline();
          this.disablePassword();
          this.disableFileSelection();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Comb, true);
        };
        PDFTextField2.prototype.disableCombing = function() {
          this.markAsDirty();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Comb, false);
        };
        PDFTextField2.prototype.isRichFormatted = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.RichText);
        };
        PDFTextField2.prototype.enableRichFormatting = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.RichText, true);
        };
        PDFTextField2.prototype.disableRichFormatting = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.RichText, false);
        };
        PDFTextField2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFTextField2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFTextField2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFTextField2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
          this.markAsClean();
        };
        PDFTextField2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultTextFieldAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFTextField2.of = function(acroText, ref, doc) {
          return new PDFTextField2(acroText, ref, doc);
        };
        return PDFTextField2;
      }(PDFField_1.default)
    );
    exports.default = PDFTextField;
  }
});

// node_modules/pdf-lib/cjs/api/StandardFonts.js
var require_StandardFonts = __commonJS({
  "node_modules/pdf-lib/cjs/api/StandardFonts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StandardFonts = void 0;
    var StandardFonts;
    (function(StandardFonts2) {
      StandardFonts2["Courier"] = "Courier";
      StandardFonts2["CourierBold"] = "Courier-Bold";
      StandardFonts2["CourierOblique"] = "Courier-Oblique";
      StandardFonts2["CourierBoldOblique"] = "Courier-BoldOblique";
      StandardFonts2["Helvetica"] = "Helvetica";
      StandardFonts2["HelveticaBold"] = "Helvetica-Bold";
      StandardFonts2["HelveticaOblique"] = "Helvetica-Oblique";
      StandardFonts2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
      StandardFonts2["TimesRoman"] = "Times-Roman";
      StandardFonts2["TimesRomanBold"] = "Times-Bold";
      StandardFonts2["TimesRomanItalic"] = "Times-Italic";
      StandardFonts2["TimesRomanBoldItalic"] = "Times-BoldItalic";
      StandardFonts2["Symbol"] = "Symbol";
      StandardFonts2["ZapfDingbats"] = "ZapfDingbats";
    })(StandardFonts = exports.StandardFonts || (exports.StandardFonts = {}));
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFForm.js
var require_PDFForm = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFForm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var PDFButton_1 = tslib_1.__importDefault(require_PDFButton());
    var PDFCheckBox_1 = tslib_1.__importDefault(require_PDFCheckBox());
    var PDFDropdown_1 = tslib_1.__importDefault(require_PDFDropdown());
    var PDFOptionList_1 = tslib_1.__importDefault(require_PDFOptionList());
    var PDFRadioGroup_1 = tslib_1.__importDefault(require_PDFRadioGroup());
    var PDFSignature_1 = tslib_1.__importDefault(require_PDFSignature());
    var PDFTextField_1 = tslib_1.__importDefault(require_PDFTextField());
    var errors_1 = require_errors3();
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var StandardFonts_1 = require_StandardFonts();
    var operations_1 = require_operations();
    var operators_1 = require_operators();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFForm = (
      /** @class */
      function() {
        function PDFForm2(acroForm, doc) {
          var _this = this;
          this.embedDefaultFont = function() {
            return _this.doc.embedStandardFont(StandardFonts_1.StandardFonts.Helvetica);
          };
          utils_1.assertIs(acroForm, "acroForm", [[core_1.PDFAcroForm, "PDFAcroForm"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          this.acroForm = acroForm;
          this.doc = doc;
          this.dirtyFields = /* @__PURE__ */ new Set();
          this.defaultFontCache = utils_1.Cache.populatedBy(this.embedDefaultFont);
        }
        PDFForm2.prototype.hasXFA = function() {
          return this.acroForm.dict.has(core_1.PDFName.of("XFA"));
        };
        PDFForm2.prototype.deleteXFA = function() {
          this.acroForm.dict.delete(core_1.PDFName.of("XFA"));
        };
        PDFForm2.prototype.getFields = function() {
          var allFields = this.acroForm.getAllFields();
          var fields = [];
          for (var idx = 0, len = allFields.length; idx < len; idx++) {
            var _a = allFields[idx], acroField = _a[0], ref = _a[1];
            var field = convertToPDFField(acroField, ref, this.doc);
            if (field)
              fields.push(field);
          }
          return fields;
        };
        PDFForm2.prototype.getFieldMaybe = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var fields = this.getFields();
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var field = fields[idx];
            if (field.getName() === name)
              return field;
          }
          return void 0;
        };
        PDFForm2.prototype.getField = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getFieldMaybe(name);
          if (field)
            return field;
          throw new errors_1.NoSuchFieldError(name);
        };
        PDFForm2.prototype.getButton = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFButton_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFButton_1.default, field);
        };
        PDFForm2.prototype.getCheckBox = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFCheckBox_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFCheckBox_1.default, field);
        };
        PDFForm2.prototype.getDropdown = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFDropdown_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFDropdown_1.default, field);
        };
        PDFForm2.prototype.getOptionList = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFOptionList_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFOptionList_1.default, field);
        };
        PDFForm2.prototype.getRadioGroup = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFRadioGroup_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFRadioGroup_1.default, field);
        };
        PDFForm2.prototype.getSignature = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFSignature_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFSignature_1.default, field);
        };
        PDFForm2.prototype.getTextField = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFTextField_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFTextField_1.default, field);
        };
        PDFForm2.prototype.createButton = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var button = core_1.PDFAcroPushButton.create(this.doc.context);
          button.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [button, button.ref], nameParts.terminal);
          return PDFButton_1.default.of(button, button.ref, this.doc);
        };
        PDFForm2.prototype.createCheckBox = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var checkBox = core_1.PDFAcroCheckBox.create(this.doc.context);
          checkBox.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);
          return PDFCheckBox_1.default.of(checkBox, checkBox.ref, this.doc);
        };
        PDFForm2.prototype.createDropdown = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var comboBox = core_1.PDFAcroComboBox.create(this.doc.context);
          comboBox.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);
          return PDFDropdown_1.default.of(comboBox, comboBox.ref, this.doc);
        };
        PDFForm2.prototype.createOptionList = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var listBox = core_1.PDFAcroListBox.create(this.doc.context);
          listBox.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);
          return PDFOptionList_1.default.of(listBox, listBox.ref, this.doc);
        };
        PDFForm2.prototype.createRadioGroup = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var radioButton = core_1.PDFAcroRadioButton.create(this.doc.context);
          radioButton.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [radioButton, radioButton.ref], nameParts.terminal);
          return PDFRadioGroup_1.default.of(radioButton, radioButton.ref, this.doc);
        };
        PDFForm2.prototype.createTextField = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var text = core_1.PDFAcroText.create(this.doc.context);
          text.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [text, text.ref], nameParts.terminal);
          return PDFTextField_1.default.of(text, text.ref, this.doc);
        };
        PDFForm2.prototype.flatten = function(options) {
          if (options === void 0) {
            options = { updateFieldAppearances: true };
          }
          if (options.updateFieldAppearances) {
            this.updateFieldAppearances();
          }
          var fields = this.getFields();
          for (var i = 0, lenFields = fields.length; i < lenFields; i++) {
            var field = fields[i];
            var widgets = field.acroField.getWidgets();
            for (var j = 0, lenWidgets = widgets.length; j < lenWidgets; j++) {
              var widget = widgets[j];
              var page = this.findWidgetPage(widget);
              var widgetRef = this.findWidgetAppearanceRef(field, widget);
              var xObjectKey = page.node.newXObject("FlatWidget", widgetRef);
              var rectangle = widget.getRectangle();
              var operators = tslib_1.__spreadArrays([
                operators_1.pushGraphicsState(),
                operators_1.translate(rectangle.x, rectangle.y)
              ], operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation: 0 })), [
                operators_1.drawObject(xObjectKey),
                operators_1.popGraphicsState()
              ]).filter(Boolean);
              page.pushOperators.apply(page, operators);
            }
            this.removeField(field);
          }
        };
        PDFForm2.prototype.removeField = function(field) {
          var widgets = field.acroField.getWidgets();
          var pages = /* @__PURE__ */ new Set();
          for (var i = 0, len = widgets.length; i < len; i++) {
            var widget = widgets[i];
            var widgetRef = this.findWidgetAppearanceRef(field, widget);
            var page = this.findWidgetPage(widget);
            pages.add(page);
            page.node.removeAnnot(widgetRef);
          }
          pages.forEach(function(page2) {
            return page2.node.removeAnnot(field.ref);
          });
          this.acroForm.removeField(field.acroField);
          var fieldKids = field.acroField.normalizedEntries().Kids;
          var kidsCount = fieldKids.size();
          for (var childIndex = 0; childIndex < kidsCount; childIndex++) {
            var child = fieldKids.get(childIndex);
            if (child instanceof core_1.PDFRef) {
              this.doc.context.delete(child);
            }
          }
          this.doc.context.delete(field.ref);
        };
        PDFForm2.prototype.updateFieldAppearances = function(font) {
          utils_1.assertOrUndefined(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          font = font !== null && font !== void 0 ? font : this.getDefaultFont();
          var fields = this.getFields();
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var field = fields[idx];
            if (field.needsAppearancesUpdate()) {
              field.defaultUpdateAppearances(font);
            }
          }
        };
        PDFForm2.prototype.markFieldAsDirty = function(fieldRef) {
          utils_1.assertOrUndefined(fieldRef, "fieldRef", [[core_1.PDFRef, "PDFRef"]]);
          this.dirtyFields.add(fieldRef);
        };
        PDFForm2.prototype.markFieldAsClean = function(fieldRef) {
          utils_1.assertOrUndefined(fieldRef, "fieldRef", [[core_1.PDFRef, "PDFRef"]]);
          this.dirtyFields.delete(fieldRef);
        };
        PDFForm2.prototype.fieldIsDirty = function(fieldRef) {
          utils_1.assertOrUndefined(fieldRef, "fieldRef", [[core_1.PDFRef, "PDFRef"]]);
          return this.dirtyFields.has(fieldRef);
        };
        PDFForm2.prototype.getDefaultFont = function() {
          return this.defaultFontCache.access();
        };
        PDFForm2.prototype.findWidgetPage = function(widget) {
          var pageRef = widget.P();
          var page = this.doc.getPages().find(function(x) {
            return x.ref === pageRef;
          });
          if (page === void 0) {
            var widgetRef = this.doc.context.getObjectRef(widget.dict);
            if (widgetRef === void 0) {
              throw new Error("Could not find PDFRef for PDFObject");
            }
            page = this.doc.findPageForAnnotationRef(widgetRef);
            if (page === void 0) {
              throw new Error("Could not find page for PDFRef " + widgetRef);
            }
          }
          return page;
        };
        PDFForm2.prototype.findWidgetAppearanceRef = function(field, widget) {
          var _a;
          var refOrDict = widget.getNormalAppearance();
          if (refOrDict instanceof core_1.PDFDict && (field instanceof PDFCheckBox_1.default || field instanceof PDFRadioGroup_1.default)) {
            var value = field.acroField.getValue();
            var ref = (_a = refOrDict.get(value)) !== null && _a !== void 0 ? _a : refOrDict.get(core_1.PDFName.of("Off"));
            if (ref instanceof core_1.PDFRef) {
              refOrDict = ref;
            }
          }
          if (!(refOrDict instanceof core_1.PDFRef)) {
            var name_1 = field.getName();
            throw new Error("Failed to extract appearance ref for: " + name_1);
          }
          return refOrDict;
        };
        PDFForm2.prototype.findOrCreateNonTerminals = function(partialNames) {
          var nonTerminal = [
            this.acroForm
          ];
          for (var idx = 0, len = partialNames.length; idx < len; idx++) {
            var namePart = partialNames[idx];
            if (!namePart)
              throw new errors_1.InvalidFieldNamePartError(namePart);
            var parent_1 = nonTerminal[0], parentRef = nonTerminal[1];
            var res = this.findNonTerminal(namePart, parent_1);
            if (res) {
              nonTerminal = res;
            } else {
              var node = core_1.PDFAcroNonTerminal.create(this.doc.context);
              node.setPartialName(namePart);
              node.setParent(parentRef);
              var nodeRef = this.doc.context.register(node.dict);
              parent_1.addField(nodeRef);
              nonTerminal = [node, nodeRef];
            }
          }
          return nonTerminal;
        };
        PDFForm2.prototype.findNonTerminal = function(partialName, parent) {
          var fields = parent instanceof core_1.PDFAcroForm ? this.acroForm.getFields() : core_1.createPDFAcroFields(parent.Kids());
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var _a = fields[idx], field = _a[0], ref = _a[1];
            if (field.getPartialName() === partialName) {
              if (field instanceof core_1.PDFAcroNonTerminal)
                return [field, ref];
              throw new errors_1.FieldAlreadyExistsError(partialName);
            }
          }
          return void 0;
        };
        PDFForm2.of = function(acroForm, doc) {
          return new PDFForm2(acroForm, doc);
        };
        return PDFForm2;
      }()
    );
    exports.default = PDFForm;
    var convertToPDFField = function(field, ref, doc) {
      if (field instanceof core_1.PDFAcroPushButton)
        return PDFButton_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroCheckBox)
        return PDFCheckBox_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroComboBox)
        return PDFDropdown_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroListBox)
        return PDFOptionList_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroText)
        return PDFTextField_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroRadioButton) {
        return PDFRadioGroup_1.default.of(field, ref, doc);
      }
      if (field instanceof core_1.PDFAcroSignature) {
        return PDFSignature_1.default.of(field, ref, doc);
      }
      return void 0;
    };
    var splitFieldName = function(fullyQualifiedName) {
      if (fullyQualifiedName.length === 0) {
        throw new Error("PDF field names must not be empty strings");
      }
      var parts = fullyQualifiedName.split(".");
      for (var idx = 0, len = parts.length; idx < len; idx++) {
        if (parts[idx] === "") {
          throw new Error('Periods in PDF field names must be separated by at least one character: "' + fullyQualifiedName + '"');
        }
      }
      if (parts.length === 1)
        return { nonTerminal: [], terminal: parts[0] };
      return {
        nonTerminal: parts.slice(0, parts.length - 1),
        terminal: parts[parts.length - 1]
      };
    };
    var addFieldToParent = function(_a, _b, partialName) {
      var parent = _a[0], parentRef = _a[1];
      var field = _b[0], fieldRef = _b[1];
      var entries = parent.normalizedEntries();
      var fields = core_1.createPDFAcroFields("Kids" in entries ? entries.Kids : entries.Fields);
      for (var idx = 0, len = fields.length; idx < len; idx++) {
        if (fields[idx][0].getPartialName() === partialName) {
          throw new errors_1.FieldAlreadyExistsError(partialName);
        }
      }
      parent.addField(fieldRef);
      field.setParent(parentRef);
    };
  }
});

// node_modules/pdf-lib/cjs/api/sizes.js
var require_sizes = __commonJS({
  "node_modules/pdf-lib/cjs/api/sizes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageSizes = void 0;
    exports.PageSizes = {
      "4A0": [4767.87, 6740.79],
      "2A0": [3370.39, 4767.87],
      A0: [2383.94, 3370.39],
      A1: [1683.78, 2383.94],
      A2: [1190.55, 1683.78],
      A3: [841.89, 1190.55],
      A4: [595.28, 841.89],
      A5: [419.53, 595.28],
      A6: [297.64, 419.53],
      A7: [209.76, 297.64],
      A8: [147.4, 209.76],
      A9: [104.88, 147.4],
      A10: [73.7, 104.88],
      B0: [2834.65, 4008.19],
      B1: [2004.09, 2834.65],
      B2: [1417.32, 2004.09],
      B3: [1000.63, 1417.32],
      B4: [708.66, 1000.63],
      B5: [498.9, 708.66],
      B6: [354.33, 498.9],
      B7: [249.45, 354.33],
      B8: [175.75, 249.45],
      B9: [124.72, 175.75],
      B10: [87.87, 124.72],
      C0: [2599.37, 3676.54],
      C1: [1836.85, 2599.37],
      C2: [1298.27, 1836.85],
      C3: [918.43, 1298.27],
      C4: [649.13, 918.43],
      C5: [459.21, 649.13],
      C6: [323.15, 459.21],
      C7: [229.61, 323.15],
      C8: [161.57, 229.61],
      C9: [113.39, 161.57],
      C10: [79.37, 113.39],
      RA0: [2437.8, 3458.27],
      RA1: [1729.13, 2437.8],
      RA2: [1218.9, 1729.13],
      RA3: [864.57, 1218.9],
      RA4: [609.45, 864.57],
      SRA0: [2551.18, 3628.35],
      SRA1: [1814.17, 2551.18],
      SRA2: [1275.59, 1814.17],
      SRA3: [907.09, 1275.59],
      SRA4: [637.8, 907.09],
      Executive: [521.86, 756],
      Folio: [612, 936],
      Legal: [612, 1008],
      Letter: [612, 792],
      Tabloid: [792, 1224]
    };
  }
});

// node_modules/pdf-lib/cjs/api/PDFDocumentOptions.js
var require_PDFDocumentOptions = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFDocumentOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseSpeeds = void 0;
    var ParseSpeeds;
    (function(ParseSpeeds2) {
      ParseSpeeds2[ParseSpeeds2["Fastest"] = Infinity] = "Fastest";
      ParseSpeeds2[ParseSpeeds2["Fast"] = 1500] = "Fast";
      ParseSpeeds2[ParseSpeeds2["Medium"] = 500] = "Medium";
      ParseSpeeds2[ParseSpeeds2["Slow"] = 100] = "Slow";
    })(ParseSpeeds = exports.ParseSpeeds || (exports.ParseSpeeds = {}));
  }
});

// node_modules/pdf-lib/cjs/api/PDFEmbeddedFile.js
var require_PDFEmbeddedFile = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFEmbeddedFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var core_1 = require_core();
    var PDFEmbeddedFile = (
      /** @class */
      function() {
        function PDFEmbeddedFile2(ref, doc, embedder) {
          this.alreadyEmbedded = false;
          this.ref = ref;
          this.doc = doc;
          this.embedder = embedder;
        }
        PDFEmbeddedFile2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var ref, Names, EmbeddedFiles, EFNames, AF;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.alreadyEmbedded)
                    return [3, 2];
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  ref = _a.sent();
                  if (!this.doc.catalog.has(core_1.PDFName.of("Names"))) {
                    this.doc.catalog.set(core_1.PDFName.of("Names"), this.doc.context.obj({}));
                  }
                  Names = this.doc.catalog.lookup(core_1.PDFName.of("Names"), core_1.PDFDict);
                  if (!Names.has(core_1.PDFName.of("EmbeddedFiles"))) {
                    Names.set(core_1.PDFName.of("EmbeddedFiles"), this.doc.context.obj({}));
                  }
                  EmbeddedFiles = Names.lookup(core_1.PDFName.of("EmbeddedFiles"), core_1.PDFDict);
                  if (!EmbeddedFiles.has(core_1.PDFName.of("Names"))) {
                    EmbeddedFiles.set(core_1.PDFName.of("Names"), this.doc.context.obj([]));
                  }
                  EFNames = EmbeddedFiles.lookup(core_1.PDFName.of("Names"), core_1.PDFArray);
                  EFNames.push(core_1.PDFHexString.fromText(this.embedder.fileName));
                  EFNames.push(ref);
                  if (!this.doc.catalog.has(core_1.PDFName.of("AF"))) {
                    this.doc.catalog.set(core_1.PDFName.of("AF"), this.doc.context.obj([]));
                  }
                  AF = this.doc.catalog.lookup(core_1.PDFName.of("AF"), core_1.PDFArray);
                  AF.push(ref);
                  this.alreadyEmbedded = true;
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFEmbeddedFile2.of = function(ref, doc, embedder) {
          return new PDFEmbeddedFile2(ref, doc, embedder);
        };
        return PDFEmbeddedFile2;
      }()
    );
    exports.default = PDFEmbeddedFile;
  }
});

// node_modules/pdf-lib/cjs/api/PDFJavaScript.js
var require_PDFJavaScript = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFJavaScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var core_1 = require_core();
    var PDFJavaScript = (
      /** @class */
      function() {
        function PDFJavaScript2(ref, doc, embedder) {
          this.alreadyEmbedded = false;
          this.ref = ref;
          this.doc = doc;
          this.embedder = embedder;
        }
        PDFJavaScript2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, catalog, context, ref, Names, Javascript, JSNames;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!!this.alreadyEmbedded)
                    return [3, 2];
                  _a = this.doc, catalog = _a.catalog, context = _a.context;
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  ref = _b.sent();
                  if (!catalog.has(core_1.PDFName.of("Names"))) {
                    catalog.set(core_1.PDFName.of("Names"), context.obj({}));
                  }
                  Names = catalog.lookup(core_1.PDFName.of("Names"), core_1.PDFDict);
                  if (!Names.has(core_1.PDFName.of("JavaScript"))) {
                    Names.set(core_1.PDFName.of("JavaScript"), context.obj({}));
                  }
                  Javascript = Names.lookup(core_1.PDFName.of("JavaScript"), core_1.PDFDict);
                  if (!Javascript.has(core_1.PDFName.of("Names"))) {
                    Javascript.set(core_1.PDFName.of("Names"), context.obj([]));
                  }
                  JSNames = Javascript.lookup(core_1.PDFName.of("Names"), core_1.PDFArray);
                  JSNames.push(core_1.PDFHexString.fromText(this.embedder.scriptName));
                  JSNames.push(ref);
                  this.alreadyEmbedded = true;
                  _b.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFJavaScript2.of = function(ref, doc, embedder) {
          return new PDFJavaScript2(ref, doc, embedder);
        };
        return PDFJavaScript2;
      }()
    );
    exports.default = PDFJavaScript;
  }
});

// node_modules/pdf-lib/cjs/core/embedders/JavaScriptEmbedder.js
var require_JavaScriptEmbedder = __commonJS({
  "node_modules/pdf-lib/cjs/core/embedders/JavaScriptEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var JavaScriptEmbedder = (
      /** @class */
      function() {
        function JavaScriptEmbedder2(script, scriptName) {
          this.script = script;
          this.scriptName = scriptName;
        }
        JavaScriptEmbedder2.for = function(script, scriptName) {
          return new JavaScriptEmbedder2(script, scriptName);
        };
        JavaScriptEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var jsActionDict;
            return tslib_1.__generator(this, function(_a) {
              jsActionDict = context.obj({
                Type: "Action",
                S: "JavaScript",
                JS: PDFHexString_1.default.fromText(this.script)
              });
              if (ref) {
                context.assign(ref, jsActionDict);
                return [2, ref];
              } else {
                return [2, context.register(jsActionDict)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        return JavaScriptEmbedder2;
      }()
    );
    exports.default = JavaScriptEmbedder;
  }
});

// node_modules/pdf-lib/cjs/api/PDFDocument.js
var require_PDFDocument = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors3();
    var PDFEmbeddedPage_1 = tslib_1.__importDefault(require_PDFEmbeddedPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFImage_1 = tslib_1.__importDefault(require_PDFImage());
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFForm_1 = tslib_1.__importDefault(require_PDFForm());
    var sizes_1 = require_sizes();
    var core_1 = require_core();
    var PDFDocumentOptions_1 = require_PDFDocumentOptions();
    var utils_1 = require_utils2();
    var FileEmbedder_1 = tslib_1.__importStar(require_FileEmbedder());
    var PDFEmbeddedFile_1 = tslib_1.__importDefault(require_PDFEmbeddedFile());
    var PDFJavaScript_1 = tslib_1.__importDefault(require_PDFJavaScript());
    var JavaScriptEmbedder_1 = tslib_1.__importDefault(require_JavaScriptEmbedder());
    var PDFDocument2 = (
      /** @class */
      function() {
        function PDFDocument3(context, ignoreEncryption, updateMetadata) {
          var _this = this;
          this.defaultWordBreaks = [" "];
          this.computePages = function() {
            var pages = [];
            _this.catalog.Pages().traverse(function(node, ref) {
              if (node instanceof core_1.PDFPageLeaf) {
                var page = _this.pageMap.get(node);
                if (!page) {
                  page = PDFPage_1.default.of(node, ref, _this);
                  _this.pageMap.set(node, page);
                }
                pages.push(page);
              }
            });
            return pages;
          };
          this.getOrCreateForm = function() {
            var acroForm = _this.catalog.getOrCreateAcroForm();
            return PDFForm_1.default.of(acroForm, _this);
          };
          utils_1.assertIs(context, "context", [[core_1.PDFContext, "PDFContext"]]);
          utils_1.assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
          this.context = context;
          this.catalog = context.lookup(context.trailerInfo.Root);
          this.isEncrypted = !!context.lookup(context.trailerInfo.Encrypt);
          this.pageCache = utils_1.Cache.populatedBy(this.computePages);
          this.pageMap = /* @__PURE__ */ new Map();
          this.formCache = utils_1.Cache.populatedBy(this.getOrCreateForm);
          this.fonts = [];
          this.images = [];
          this.embeddedPages = [];
          this.embeddedFiles = [];
          this.javaScripts = [];
          if (!ignoreEncryption && this.isEncrypted)
            throw new errors_1.EncryptedPDFError();
          if (updateMetadata)
            this.updateInfoDict();
        }
        PDFDocument3.load = function(pdf, options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, ignoreEncryption, _b, parseSpeed, _c, throwOnInvalidObject, _d, updateMetadata, _e, capNumbers, bytes, context;
            return tslib_1.__generator(this, function(_f) {
              switch (_f.label) {
                case 0:
                  _a = options.ignoreEncryption, ignoreEncryption = _a === void 0 ? false : _a, _b = options.parseSpeed, parseSpeed = _b === void 0 ? PDFDocumentOptions_1.ParseSpeeds.Slow : _b, _c = options.throwOnInvalidObject, throwOnInvalidObject = _c === void 0 ? false : _c, _d = options.updateMetadata, updateMetadata = _d === void 0 ? true : _d, _e = options.capNumbers, capNumbers = _e === void 0 ? false : _e;
                  utils_1.assertIs(pdf, "pdf", ["string", Uint8Array, ArrayBuffer]);
                  utils_1.assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
                  utils_1.assertIs(parseSpeed, "parseSpeed", ["number"]);
                  utils_1.assertIs(throwOnInvalidObject, "throwOnInvalidObject", ["boolean"]);
                  bytes = utils_1.toUint8Array(pdf);
                  return [4, core_1.PDFParser.forBytesWithOptions(bytes, parseSpeed, throwOnInvalidObject, capNumbers).parseDocument()];
                case 1:
                  context = _f.sent();
                  return [2, new PDFDocument3(context, ignoreEncryption, updateMetadata)];
              }
            });
          });
        };
        PDFDocument3.create = function(options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, updateMetadata, context, pageTree, pageTreeRef, catalog;
            return tslib_1.__generator(this, function(_b) {
              _a = options.updateMetadata, updateMetadata = _a === void 0 ? true : _a;
              context = core_1.PDFContext.create();
              pageTree = core_1.PDFPageTree.withContext(context);
              pageTreeRef = context.register(pageTree);
              catalog = core_1.PDFCatalog.withContextAndPages(context, pageTreeRef);
              context.trailerInfo.Root = context.register(catalog);
              return [2, new PDFDocument3(context, false, updateMetadata)];
            });
          });
        };
        PDFDocument3.prototype.registerFontkit = function(fontkit) {
          this.fontkit = fontkit;
        };
        PDFDocument3.prototype.getForm = function() {
          var form = this.formCache.access();
          if (form.hasXFA()) {
            console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA");
            form.deleteXFA();
          }
          return form;
        };
        PDFDocument3.prototype.getTitle = function() {
          var title = this.getInfoDict().lookup(core_1.PDFName.Title);
          if (!title)
            return void 0;
          assertIsLiteralOrHexString(title);
          return title.decodeText();
        };
        PDFDocument3.prototype.getAuthor = function() {
          var author = this.getInfoDict().lookup(core_1.PDFName.Author);
          if (!author)
            return void 0;
          assertIsLiteralOrHexString(author);
          return author.decodeText();
        };
        PDFDocument3.prototype.getSubject = function() {
          var subject = this.getInfoDict().lookup(core_1.PDFName.Subject);
          if (!subject)
            return void 0;
          assertIsLiteralOrHexString(subject);
          return subject.decodeText();
        };
        PDFDocument3.prototype.getKeywords = function() {
          var keywords = this.getInfoDict().lookup(core_1.PDFName.Keywords);
          if (!keywords)
            return void 0;
          assertIsLiteralOrHexString(keywords);
          return keywords.decodeText();
        };
        PDFDocument3.prototype.getCreator = function() {
          var creator = this.getInfoDict().lookup(core_1.PDFName.Creator);
          if (!creator)
            return void 0;
          assertIsLiteralOrHexString(creator);
          return creator.decodeText();
        };
        PDFDocument3.prototype.getProducer = function() {
          var producer = this.getInfoDict().lookup(core_1.PDFName.Producer);
          if (!producer)
            return void 0;
          assertIsLiteralOrHexString(producer);
          return producer.decodeText();
        };
        PDFDocument3.prototype.getCreationDate = function() {
          var creationDate = this.getInfoDict().lookup(core_1.PDFName.CreationDate);
          if (!creationDate)
            return void 0;
          assertIsLiteralOrHexString(creationDate);
          return creationDate.decodeDate();
        };
        PDFDocument3.prototype.getModificationDate = function() {
          var modificationDate = this.getInfoDict().lookup(core_1.PDFName.ModDate);
          if (!modificationDate)
            return void 0;
          assertIsLiteralOrHexString(modificationDate);
          return modificationDate.decodeDate();
        };
        PDFDocument3.prototype.setTitle = function(title, options) {
          utils_1.assertIs(title, "title", ["string"]);
          var key = core_1.PDFName.of("Title");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(title));
          if (options === null || options === void 0 ? void 0 : options.showInWindowTitleBar) {
            var prefs = this.catalog.getOrCreateViewerPreferences();
            prefs.setDisplayDocTitle(true);
          }
        };
        PDFDocument3.prototype.setAuthor = function(author) {
          utils_1.assertIs(author, "author", ["string"]);
          var key = core_1.PDFName.of("Author");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(author));
        };
        PDFDocument3.prototype.setSubject = function(subject) {
          utils_1.assertIs(subject, "author", ["string"]);
          var key = core_1.PDFName.of("Subject");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(subject));
        };
        PDFDocument3.prototype.setKeywords = function(keywords) {
          utils_1.assertIs(keywords, "keywords", [Array]);
          var key = core_1.PDFName.of("Keywords");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(keywords.join(" ")));
        };
        PDFDocument3.prototype.setCreator = function(creator) {
          utils_1.assertIs(creator, "creator", ["string"]);
          var key = core_1.PDFName.of("Creator");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(creator));
        };
        PDFDocument3.prototype.setProducer = function(producer) {
          utils_1.assertIs(producer, "creator", ["string"]);
          var key = core_1.PDFName.of("Producer");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(producer));
        };
        PDFDocument3.prototype.setLanguage = function(language) {
          utils_1.assertIs(language, "language", ["string"]);
          var key = core_1.PDFName.of("Lang");
          this.catalog.set(key, core_1.PDFString.of(language));
        };
        PDFDocument3.prototype.setCreationDate = function(creationDate) {
          utils_1.assertIs(creationDate, "creationDate", [[Date, "Date"]]);
          var key = core_1.PDFName.of("CreationDate");
          this.getInfoDict().set(key, core_1.PDFString.fromDate(creationDate));
        };
        PDFDocument3.prototype.setModificationDate = function(modificationDate) {
          utils_1.assertIs(modificationDate, "modificationDate", [[Date, "Date"]]);
          var key = core_1.PDFName.of("ModDate");
          this.getInfoDict().set(key, core_1.PDFString.fromDate(modificationDate));
        };
        PDFDocument3.prototype.getPageCount = function() {
          if (this.pageCount === void 0)
            this.pageCount = this.getPages().length;
          return this.pageCount;
        };
        PDFDocument3.prototype.getPages = function() {
          return this.pageCache.access();
        };
        PDFDocument3.prototype.getPage = function(index) {
          var pages = this.getPages();
          utils_1.assertRange(index, "index", 0, pages.length - 1);
          return pages[index];
        };
        PDFDocument3.prototype.getPageIndices = function() {
          return utils_1.range(0, this.getPageCount());
        };
        PDFDocument3.prototype.removePage = function(index) {
          var pageCount = this.getPageCount();
          if (this.pageCount === 0)
            throw new errors_1.RemovePageFromEmptyDocumentError();
          utils_1.assertRange(index, "index", 0, pageCount - 1);
          this.catalog.removeLeafNode(index);
          this.pageCount = pageCount - 1;
        };
        PDFDocument3.prototype.addPage = function(page) {
          utils_1.assertIs(page, "page", ["undefined", [PDFPage_1.default, "PDFPage"], Array]);
          return this.insertPage(this.getPageCount(), page);
        };
        PDFDocument3.prototype.insertPage = function(index, page) {
          var pageCount = this.getPageCount();
          utils_1.assertRange(index, "index", 0, pageCount);
          utils_1.assertIs(page, "page", ["undefined", [PDFPage_1.default, "PDFPage"], Array]);
          if (!page || Array.isArray(page)) {
            var dims = Array.isArray(page) ? page : sizes_1.PageSizes.A4;
            page = PDFPage_1.default.create(this);
            page.setSize.apply(page, dims);
          } else if (page.doc !== this) {
            throw new errors_1.ForeignPageError();
          }
          var parentRef = this.catalog.insertLeafNode(page.ref, index);
          page.node.setParent(parentRef);
          this.pageMap.set(page.node, page);
          this.pageCache.invalidate();
          this.pageCount = pageCount + 1;
          return page;
        };
        PDFDocument3.prototype.copyPages = function(srcDoc, indices) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var copier, srcPages, copiedPages, idx, len, srcPage, copiedPage, ref;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(srcDoc, "srcDoc", [[PDFDocument3, "PDFDocument"]]);
                  utils_1.assertIs(indices, "indices", [Array]);
                  return [4, srcDoc.flush()];
                case 1:
                  _a.sent();
                  copier = core_1.PDFObjectCopier.for(srcDoc.context, this.context);
                  srcPages = srcDoc.getPages();
                  copiedPages = new Array(indices.length);
                  for (idx = 0, len = indices.length; idx < len; idx++) {
                    srcPage = srcPages[indices[idx]];
                    copiedPage = copier.copy(srcPage.node);
                    ref = this.context.register(copiedPage);
                    copiedPages[idx] = PDFPage_1.default.of(copiedPage, ref, this);
                  }
                  return [2, copiedPages];
              }
            });
          });
        };
        PDFDocument3.prototype.copy = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var pdfCopy, contentPages, idx, len;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, PDFDocument3.create()];
                case 1:
                  pdfCopy = _a.sent();
                  return [4, pdfCopy.copyPages(this, this.getPageIndices())];
                case 2:
                  contentPages = _a.sent();
                  for (idx = 0, len = contentPages.length; idx < len; idx++) {
                    pdfCopy.addPage(contentPages[idx]);
                  }
                  if (this.getAuthor() !== void 0) {
                    pdfCopy.setAuthor(this.getAuthor());
                  }
                  if (this.getCreationDate() !== void 0) {
                    pdfCopy.setCreationDate(this.getCreationDate());
                  }
                  if (this.getCreator() !== void 0) {
                    pdfCopy.setCreator(this.getCreator());
                  }
                  if (this.getModificationDate() !== void 0) {
                    pdfCopy.setModificationDate(this.getModificationDate());
                  }
                  if (this.getProducer() !== void 0) {
                    pdfCopy.setProducer(this.getProducer());
                  }
                  if (this.getSubject() !== void 0) {
                    pdfCopy.setSubject(this.getSubject());
                  }
                  if (this.getTitle() !== void 0) {
                    pdfCopy.setTitle(this.getTitle());
                  }
                  pdfCopy.defaultWordBreaks = this.defaultWordBreaks;
                  return [2, pdfCopy];
              }
            });
          });
        };
        PDFDocument3.prototype.addJavaScript = function(name, script) {
          utils_1.assertIs(name, "name", ["string"]);
          utils_1.assertIs(script, "script", ["string"]);
          var embedder = JavaScriptEmbedder_1.default.for(script, name);
          var ref = this.context.nextRef();
          var javaScript = PDFJavaScript_1.default.of(ref, this, embedder);
          this.javaScripts.push(javaScript);
        };
        PDFDocument3.prototype.attach = function(attachment, name, options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var bytes, embedder, ref, embeddedFile;
            return tslib_1.__generator(this, function(_a) {
              utils_1.assertIs(attachment, "attachment", ["string", Uint8Array, ArrayBuffer]);
              utils_1.assertIs(name, "name", ["string"]);
              utils_1.assertOrUndefined(options.mimeType, "mimeType", ["string"]);
              utils_1.assertOrUndefined(options.description, "description", ["string"]);
              utils_1.assertOrUndefined(options.creationDate, "options.creationDate", [Date]);
              utils_1.assertOrUndefined(options.modificationDate, "options.modificationDate", [
                Date
              ]);
              utils_1.assertIsOneOfOrUndefined(options.afRelationship, "options.afRelationship", FileEmbedder_1.AFRelationship);
              bytes = utils_1.toUint8Array(attachment);
              embedder = FileEmbedder_1.default.for(bytes, name, options);
              ref = this.context.nextRef();
              embeddedFile = PDFEmbeddedFile_1.default.of(ref, this, embedder);
              this.embeddedFiles.push(embeddedFile);
              return [
                2
                /*return*/
              ];
            });
          });
        };
        PDFDocument3.prototype.embedFont = function(font, options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, subset, customName, features, embedder, bytes, fontkit, _b, ref, pdfFont;
            return tslib_1.__generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _a = options.subset, subset = _a === void 0 ? false : _a, customName = options.customName, features = options.features;
                  utils_1.assertIs(font, "font", ["string", Uint8Array, ArrayBuffer]);
                  utils_1.assertIs(subset, "subset", ["boolean"]);
                  if (!utils_1.isStandardFont(font))
                    return [3, 1];
                  embedder = core_1.StandardFontEmbedder.for(font, customName);
                  return [3, 7];
                case 1:
                  if (!utils_1.canBeConvertedToUint8Array(font))
                    return [3, 6];
                  bytes = utils_1.toUint8Array(font);
                  fontkit = this.assertFontkit();
                  if (!subset)
                    return [3, 3];
                  return [4, core_1.CustomFontSubsetEmbedder.for(fontkit, bytes, customName, features)];
                case 2:
                  _b = _c.sent();
                  return [3, 5];
                case 3:
                  return [4, core_1.CustomFontEmbedder.for(fontkit, bytes, customName, features)];
                case 4:
                  _b = _c.sent();
                  _c.label = 5;
                case 5:
                  embedder = _b;
                  return [3, 7];
                case 6:
                  throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`");
                case 7:
                  ref = this.context.nextRef();
                  pdfFont = PDFFont_1.default.of(ref, this, embedder);
                  this.fonts.push(pdfFont);
                  return [2, pdfFont];
              }
            });
          });
        };
        PDFDocument3.prototype.embedStandardFont = function(font, customName) {
          utils_1.assertIs(font, "font", ["string"]);
          if (!utils_1.isStandardFont(font)) {
            throw new TypeError("`font` must be one of type `StandardFonts`");
          }
          var embedder = core_1.StandardFontEmbedder.for(font, customName);
          var ref = this.context.nextRef();
          var pdfFont = PDFFont_1.default.of(ref, this, embedder);
          this.fonts.push(pdfFont);
          return pdfFont;
        };
        PDFDocument3.prototype.embedJpg = function(jpg) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var bytes, embedder, ref, pdfImage;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(jpg, "jpg", ["string", Uint8Array, ArrayBuffer]);
                  bytes = utils_1.toUint8Array(jpg);
                  return [4, core_1.JpegEmbedder.for(bytes)];
                case 1:
                  embedder = _a.sent();
                  ref = this.context.nextRef();
                  pdfImage = PDFImage_1.default.of(ref, this, embedder);
                  this.images.push(pdfImage);
                  return [2, pdfImage];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPng = function(png) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var bytes, embedder, ref, pdfImage;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(png, "png", ["string", Uint8Array, ArrayBuffer]);
                  bytes = utils_1.toUint8Array(png);
                  return [4, core_1.PngEmbedder.for(bytes)];
                case 1:
                  embedder = _a.sent();
                  ref = this.context.nextRef();
                  pdfImage = PDFImage_1.default.of(ref, this, embedder);
                  this.images.push(pdfImage);
                  return [2, pdfImage];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPdf = function(pdf, indices) {
          if (indices === void 0) {
            indices = [0];
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var srcDoc, _a, srcPages;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  utils_1.assertIs(pdf, "pdf", [
                    "string",
                    Uint8Array,
                    ArrayBuffer,
                    [PDFDocument3, "PDFDocument"]
                  ]);
                  utils_1.assertIs(indices, "indices", [Array]);
                  if (!(pdf instanceof PDFDocument3))
                    return [3, 1];
                  _a = pdf;
                  return [3, 3];
                case 1:
                  return [4, PDFDocument3.load(pdf)];
                case 2:
                  _a = _b.sent();
                  _b.label = 3;
                case 3:
                  srcDoc = _a;
                  srcPages = utils_1.pluckIndices(srcDoc.getPages(), indices);
                  return [2, this.embedPages(srcPages)];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPage = function(page, boundingBox, transformationMatrix) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var embeddedPage;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
                  return [4, this.embedPages([page], [boundingBox], [transformationMatrix])];
                case 1:
                  embeddedPage = _a.sent()[0];
                  return [2, embeddedPage];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPages = function(pages, boundingBoxes, transformationMatrices) {
          if (boundingBoxes === void 0) {
            boundingBoxes = [];
          }
          if (transformationMatrices === void 0) {
            transformationMatrices = [];
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var idx, len, currPage, nextPage, context, maybeCopyPage, embeddedPages, idx, len, page, box, matrix, embedder, ref;
            var _a;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (pages.length === 0)
                    return [2, []];
                  for (idx = 0, len = pages.length - 1; idx < len; idx++) {
                    currPage = pages[idx];
                    nextPage = pages[idx + 1];
                    if (currPage.node.context !== nextPage.node.context) {
                      throw new core_1.PageEmbeddingMismatchedContextError();
                    }
                  }
                  context = pages[0].node.context;
                  maybeCopyPage = context === this.context ? function(p) {
                    return p;
                  } : core_1.PDFObjectCopier.for(context, this.context).copy;
                  embeddedPages = new Array(pages.length);
                  idx = 0, len = pages.length;
                  _b.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  page = maybeCopyPage(pages[idx].node);
                  box = boundingBoxes[idx];
                  matrix = transformationMatrices[idx];
                  return [4, core_1.PDFPageEmbedder.for(page, box, matrix)];
                case 2:
                  embedder = _b.sent();
                  ref = this.context.nextRef();
                  embeddedPages[idx] = PDFEmbeddedPage_1.default.of(ref, this, embedder);
                  _b.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  (_a = this.embeddedPages).push.apply(_a, embeddedPages);
                  return [2, embeddedPages];
              }
            });
          });
        };
        PDFDocument3.prototype.flush = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.embedAll(this.fonts)];
                case 1:
                  _a.sent();
                  return [4, this.embedAll(this.images)];
                case 2:
                  _a.sent();
                  return [4, this.embedAll(this.embeddedPages)];
                case 3:
                  _a.sent();
                  return [4, this.embedAll(this.embeddedFiles)];
                case 4:
                  _a.sent();
                  return [4, this.embedAll(this.javaScripts)];
                case 5:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFDocument3.prototype.save = function(options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, useObjectStreams, _b, addDefaultPage, _c, objectsPerTick, _d, updateFieldAppearances, form, Writer;
            return tslib_1.__generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  _a = options.useObjectStreams, useObjectStreams = _a === void 0 ? true : _a, _b = options.addDefaultPage, addDefaultPage = _b === void 0 ? true : _b, _c = options.objectsPerTick, objectsPerTick = _c === void 0 ? 50 : _c, _d = options.updateFieldAppearances, updateFieldAppearances = _d === void 0 ? true : _d;
                  utils_1.assertIs(useObjectStreams, "useObjectStreams", ["boolean"]);
                  utils_1.assertIs(addDefaultPage, "addDefaultPage", ["boolean"]);
                  utils_1.assertIs(objectsPerTick, "objectsPerTick", ["number"]);
                  utils_1.assertIs(updateFieldAppearances, "updateFieldAppearances", ["boolean"]);
                  if (addDefaultPage && this.getPageCount() === 0)
                    this.addPage();
                  if (updateFieldAppearances) {
                    form = this.formCache.getValue();
                    if (form)
                      form.updateFieldAppearances();
                  }
                  return [4, this.flush()];
                case 1:
                  _e.sent();
                  Writer = useObjectStreams ? core_1.PDFStreamWriter : core_1.PDFWriter;
                  return [2, Writer.forContext(this.context, objectsPerTick).serializeToBuffer()];
              }
            });
          });
        };
        PDFDocument3.prototype.saveAsBase64 = function(options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, dataUri, otherOptions, bytes, base64;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = options.dataUri, dataUri = _a === void 0 ? false : _a, otherOptions = tslib_1.__rest(options, ["dataUri"]);
                  utils_1.assertIs(dataUri, "dataUri", ["boolean"]);
                  return [4, this.save(otherOptions)];
                case 1:
                  bytes = _b.sent();
                  base64 = utils_1.encodeToBase64(bytes);
                  return [2, dataUri ? "data:application/pdf;base64," + base64 : base64];
              }
            });
          });
        };
        PDFDocument3.prototype.findPageForAnnotationRef = function(ref) {
          var pages = this.getPages();
          for (var idx = 0, len = pages.length; idx < len; idx++) {
            var page = pages[idx];
            var annotations = page.node.Annots();
            if ((annotations === null || annotations === void 0 ? void 0 : annotations.indexOf(ref)) !== void 0) {
              return page;
            }
          }
          return void 0;
        };
        PDFDocument3.prototype.embedAll = function(embeddables) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var idx, len;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  idx = 0, len = embeddables.length;
                  _a.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  return [4, embeddables[idx].embed()];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFDocument3.prototype.updateInfoDict = function() {
          var pdfLib = "pdf-lib (https://github.com/Hopding/pdf-lib)";
          var now = new Date();
          var info = this.getInfoDict();
          this.setProducer(pdfLib);
          this.setModificationDate(now);
          if (!info.get(core_1.PDFName.of("Creator")))
            this.setCreator(pdfLib);
          if (!info.get(core_1.PDFName.of("CreationDate")))
            this.setCreationDate(now);
        };
        PDFDocument3.prototype.getInfoDict = function() {
          var existingInfo = this.context.lookup(this.context.trailerInfo.Info);
          if (existingInfo instanceof core_1.PDFDict)
            return existingInfo;
          var newInfo = this.context.obj({});
          this.context.trailerInfo.Info = this.context.register(newInfo);
          return newInfo;
        };
        PDFDocument3.prototype.assertFontkit = function() {
          if (!this.fontkit)
            throw new errors_1.FontkitNotRegisteredError();
          return this.fontkit;
        };
        return PDFDocument3;
      }()
    );
    exports.default = PDFDocument2;
    function assertIsLiteralOrHexString(pdfObject) {
      if (!(pdfObject instanceof core_1.PDFHexString) && !(pdfObject instanceof core_1.PDFString)) {
        throw new core_1.UnexpectedObjectTypeError([core_1.PDFHexString, core_1.PDFString], pdfObject);
      }
    }
  }
});

// node_modules/pdf-lib/cjs/api/PDFPageOptions.js
var require_PDFPageOptions = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFPageOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlendMode = void 0;
    var BlendMode;
    (function(BlendMode2) {
      BlendMode2["Normal"] = "Normal";
      BlendMode2["Multiply"] = "Multiply";
      BlendMode2["Screen"] = "Screen";
      BlendMode2["Overlay"] = "Overlay";
      BlendMode2["Darken"] = "Darken";
      BlendMode2["Lighten"] = "Lighten";
      BlendMode2["ColorDodge"] = "ColorDodge";
      BlendMode2["ColorBurn"] = "ColorBurn";
      BlendMode2["HardLight"] = "HardLight";
      BlendMode2["SoftLight"] = "SoftLight";
      BlendMode2["Difference"] = "Difference";
      BlendMode2["Exclusion"] = "Exclusion";
    })(BlendMode = exports.BlendMode || (exports.BlendMode = {}));
  }
});

// node_modules/pdf-lib/cjs/api/PDFPage.js
var require_PDFPage = __commonJS({
  "node_modules/pdf-lib/cjs/api/PDFPage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var colors_1 = require_colors();
    var operations_1 = require_operations();
    var operators_1 = require_operators();
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var PDFEmbeddedPage_1 = tslib_1.__importDefault(require_PDFEmbeddedPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFImage_1 = tslib_1.__importDefault(require_PDFImage());
    var PDFPageOptions_1 = require_PDFPageOptions();
    var rotations_1 = require_rotations();
    var StandardFonts_1 = require_StandardFonts();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFPage = (
      /** @class */
      function() {
        function PDFPage2(leafNode, ref, doc) {
          this.fontSize = 24;
          this.fontColor = colors_1.rgb(0, 0, 0);
          this.lineHeight = 24;
          this.x = 0;
          this.y = 0;
          utils_1.assertIs(leafNode, "leafNode", [[core_1.PDFPageLeaf, "PDFPageLeaf"]]);
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          this.node = leafNode;
          this.ref = ref;
          this.doc = doc;
        }
        PDFPage2.prototype.setRotation = function(angle) {
          var degreesAngle = rotations_1.toDegrees(angle);
          utils_1.assertMultiple(degreesAngle, "degreesAngle", 90);
          this.node.set(core_1.PDFName.of("Rotate"), this.doc.context.obj(degreesAngle));
        };
        PDFPage2.prototype.getRotation = function() {
          var Rotate = this.node.Rotate();
          return rotations_1.degrees(Rotate ? Rotate.asNumber() : 0);
        };
        PDFPage2.prototype.setSize = function(width, height) {
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var mediaBox = this.getMediaBox();
          this.setMediaBox(mediaBox.x, mediaBox.y, width, height);
          var cropBox = this.getCropBox();
          var bleedBox = this.getBleedBox();
          var trimBox = this.getTrimBox();
          var artBox = this.getArtBox();
          var hasCropBox = this.node.CropBox();
          var hasBleedBox = this.node.BleedBox();
          var hasTrimBox = this.node.TrimBox();
          var hasArtBox = this.node.ArtBox();
          if (hasCropBox && utils_1.rectanglesAreEqual(cropBox, mediaBox)) {
            this.setCropBox(mediaBox.x, mediaBox.y, width, height);
          }
          if (hasBleedBox && utils_1.rectanglesAreEqual(bleedBox, mediaBox)) {
            this.setBleedBox(mediaBox.x, mediaBox.y, width, height);
          }
          if (hasTrimBox && utils_1.rectanglesAreEqual(trimBox, mediaBox)) {
            this.setTrimBox(mediaBox.x, mediaBox.y, width, height);
          }
          if (hasArtBox && utils_1.rectanglesAreEqual(artBox, mediaBox)) {
            this.setArtBox(mediaBox.x, mediaBox.y, width, height);
          }
        };
        PDFPage2.prototype.setWidth = function(width) {
          utils_1.assertIs(width, "width", ["number"]);
          this.setSize(width, this.getSize().height);
        };
        PDFPage2.prototype.setHeight = function(height) {
          utils_1.assertIs(height, "height", ["number"]);
          this.setSize(this.getSize().width, height);
        };
        PDFPage2.prototype.setMediaBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var mediaBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.MediaBox, mediaBox);
        };
        PDFPage2.prototype.setCropBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var cropBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.CropBox, cropBox);
        };
        PDFPage2.prototype.setBleedBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var bleedBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.BleedBox, bleedBox);
        };
        PDFPage2.prototype.setTrimBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var trimBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.TrimBox, trimBox);
        };
        PDFPage2.prototype.setArtBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var artBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.ArtBox, artBox);
        };
        PDFPage2.prototype.getSize = function() {
          var _a = this.getMediaBox(), width = _a.width, height = _a.height;
          return { width, height };
        };
        PDFPage2.prototype.getWidth = function() {
          return this.getSize().width;
        };
        PDFPage2.prototype.getHeight = function() {
          return this.getSize().height;
        };
        PDFPage2.prototype.getMediaBox = function() {
          var mediaBox = this.node.MediaBox();
          return mediaBox.asRectangle();
        };
        PDFPage2.prototype.getCropBox = function() {
          var _a;
          var cropBox = this.node.CropBox();
          return (_a = cropBox === null || cropBox === void 0 ? void 0 : cropBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getMediaBox();
        };
        PDFPage2.prototype.getBleedBox = function() {
          var _a;
          var bleedBox = this.node.BleedBox();
          return (_a = bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
        };
        PDFPage2.prototype.getTrimBox = function() {
          var _a;
          var trimBox = this.node.TrimBox();
          return (_a = trimBox === null || trimBox === void 0 ? void 0 : trimBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
        };
        PDFPage2.prototype.getArtBox = function() {
          var _a;
          var artBox = this.node.ArtBox();
          return (_a = artBox === null || artBox === void 0 ? void 0 : artBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
        };
        PDFPage2.prototype.translateContent = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.node.normalize();
          this.getContentStream();
          var start2 = this.createContentStream(operators_1.pushGraphicsState(), operators_1.translate(x, y));
          var startRef = this.doc.context.register(start2);
          var end2 = this.createContentStream(operators_1.popGraphicsState());
          var endRef = this.doc.context.register(end2);
          this.node.wrapContentStreams(startRef, endRef);
        };
        PDFPage2.prototype.scale = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.setSize(this.getWidth() * x, this.getHeight() * y);
          this.scaleContent(x, y);
          this.scaleAnnotations(x, y);
        };
        PDFPage2.prototype.scaleContent = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.node.normalize();
          this.getContentStream();
          var start2 = this.createContentStream(operators_1.pushGraphicsState(), operators_1.scale(x, y));
          var startRef = this.doc.context.register(start2);
          var end2 = this.createContentStream(operators_1.popGraphicsState());
          var endRef = this.doc.context.register(end2);
          this.node.wrapContentStreams(startRef, endRef);
        };
        PDFPage2.prototype.scaleAnnotations = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          var annots = this.node.Annots();
          if (!annots)
            return;
          for (var idx = 0; idx < annots.size(); idx++) {
            var annot = annots.lookup(idx);
            if (annot instanceof core_1.PDFDict)
              this.scaleAnnot(annot, x, y);
          }
        };
        PDFPage2.prototype.resetPosition = function() {
          this.getContentStream(false);
          this.x = 0;
          this.y = 0;
        };
        PDFPage2.prototype.setFont = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.font = font;
          this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref);
        };
        PDFPage2.prototype.setFontSize = function(fontSize) {
          utils_1.assertIs(fontSize, "fontSize", ["number"]);
          this.fontSize = fontSize;
        };
        PDFPage2.prototype.setFontColor = function(fontColor) {
          utils_1.assertIs(fontColor, "fontColor", [[Object, "Color"]]);
          this.fontColor = fontColor;
        };
        PDFPage2.prototype.setLineHeight = function(lineHeight) {
          utils_1.assertIs(lineHeight, "lineHeight", ["number"]);
          this.lineHeight = lineHeight;
        };
        PDFPage2.prototype.getPosition = function() {
          return { x: this.x, y: this.y };
        };
        PDFPage2.prototype.getX = function() {
          return this.x;
        };
        PDFPage2.prototype.getY = function() {
          return this.y;
        };
        PDFPage2.prototype.moveTo = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.x = x;
          this.y = y;
        };
        PDFPage2.prototype.moveDown = function(yDecrease) {
          utils_1.assertIs(yDecrease, "yDecrease", ["number"]);
          this.y -= yDecrease;
        };
        PDFPage2.prototype.moveUp = function(yIncrease) {
          utils_1.assertIs(yIncrease, "yIncrease", ["number"]);
          this.y += yIncrease;
        };
        PDFPage2.prototype.moveLeft = function(xDecrease) {
          utils_1.assertIs(xDecrease, "xDecrease", ["number"]);
          this.x -= xDecrease;
        };
        PDFPage2.prototype.moveRight = function(xIncrease) {
          utils_1.assertIs(xIncrease, "xIncrease", ["number"]);
          this.x += xIncrease;
        };
        PDFPage2.prototype.pushOperators = function() {
          var operator = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operator[_i] = arguments[_i];
          }
          utils_1.assertEachIs(operator, "operator", [[core_1.PDFOperator, "PDFOperator"]]);
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operator);
        };
        PDFPage2.prototype.drawText = function(text, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(text, "text", ["string"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.font, "options.font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(options.size, "options.size", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.lineHeight, "options.lineHeight", ["number"]);
          utils_1.assertOrUndefined(options.maxWidth, "options.maxWidth", ["number"]);
          utils_1.assertOrUndefined(options.wordBreaks, "options.wordBreaks", [Array]);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var _h = this.setOrEmbedFont(options.font), oldFont = _h.oldFont, newFont = _h.newFont, newFontKey = _h.newFontKey;
          var fontSize = options.size || this.fontSize;
          var wordBreaks = options.wordBreaks || this.doc.defaultWordBreaks;
          var textWidth = function(t) {
            return newFont.widthOfTextAtSize(t, fontSize);
          };
          var lines = options.maxWidth === void 0 ? utils_1.lineSplit(utils_1.cleanText(text)) : utils_1.breakTextIntoLines(text, wordBreaks, options.maxWidth, textWidth);
          var encodedLines = new Array(lines.length);
          for (var idx = 0, len = lines.length; idx < len; idx++) {
            encodedLines[idx] = newFont.encodeText(lines[idx]);
          }
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            blendMode: options.blendMode
          });
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawLinesOfText(encodedLines, {
            color: (_a = options.color) !== null && _a !== void 0 ? _a : this.fontColor,
            font: newFontKey,
            size: fontSize,
            rotate: (_b = options.rotate) !== null && _b !== void 0 ? _b : rotations_1.degrees(0),
            xSkew: (_c = options.xSkew) !== null && _c !== void 0 ? _c : rotations_1.degrees(0),
            ySkew: (_d = options.ySkew) !== null && _d !== void 0 ? _d : rotations_1.degrees(0),
            x: (_e = options.x) !== null && _e !== void 0 ? _e : this.x,
            y: (_f = options.y) !== null && _f !== void 0 ? _f : this.y,
            lineHeight: (_g = options.lineHeight) !== null && _g !== void 0 ? _g : this.lineHeight,
            graphicsState: graphicsStateKey
          }));
          if (options.font) {
            if (oldFont)
              this.setFont(oldFont);
            else
              this.resetFont();
          }
        };
        PDFPage2.prototype.drawImage = function(image, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(image, "image", [[PDFImage_1.default, "PDFImage"]]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.width, "options.width", ["number"]);
          utils_1.assertOrUndefined(options.height, "options.height", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var xObjectKey = this.node.newXObject("Image", image.ref);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            blendMode: options.blendMode
          });
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawImage(xObjectKey, {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : image.size().width,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : image.size().height,
            rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : rotations_1.degrees(0),
            xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : rotations_1.degrees(0),
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawPage = function(embeddedPage, options) {
          var _a, _b, _c, _d, _e;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(embeddedPage, "embeddedPage", [
            [PDFEmbeddedPage_1.default, "PDFEmbeddedPage"]
          ]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.xScale, "options.xScale", ["number"]);
          utils_1.assertOrUndefined(options.yScale, "options.yScale", ["number"]);
          utils_1.assertOrUndefined(options.width, "options.width", ["number"]);
          utils_1.assertOrUndefined(options.height, "options.height", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var xObjectKey = this.node.newXObject("EmbeddedPdfPage", embeddedPage.ref);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            blendMode: options.blendMode
          });
          var xScale = options.width !== void 0 ? options.width / embeddedPage.width : options.xScale !== void 0 ? options.xScale : 1;
          var yScale = options.height !== void 0 ? options.height / embeddedPage.height : options.yScale !== void 0 ? options.yScale : 1;
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawPage(xObjectKey, {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            xScale,
            yScale,
            rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : rotations_1.degrees(0),
            xSkew: (_d = options.xSkew) !== null && _d !== void 0 ? _d : rotations_1.degrees(0),
            ySkew: (_e = options.ySkew) !== null && _e !== void 0 ? _e : rotations_1.degrees(0),
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawSvgPath = function(path, options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(path, "path", ["string"]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.scale, "options.scale", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.borderColor, "options.borderColor", [
            [Object, "Color"]
          ]);
          utils_1.assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
            Array
          ]);
          utils_1.assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
            "number"
          ]);
          utils_1.assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", operators_1.LineCapStyle);
          utils_1.assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            borderOpacity: options.borderOpacity,
            blendMode: options.blendMode
          });
          if (!("color" in options) && !("borderColor" in options)) {
            options.borderColor = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawSvgPath(path, {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            scale: options.scale,
            rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : rotations_1.degrees(0),
            color: (_d = options.color) !== null && _d !== void 0 ? _d : void 0,
            borderColor: (_e = options.borderColor) !== null && _e !== void 0 ? _e : void 0,
            borderWidth: (_f = options.borderWidth) !== null && _f !== void 0 ? _f : 0,
            borderDashArray: (_g = options.borderDashArray) !== null && _g !== void 0 ? _g : void 0,
            borderDashPhase: (_h = options.borderDashPhase) !== null && _h !== void 0 ? _h : void 0,
            borderLineCap: (_j = options.borderLineCap) !== null && _j !== void 0 ? _j : void 0,
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawLine = function(options) {
          var _a, _b, _c, _d, _e;
          utils_1.assertIs(options.start, "options.start", [
            [Object, "{ x: number, y: number }"]
          ]);
          utils_1.assertIs(options.end, "options.end", [
            [Object, "{ x: number, y: number }"]
          ]);
          utils_1.assertIs(options.start.x, "options.start.x", ["number"]);
          utils_1.assertIs(options.start.y, "options.start.y", ["number"]);
          utils_1.assertIs(options.end.x, "options.end.x", ["number"]);
          utils_1.assertIs(options.end.y, "options.end.y", ["number"]);
          utils_1.assertOrUndefined(options.thickness, "options.thickness", ["number"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertOrUndefined(options.dashArray, "options.dashArray", [Array]);
          utils_1.assertOrUndefined(options.dashPhase, "options.dashPhase", ["number"]);
          utils_1.assertIsOneOfOrUndefined(options.lineCap, "options.lineCap", operators_1.LineCapStyle);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            borderOpacity: options.opacity,
            blendMode: options.blendMode
          });
          if (!("color" in options)) {
            options.color = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawLine({
            start: options.start,
            end: options.end,
            thickness: (_a = options.thickness) !== null && _a !== void 0 ? _a : 1,
            color: (_b = options.color) !== null && _b !== void 0 ? _b : void 0,
            dashArray: (_c = options.dashArray) !== null && _c !== void 0 ? _c : void 0,
            dashPhase: (_d = options.dashPhase) !== null && _d !== void 0 ? _d : void 0,
            lineCap: (_e = options.lineCap) !== null && _e !== void 0 ? _e : void 0,
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawRectangle = function(options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.width, "options.width", ["number"]);
          utils_1.assertOrUndefined(options.height, "options.height", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.borderColor, "options.borderColor", [
            [Object, "Color"]
          ]);
          utils_1.assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
            Array
          ]);
          utils_1.assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
            "number"
          ]);
          utils_1.assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", operators_1.LineCapStyle);
          utils_1.assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            borderOpacity: options.borderOpacity,
            blendMode: options.blendMode
          });
          if (!("color" in options) && !("borderColor" in options)) {
            options.color = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawRectangle({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 150,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
            rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : rotations_1.degrees(0),
            xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : rotations_1.degrees(0),
            borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
            color: (_j = options.color) !== null && _j !== void 0 ? _j : void 0,
            borderColor: (_k = options.borderColor) !== null && _k !== void 0 ? _k : void 0,
            borderDashArray: (_l = options.borderDashArray) !== null && _l !== void 0 ? _l : void 0,
            borderDashPhase: (_m = options.borderDashPhase) !== null && _m !== void 0 ? _m : void 0,
            graphicsState: graphicsStateKey,
            borderLineCap: (_o = options.borderLineCap) !== null && _o !== void 0 ? _o : void 0
          }));
        };
        PDFPage2.prototype.drawSquare = function(options) {
          if (options === void 0) {
            options = {};
          }
          var size = options.size;
          utils_1.assertOrUndefined(size, "size", ["number"]);
          this.drawRectangle(tslib_1.__assign(tslib_1.__assign({}, options), { width: size, height: size }));
        };
        PDFPage2.prototype.drawEllipse = function(options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.xScale, "options.xScale", ["number"]);
          utils_1.assertOrUndefined(options.yScale, "options.yScale", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.borderColor, "options.borderColor", [
            [Object, "Color"]
          ]);
          utils_1.assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
          utils_1.assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
          utils_1.assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
            Array
          ]);
          utils_1.assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
            "number"
          ]);
          utils_1.assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", operators_1.LineCapStyle);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            borderOpacity: options.borderOpacity,
            blendMode: options.blendMode
          });
          if (!("color" in options) && !("borderColor" in options)) {
            options.color = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawEllipse({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            xScale: (_c = options.xScale) !== null && _c !== void 0 ? _c : 100,
            yScale: (_d = options.yScale) !== null && _d !== void 0 ? _d : 100,
            rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : void 0,
            color: (_f = options.color) !== null && _f !== void 0 ? _f : void 0,
            borderColor: (_g = options.borderColor) !== null && _g !== void 0 ? _g : void 0,
            borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
            borderDashArray: (_j = options.borderDashArray) !== null && _j !== void 0 ? _j : void 0,
            borderDashPhase: (_k = options.borderDashPhase) !== null && _k !== void 0 ? _k : void 0,
            borderLineCap: (_l = options.borderLineCap) !== null && _l !== void 0 ? _l : void 0,
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawCircle = function(options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.size, size = _a === void 0 ? 100 : _a;
          utils_1.assertOrUndefined(size, "size", ["number"]);
          this.drawEllipse(tslib_1.__assign(tslib_1.__assign({}, options), { xScale: size, yScale: size }));
        };
        PDFPage2.prototype.setOrEmbedFont = function(font) {
          var oldFont = this.font;
          var oldFontKey = this.fontKey;
          if (font)
            this.setFont(font);
          else
            this.getFont();
          var newFont = this.font;
          var newFontKey = this.fontKey;
          return { oldFont, oldFontKey, newFont, newFontKey };
        };
        PDFPage2.prototype.getFont = function() {
          if (!this.font || !this.fontKey) {
            var font = this.doc.embedStandardFont(StandardFonts_1.StandardFonts.Helvetica);
            this.setFont(font);
          }
          return [this.font, this.fontKey];
        };
        PDFPage2.prototype.resetFont = function() {
          this.font = void 0;
          this.fontKey = void 0;
        };
        PDFPage2.prototype.getContentStream = function(useExisting) {
          if (useExisting === void 0) {
            useExisting = true;
          }
          if (useExisting && this.contentStream)
            return this.contentStream;
          this.contentStream = this.createContentStream();
          this.contentStreamRef = this.doc.context.register(this.contentStream);
          this.node.addContentStream(this.contentStreamRef);
          return this.contentStream;
        };
        PDFPage2.prototype.createContentStream = function() {
          var operators = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
          }
          var dict = this.doc.context.obj({});
          var contentStream = core_1.PDFContentStream.of(dict, operators);
          return contentStream;
        };
        PDFPage2.prototype.maybeEmbedGraphicsState = function(options) {
          var opacity = options.opacity, borderOpacity = options.borderOpacity, blendMode = options.blendMode;
          if (opacity === void 0 && borderOpacity === void 0 && blendMode === void 0) {
            return void 0;
          }
          var graphicsState = this.doc.context.obj({
            Type: "ExtGState",
            ca: opacity,
            CA: borderOpacity,
            BM: blendMode
          });
          var key = this.node.newExtGState("GS", graphicsState);
          return key;
        };
        PDFPage2.prototype.scaleAnnot = function(annot, x, y) {
          var selectors = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"];
          for (var idx = 0, len = selectors.length; idx < len; idx++) {
            var list = annot.lookup(core_1.PDFName.of(selectors[idx]));
            if (list instanceof core_1.PDFArray)
              list.scalePDFNumbers(x, y);
          }
          var inkLists = annot.lookup(core_1.PDFName.of("InkList"));
          if (inkLists instanceof core_1.PDFArray) {
            for (var idx = 0, len = inkLists.size(); idx < len; idx++) {
              var arr = inkLists.lookup(idx);
              if (arr instanceof core_1.PDFArray)
                arr.scalePDFNumbers(x, y);
            }
          }
        };
        PDFPage2.of = function(leafNode, ref, doc) {
          return new PDFPage2(leafNode, ref, doc);
        };
        PDFPage2.create = function(doc) {
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          var dummyRef = core_1.PDFRef.of(-1);
          var pageLeaf = core_1.PDFPageLeaf.withContextAndParent(doc.context, dummyRef);
          var pageRef = doc.context.register(pageLeaf);
          return new PDFPage2(pageLeaf, pageRef, doc);
        };
        return PDFPage2;
      }()
    );
    exports.default = PDFPage;
  }
});

// node_modules/pdf-lib/cjs/api/form/PDFButton.js
var require_PDFButton = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/PDFButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var alignment_1 = require_alignment2();
    var appearances_1 = require_appearances();
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFButton2, _super);
        function PDFButton2(acroPushButton, ref, doc) {
          var _this = _super.call(this, acroPushButton, ref, doc) || this;
          utils_1.assertIs(acroPushButton, "acroButton", [
            [core_1.PDFAcroPushButton, "PDFAcroPushButton"]
          ]);
          _this.acroField = acroPushButton;
          return _this;
        }
        PDFButton2.prototype.setImage = function(image, alignment) {
          if (alignment === void 0) {
            alignment = alignment_1.ImageAlignment.Center;
          }
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var streamRef = this.createImageAppearanceStream(widget, image, alignment);
            this.updateWidgetAppearances(widget, { normal: streamRef });
          }
          this.markAsClean();
        };
        PDFButton2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFButton2.prototype.addToPage = function(text, page, options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
          utils_1.assertOrUndefined(text, "text", ["string"]);
          utils_1.assertOrUndefined(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          var widget = this.createWidget({
            x: ((_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0) - ((_b = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _b !== void 0 ? _b : 0) / 2,
            y: ((_c = options === null || options === void 0 ? void 0 : options.y) !== null && _c !== void 0 ? _c : 0) - ((_d = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _d !== void 0 ? _d : 0) / 2,
            width: (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : 100,
            height: (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : 50,
            textColor: (_g = options === null || options === void 0 ? void 0 : options.textColor) !== null && _g !== void 0 ? _g : colors_1.rgb(0, 0, 0),
            backgroundColor: (_h = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _h !== void 0 ? _h : colors_1.rgb(0.75, 0.75, 0.75),
            borderColor: options === null || options === void 0 ? void 0 : options.borderColor,
            borderWidth: (_j = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _j !== void 0 ? _j : 0,
            rotate: (_k = options === null || options === void 0 ? void 0 : options.rotate) !== null && _k !== void 0 ? _k : rotations_1.degrees(0),
            caption: text,
            hidden: options === null || options === void 0 ? void 0 : options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_l = options === null || options === void 0 ? void 0 : options.font) !== null && _l !== void 0 ? _l : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFButton2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFButton2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFButton2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
        };
        PDFButton2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultButtonAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFButton2.of = function(acroPushButton, ref, doc) {
          return new PDFButton2(acroPushButton, ref, doc);
        };
        return PDFButton2;
      }(PDFField_1.default)
    );
    exports.default = PDFButton;
  }
});

// node_modules/pdf-lib/cjs/api/form/index.js
var require_form = __commonJS({
  "node_modules/pdf-lib/cjs/api/form/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_appearances(), exports);
    var PDFButton_1 = require_PDFButton();
    Object.defineProperty(exports, "PDFButton", { enumerable: true, get: function() {
      return PDFButton_1.default;
    } });
    var PDFCheckBox_1 = require_PDFCheckBox();
    Object.defineProperty(exports, "PDFCheckBox", { enumerable: true, get: function() {
      return PDFCheckBox_1.default;
    } });
    var PDFDropdown_1 = require_PDFDropdown();
    Object.defineProperty(exports, "PDFDropdown", { enumerable: true, get: function() {
      return PDFDropdown_1.default;
    } });
    var PDFField_1 = require_PDFField();
    Object.defineProperty(exports, "PDFField", { enumerable: true, get: function() {
      return PDFField_1.default;
    } });
    var PDFForm_1 = require_PDFForm();
    Object.defineProperty(exports, "PDFForm", { enumerable: true, get: function() {
      return PDFForm_1.default;
    } });
    var PDFOptionList_1 = require_PDFOptionList();
    Object.defineProperty(exports, "PDFOptionList", { enumerable: true, get: function() {
      return PDFOptionList_1.default;
    } });
    var PDFRadioGroup_1 = require_PDFRadioGroup();
    Object.defineProperty(exports, "PDFRadioGroup", { enumerable: true, get: function() {
      return PDFRadioGroup_1.default;
    } });
    var PDFSignature_1 = require_PDFSignature();
    Object.defineProperty(exports, "PDFSignature", { enumerable: true, get: function() {
      return PDFSignature_1.default;
    } });
    var PDFTextField_1 = require_PDFTextField();
    Object.defineProperty(exports, "PDFTextField", { enumerable: true, get: function() {
      return PDFTextField_1.default;
    } });
  }
});

// node_modules/pdf-lib/cjs/api/text/index.js
var require_text = __commonJS({
  "node_modules/pdf-lib/cjs/api/text/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_alignment(), exports);
    tslib_1.__exportStar(require_layout(), exports);
  }
});

// node_modules/pdf-lib/cjs/api/index.js
var require_api = __commonJS({
  "node_modules/pdf-lib/cjs/api/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_form(), exports);
    tslib_1.__exportStar(require_text(), exports);
    tslib_1.__exportStar(require_colors(), exports);
    tslib_1.__exportStar(require_errors3(), exports);
    tslib_1.__exportStar(require_image(), exports);
    tslib_1.__exportStar(require_objects2(), exports);
    tslib_1.__exportStar(require_operations(), exports);
    tslib_1.__exportStar(require_operators(), exports);
    tslib_1.__exportStar(require_rotations(), exports);
    tslib_1.__exportStar(require_sizes(), exports);
    tslib_1.__exportStar(require_PDFPageOptions(), exports);
    tslib_1.__exportStar(require_PDFDocumentOptions(), exports);
    tslib_1.__exportStar(require_StandardFonts(), exports);
    var PDFDocument_1 = require_PDFDocument();
    Object.defineProperty(exports, "PDFDocument", { enumerable: true, get: function() {
      return PDFDocument_1.default;
    } });
    var PDFFont_1 = require_PDFFont();
    Object.defineProperty(exports, "PDFFont", { enumerable: true, get: function() {
      return PDFFont_1.default;
    } });
    var PDFImage_1 = require_PDFImage();
    Object.defineProperty(exports, "PDFImage", { enumerable: true, get: function() {
      return PDFImage_1.default;
    } });
    var PDFPage_1 = require_PDFPage();
    Object.defineProperty(exports, "PDFPage", { enumerable: true, get: function() {
      return PDFPage_1.default;
    } });
    var PDFEmbeddedPage_1 = require_PDFEmbeddedPage();
    Object.defineProperty(exports, "PDFEmbeddedPage", { enumerable: true, get: function() {
      return PDFEmbeddedPage_1.default;
    } });
    var PDFJavaScript_1 = require_PDFJavaScript();
    Object.defineProperty(exports, "PDFJavaScript", { enumerable: true, get: function() {
      return PDFJavaScript_1.default;
    } });
  }
});

// node_modules/pdf-lib/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/pdf-lib/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/pdf-lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/pdf-lib/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_api(), exports);
    tslib_1.__exportStar(require_core(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_utils2(), exports);
  }
});

// node_modules/html-to-image/lib/util.js
var require_util = __commonJS({
  "node_modules/html-to-image/lib/util.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInstanceOfElement = exports.nodeToDataURL = exports.svgToDataURL = exports.createImage = exports.canvasToBlob = exports.checkCanvasDimensions = exports.getPixelRatio = exports.getImageSize = exports.getStyleProperties = exports.toArray = exports.delay = exports.uuid = exports.resolveUrl = void 0;
    function resolveUrl(url, baseUrl) {
      if (url.match(/^[a-z]+:\/\//i)) {
        return url;
      }
      if (url.match(/^\/\//)) {
        return window.location.protocol + url;
      }
      if (url.match(/^[a-z]+:/i)) {
        return url;
      }
      var doc = document.implementation.createHTMLDocument();
      var base = doc.createElement("base");
      var a = doc.createElement("a");
      doc.head.appendChild(base);
      doc.body.appendChild(a);
      if (baseUrl) {
        base.href = baseUrl;
      }
      a.href = url;
      return a.href;
    }
    exports.resolveUrl = resolveUrl;
    exports.uuid = function() {
      var counter = 0;
      var random = function() {
        return "0000".concat((Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
      };
      return function() {
        counter += 1;
        return "u".concat(random()).concat(counter);
      };
    }();
    function delay(ms) {
      return function(args) {
        return new Promise(function(resolve) {
          setTimeout(function() {
            return resolve(args);
          }, ms);
        });
      };
    }
    exports.delay = delay;
    function toArray(arrayLike) {
      var arr = [];
      for (var i = 0, l = arrayLike.length; i < l; i++) {
        arr.push(arrayLike[i]);
      }
      return arr;
    }
    exports.toArray = toArray;
    var styleProps = null;
    function getStyleProperties(options) {
      if (options === void 0) {
        options = {};
      }
      if (styleProps) {
        return styleProps;
      }
      if (options.includeStyleProperties) {
        styleProps = options.includeStyleProperties;
        return styleProps;
      }
      styleProps = toArray(window.getComputedStyle(document.documentElement));
      return styleProps;
    }
    exports.getStyleProperties = getStyleProperties;
    function px(node, styleProperty) {
      var win = node.ownerDocument.defaultView || window;
      var val = win.getComputedStyle(node).getPropertyValue(styleProperty);
      return val ? parseFloat(val.replace("px", "")) : 0;
    }
    function getNodeWidth(node) {
      var leftBorder = px(node, "border-left-width");
      var rightBorder = px(node, "border-right-width");
      return node.clientWidth + leftBorder + rightBorder;
    }
    function getNodeHeight(node) {
      var topBorder = px(node, "border-top-width");
      var bottomBorder = px(node, "border-bottom-width");
      return node.clientHeight + topBorder + bottomBorder;
    }
    function getImageSize(targetNode, options) {
      if (options === void 0) {
        options = {};
      }
      var width = options.width || getNodeWidth(targetNode);
      var height = options.height || getNodeHeight(targetNode);
      return { width, height };
    }
    exports.getImageSize = getImageSize;
    function getPixelRatio() {
      var ratio;
      var FINAL_PROCESS;
      try {
        FINAL_PROCESS = process;
      } catch (e) {
      }
      var val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
      if (val) {
        ratio = parseInt(val, 10);
        if (Number.isNaN(ratio)) {
          ratio = 1;
        }
      }
      return ratio || window.devicePixelRatio || 1;
    }
    exports.getPixelRatio = getPixelRatio;
    var canvasDimensionLimit = 16384;
    function checkCanvasDimensions(canvas) {
      if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
        if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
          if (canvas.width > canvas.height) {
            canvas.height *= canvasDimensionLimit / canvas.width;
            canvas.width = canvasDimensionLimit;
          } else {
            canvas.width *= canvasDimensionLimit / canvas.height;
            canvas.height = canvasDimensionLimit;
          }
        } else if (canvas.width > canvasDimensionLimit) {
          canvas.height *= canvasDimensionLimit / canvas.width;
          canvas.width = canvasDimensionLimit;
        } else {
          canvas.width *= canvasDimensionLimit / canvas.height;
          canvas.height = canvasDimensionLimit;
        }
      }
    }
    exports.checkCanvasDimensions = checkCanvasDimensions;
    function canvasToBlob(canvas, options) {
      if (options === void 0) {
        options = {};
      }
      if (canvas.toBlob) {
        return new Promise(function(resolve) {
          canvas.toBlob(resolve, options.type ? options.type : "image/png", options.quality ? options.quality : 1);
        });
      }
      return new Promise(function(resolve) {
        var binaryString = window.atob(canvas.toDataURL(options.type ? options.type : void 0, options.quality ? options.quality : void 0).split(",")[1]);
        var len = binaryString.length;
        var binaryArray = new Uint8Array(len);
        for (var i = 0; i < len; i += 1) {
          binaryArray[i] = binaryString.charCodeAt(i);
        }
        resolve(new Blob([binaryArray], {
          type: options.type ? options.type : "image/png"
        }));
      });
    }
    exports.canvasToBlob = canvasToBlob;
    function createImage(url) {
      return new Promise(function(resolve, reject) {
        var img = new Image();
        img.onload = function() {
          img.decode().then(function() {
            requestAnimationFrame(function() {
              return resolve(img);
            });
          });
        };
        img.onerror = reject;
        img.crossOrigin = "anonymous";
        img.decoding = "async";
        img.src = url;
      });
    }
    exports.createImage = createImage;
    function svgToDataURL(svg) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          return [2, Promise.resolve().then(function() {
            return new XMLSerializer().serializeToString(svg);
          }).then(encodeURIComponent).then(function(html) {
            return "data:image/svg+xml;charset=utf-8,".concat(html);
          })];
        });
      });
    }
    exports.svgToDataURL = svgToDataURL;
    function nodeToDataURL(node, width, height) {
      return __awaiter2(this, void 0, void 0, function() {
        var xmlns, svg, foreignObject;
        return __generator2(this, function(_a) {
          xmlns = "http://www.w3.org/2000/svg";
          svg = document.createElementNS(xmlns, "svg");
          foreignObject = document.createElementNS(xmlns, "foreignObject");
          svg.setAttribute("width", "".concat(width));
          svg.setAttribute("height", "".concat(height));
          svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
          foreignObject.setAttribute("width", "100%");
          foreignObject.setAttribute("height", "100%");
          foreignObject.setAttribute("x", "0");
          foreignObject.setAttribute("y", "0");
          foreignObject.setAttribute("externalResourcesRequired", "true");
          svg.appendChild(foreignObject);
          foreignObject.appendChild(node);
          return [2, svgToDataURL(svg)];
        });
      });
    }
    exports.nodeToDataURL = nodeToDataURL;
    var isInstanceOfElement = function(node, instance) {
      if (node instanceof instance)
        return true;
      var nodePrototype = Object.getPrototypeOf(node);
      if (nodePrototype === null)
        return false;
      return nodePrototype.constructor.name === instance.name || (0, exports.isInstanceOfElement)(nodePrototype, instance);
    };
    exports.isInstanceOfElement = isInstanceOfElement;
  }
});

// node_modules/html-to-image/lib/clone-pseudos.js
var require_clone_pseudos = __commonJS({
  "node_modules/html-to-image/lib/clone-pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clonePseudoElements = void 0;
    var util_1 = require_util();
    function formatCSSText(style) {
      var content = style.getPropertyValue("content");
      return "".concat(style.cssText, " content: '").concat(content.replace(/'|"/g, ""), "';");
    }
    function formatCSSProperties(style, options) {
      return (0, util_1.getStyleProperties)(options).map(function(name) {
        var value = style.getPropertyValue(name);
        var priority = style.getPropertyPriority(name);
        return "".concat(name, ": ").concat(value).concat(priority ? " !important" : "", ";");
      }).join(" ");
    }
    function getPseudoElementStyle(className, pseudo, style, options) {
      var selector = ".".concat(className, ":").concat(pseudo);
      var cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style, options);
      return document.createTextNode("".concat(selector, "{").concat(cssText, "}"));
    }
    function clonePseudoElement(nativeNode, clonedNode, pseudo, options) {
      var style = window.getComputedStyle(nativeNode, pseudo);
      var content = style.getPropertyValue("content");
      if (content === "" || content === "none") {
        return;
      }
      var className = (0, util_1.uuid)();
      try {
        clonedNode.className = "".concat(clonedNode.className, " ").concat(className);
      } catch (err) {
        return;
      }
      var styleElement = document.createElement("style");
      styleElement.appendChild(getPseudoElementStyle(className, pseudo, style, options));
      clonedNode.appendChild(styleElement);
    }
    function clonePseudoElements(nativeNode, clonedNode, options) {
      clonePseudoElement(nativeNode, clonedNode, ":before", options);
      clonePseudoElement(nativeNode, clonedNode, ":after", options);
    }
    exports.clonePseudoElements = clonePseudoElements;
  }
});

// node_modules/html-to-image/lib/mimes.js
var require_mimes = __commonJS({
  "node_modules/html-to-image/lib/mimes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMimeType = void 0;
    var WOFF = "application/font-woff";
    var JPEG = "image/jpeg";
    var mimes = {
      woff: WOFF,
      woff2: WOFF,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: JPEG,
      jpeg: JPEG,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml",
      webp: "image/webp"
    };
    function getExtension(url) {
      var match = /\.([^./]*?)$/g.exec(url);
      return match ? match[1] : "";
    }
    function getMimeType(url) {
      var extension = getExtension(url).toLowerCase();
      return mimes[extension] || "";
    }
    exports.getMimeType = getMimeType;
  }
});

// node_modules/html-to-image/lib/dataurl.js
var require_dataurl = __commonJS({
  "node_modules/html-to-image/lib/dataurl.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resourceToDataURL = exports.fetchAsDataURL = exports.makeDataUrl = exports.isDataUrl = void 0;
    function getContentFromDataUrl(dataURL) {
      return dataURL.split(/,/)[1];
    }
    function isDataUrl(url) {
      return url.search(/^(data:)/) !== -1;
    }
    exports.isDataUrl = isDataUrl;
    function makeDataUrl(content, mimeType) {
      return "data:".concat(mimeType, ";base64,").concat(content);
    }
    exports.makeDataUrl = makeDataUrl;
    function fetchAsDataURL(url, init, process2) {
      return __awaiter2(this, void 0, void 0, function() {
        var res, blob;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, fetch(url, init)];
            case 1:
              res = _a.sent();
              if (res.status === 404) {
                throw new Error('Resource "'.concat(res.url, '" not found'));
              }
              return [4, res.blob()];
            case 2:
              blob = _a.sent();
              return [2, new Promise(function(resolve, reject) {
                var reader = new FileReader();
                reader.onerror = reject;
                reader.onloadend = function() {
                  try {
                    resolve(process2({ res, result: reader.result }));
                  } catch (error) {
                    reject(error);
                  }
                };
                reader.readAsDataURL(blob);
              })];
          }
        });
      });
    }
    exports.fetchAsDataURL = fetchAsDataURL;
    var cache = {};
    function getCacheKey(url, contentType, includeQueryParams) {
      var key = url.replace(/\?.*/, "");
      if (includeQueryParams) {
        key = url;
      }
      if (/ttf|otf|eot|woff2?/i.test(key)) {
        key = key.replace(/.*\//, "");
      }
      return contentType ? "[".concat(contentType, "]").concat(key) : key;
    }
    function resourceToDataURL(resourceUrl, contentType, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var cacheKey, dataURL, content, error_1, msg;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
              if (cache[cacheKey] != null) {
                return [2, cache[cacheKey]];
              }
              if (options.cacheBust) {
                resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + new Date().getTime();
              }
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, , 4]);
              return [4, fetchAsDataURL(resourceUrl, options.fetchRequestInit, function(_a2) {
                var res = _a2.res, result = _a2.result;
                if (!contentType) {
                  contentType = res.headers.get("Content-Type") || "";
                }
                return getContentFromDataUrl(result);
              })];
            case 2:
              content = _a.sent();
              dataURL = makeDataUrl(content, contentType);
              return [3, 4];
            case 3:
              error_1 = _a.sent();
              dataURL = options.imagePlaceholder || "";
              msg = "Failed to fetch resource: ".concat(resourceUrl);
              if (error_1) {
                msg = typeof error_1 === "string" ? error_1 : error_1.message;
              }
              if (msg) {
                console.warn(msg);
              }
              return [3, 4];
            case 4:
              cache[cacheKey] = dataURL;
              return [2, dataURL];
          }
        });
      });
    }
    exports.resourceToDataURL = resourceToDataURL;
  }
});

// node_modules/html-to-image/lib/clone-node.js
var require_clone_node = __commonJS({
  "node_modules/html-to-image/lib/clone-node.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = void 0;
    var clone_pseudos_1 = require_clone_pseudos();
    var util_1 = require_util();
    var mimes_1 = require_mimes();
    var dataurl_1 = require_dataurl();
    function cloneCanvasElement(canvas) {
      return __awaiter2(this, void 0, void 0, function() {
        var dataURL;
        return __generator2(this, function(_a) {
          dataURL = canvas.toDataURL();
          if (dataURL === "data:,") {
            return [2, canvas.cloneNode(false)];
          }
          return [2, (0, util_1.createImage)(dataURL)];
        });
      });
    }
    function cloneVideoElement(video, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var canvas, ctx, dataURL_1, poster, contentType, dataURL;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (video.currentSrc) {
                canvas = document.createElement("canvas");
                ctx = canvas.getContext("2d");
                canvas.width = video.clientWidth;
                canvas.height = video.clientHeight;
                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                dataURL_1 = canvas.toDataURL();
                return [2, (0, util_1.createImage)(dataURL_1)];
              }
              poster = video.poster;
              contentType = (0, mimes_1.getMimeType)(poster);
              return [4, (0, dataurl_1.resourceToDataURL)(poster, contentType, options)];
            case 1:
              dataURL = _a.sent();
              return [2, (0, util_1.createImage)(dataURL)];
          }
        });
      });
    }
    function cloneIFrameElement(iframe, options) {
      var _a;
      return __awaiter2(this, void 0, void 0, function() {
        var _b;
        return __generator2(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 3, , 4]);
              if (!((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body))
                return [3, 2];
              return [4, cloneNode(iframe.contentDocument.body, options, true)];
            case 1:
              return [2, _c.sent()];
            case 2:
              return [3, 4];
            case 3:
              _b = _c.sent();
              return [3, 4];
            case 4:
              return [2, iframe.cloneNode(false)];
          }
        });
      });
    }
    function cloneSingleNode(node, options) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          if ((0, util_1.isInstanceOfElement)(node, HTMLCanvasElement)) {
            return [2, cloneCanvasElement(node)];
          }
          if ((0, util_1.isInstanceOfElement)(node, HTMLVideoElement)) {
            return [2, cloneVideoElement(node, options)];
          }
          if ((0, util_1.isInstanceOfElement)(node, HTMLIFrameElement)) {
            return [2, cloneIFrameElement(node, options)];
          }
          return [2, node.cloneNode(isSVGElement(node))];
        });
      });
    }
    var isSlotElement = function(node) {
      return node.tagName != null && node.tagName.toUpperCase() === "SLOT";
    };
    var isSVGElement = function(node) {
      return node.tagName != null && node.tagName.toUpperCase() === "SVG";
    };
    function cloneChildren(nativeNode, clonedNode, options) {
      var _a, _b;
      return __awaiter2(this, void 0, void 0, function() {
        var children;
        return __generator2(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (isSVGElement(clonedNode)) {
                return [2, clonedNode];
              }
              children = [];
              if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
                children = (0, util_1.toArray)(nativeNode.assignedNodes());
              } else if ((0, util_1.isInstanceOfElement)(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
                children = (0, util_1.toArray)(nativeNode.contentDocument.body.childNodes);
              } else {
                children = (0, util_1.toArray)(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
              }
              if (children.length === 0 || (0, util_1.isInstanceOfElement)(nativeNode, HTMLVideoElement)) {
                return [2, clonedNode];
              }
              return [4, children.reduce(function(deferred, child) {
                return deferred.then(function() {
                  return cloneNode(child, options);
                }).then(function(clonedChild) {
                  if (clonedChild) {
                    clonedNode.appendChild(clonedChild);
                  }
                });
              }, Promise.resolve())];
            case 1:
              _c.sent();
              return [2, clonedNode];
          }
        });
      });
    }
    function cloneCSSStyle(nativeNode, clonedNode, options) {
      var targetStyle = clonedNode.style;
      if (!targetStyle) {
        return;
      }
      var sourceStyle = window.getComputedStyle(nativeNode);
      if (sourceStyle.cssText) {
        targetStyle.cssText = sourceStyle.cssText;
        targetStyle.transformOrigin = sourceStyle.transformOrigin;
      } else {
        (0, util_1.getStyleProperties)(options).forEach(function(name) {
          var value = sourceStyle.getPropertyValue(name);
          if (name === "font-size" && value.endsWith("px")) {
            var reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
            value = "".concat(reducedFont, "px");
          }
          if ((0, util_1.isInstanceOfElement)(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
            value = "block";
          }
          if (name === "d" && clonedNode.getAttribute("d")) {
            value = "path(".concat(clonedNode.getAttribute("d"), ")");
          }
          targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
        });
      }
    }
    function cloneInputValue(nativeNode, clonedNode) {
      if ((0, util_1.isInstanceOfElement)(nativeNode, HTMLTextAreaElement)) {
        clonedNode.innerHTML = nativeNode.value;
      }
      if ((0, util_1.isInstanceOfElement)(nativeNode, HTMLInputElement)) {
        clonedNode.setAttribute("value", nativeNode.value);
      }
    }
    function cloneSelectValue(nativeNode, clonedNode) {
      if ((0, util_1.isInstanceOfElement)(nativeNode, HTMLSelectElement)) {
        var clonedSelect = clonedNode;
        var selectedOption = Array.from(clonedSelect.children).find(function(child) {
          return nativeNode.value === child.getAttribute("value");
        });
        if (selectedOption) {
          selectedOption.setAttribute("selected", "");
        }
      }
    }
    function decorate(nativeNode, clonedNode, options) {
      if ((0, util_1.isInstanceOfElement)(clonedNode, Element)) {
        cloneCSSStyle(nativeNode, clonedNode, options);
        (0, clone_pseudos_1.clonePseudoElements)(nativeNode, clonedNode, options);
        cloneInputValue(nativeNode, clonedNode);
        cloneSelectValue(nativeNode, clonedNode);
      }
      return clonedNode;
    }
    function ensureSVGSymbols(clone, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var uses, processedDefs, i, use, id, exist, definition, _a, _b, nodes, ns, svg, defs, i;
        return __generator2(this, function(_c) {
          switch (_c.label) {
            case 0:
              uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
              if (uses.length === 0) {
                return [2, clone];
              }
              processedDefs = {};
              i = 0;
              _c.label = 1;
            case 1:
              if (!(i < uses.length))
                return [3, 4];
              use = uses[i];
              id = use.getAttribute("xlink:href");
              if (!id)
                return [3, 3];
              exist = clone.querySelector(id);
              definition = document.querySelector(id);
              if (!(!exist && definition && !processedDefs[id]))
                return [3, 3];
              _a = processedDefs;
              _b = id;
              return [4, cloneNode(definition, options, true)];
            case 2:
              _a[_b] = _c.sent();
              _c.label = 3;
            case 3:
              i++;
              return [3, 1];
            case 4:
              nodes = Object.values(processedDefs);
              if (nodes.length) {
                ns = "http://www.w3.org/1999/xhtml";
                svg = document.createElementNS(ns, "svg");
                svg.setAttribute("xmlns", ns);
                svg.style.position = "absolute";
                svg.style.width = "0";
                svg.style.height = "0";
                svg.style.overflow = "hidden";
                svg.style.display = "none";
                defs = document.createElementNS(ns, "defs");
                svg.appendChild(defs);
                for (i = 0; i < nodes.length; i++) {
                  defs.appendChild(nodes[i]);
                }
                clone.appendChild(svg);
              }
              return [2, clone];
          }
        });
      });
    }
    function cloneNode(node, options, isRoot) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          if (!isRoot && options.filter && !options.filter(node)) {
            return [2, null];
          }
          return [2, Promise.resolve(node).then(function(clonedNode) {
            return cloneSingleNode(clonedNode, options);
          }).then(function(clonedNode) {
            return cloneChildren(node, clonedNode, options);
          }).then(function(clonedNode) {
            return decorate(node, clonedNode, options);
          }).then(function(clonedNode) {
            return ensureSVGSymbols(clonedNode, options);
          })];
        });
      });
    }
    exports.cloneNode = cloneNode;
  }
});

// node_modules/html-to-image/lib/embed-resources.js
var require_embed_resources = __commonJS({
  "node_modules/html-to-image/lib/embed-resources.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.embedResources = exports.shouldEmbed = exports.embed = exports.parseURLs = void 0;
    var util_1 = require_util();
    var mimes_1 = require_mimes();
    var dataurl_1 = require_dataurl();
    var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
    var URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
    var FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
    function toRegex(url) {
      var escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
      return new RegExp(`(url\\(['"]?)(`.concat(escaped, `)(['"]?\\))`), "g");
    }
    function parseURLs(cssText) {
      var urls = [];
      cssText.replace(URL_REGEX, function(raw, quotation, url) {
        urls.push(url);
        return raw;
      });
      return urls.filter(function(url) {
        return !(0, dataurl_1.isDataUrl)(url);
      });
    }
    exports.parseURLs = parseURLs;
    function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
      return __awaiter2(this, void 0, void 0, function() {
        var resolvedURL, contentType, dataURL, content, error_1;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 5, , 6]);
              resolvedURL = baseURL ? (0, util_1.resolveUrl)(resourceURL, baseURL) : resourceURL;
              contentType = (0, mimes_1.getMimeType)(resourceURL);
              dataURL = void 0;
              if (!getContentFromUrl)
                return [3, 2];
              return [4, getContentFromUrl(resolvedURL)];
            case 1:
              content = _a.sent();
              dataURL = (0, dataurl_1.makeDataUrl)(content, contentType);
              return [3, 4];
            case 2:
              return [4, (0, dataurl_1.resourceToDataURL)(resolvedURL, contentType, options)];
            case 3:
              dataURL = _a.sent();
              _a.label = 4;
            case 4:
              return [2, cssText.replace(toRegex(resourceURL), "$1".concat(dataURL, "$3"))];
            case 5:
              error_1 = _a.sent();
              return [3, 6];
            case 6:
              return [2, cssText];
          }
        });
      });
    }
    exports.embed = embed;
    function filterPreferredFontFormat(str, _a) {
      var preferredFontFormat = _a.preferredFontFormat;
      return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, function(match) {
        while (true) {
          var _a2 = URL_WITH_FORMAT_REGEX.exec(match) || [], src = _a2[0], format = _a2[2];
          if (!format) {
            return "";
          }
          if (format === preferredFontFormat) {
            return "src: ".concat(src, ";");
          }
        }
      });
    }
    function shouldEmbed(url) {
      return url.search(URL_REGEX) !== -1;
    }
    exports.shouldEmbed = shouldEmbed;
    function embedResources(cssText, baseUrl, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var filteredCSSText, urls;
        return __generator2(this, function(_a) {
          if (!shouldEmbed(cssText)) {
            return [2, cssText];
          }
          filteredCSSText = filterPreferredFontFormat(cssText, options);
          urls = parseURLs(filteredCSSText);
          return [2, urls.reduce(function(deferred, url) {
            return deferred.then(function(css) {
              return embed(css, url, baseUrl, options);
            });
          }, Promise.resolve(filteredCSSText))];
        });
      });
    }
    exports.embedResources = embedResources;
  }
});

// node_modules/html-to-image/lib/embed-images.js
var require_embed_images = __commonJS({
  "node_modules/html-to-image/lib/embed-images.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.embedImages = void 0;
    var embed_resources_1 = require_embed_resources();
    var util_1 = require_util();
    var dataurl_1 = require_dataurl();
    var mimes_1 = require_mimes();
    function embedProp(propName, node, options) {
      var _a;
      return __awaiter2(this, void 0, void 0, function() {
        var propValue, cssString;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
              if (!propValue)
                return [3, 2];
              return [4, (0, embed_resources_1.embedResources)(propValue, null, options)];
            case 1:
              cssString = _b.sent();
              node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
              return [2, true];
            case 2:
              return [2, false];
          }
        });
      });
    }
    function embedBackground(clonedNode, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var _a, _b, _c, _d;
        return __generator2(this, function(_e) {
          switch (_e.label) {
            case 0:
              ;
              return [4, embedProp("background", clonedNode, options)];
            case 1:
              _a = _e.sent();
              if (_a)
                return [3, 3];
              return [4, embedProp("background-image", clonedNode, options)];
            case 2:
              _a = _e.sent();
              _e.label = 3;
            case 3:
              _a;
              return [4, embedProp("mask", clonedNode, options)];
            case 4:
              _d = _e.sent();
              if (_d)
                return [3, 6];
              return [4, embedProp("-webkit-mask", clonedNode, options)];
            case 5:
              _d = _e.sent();
              _e.label = 6;
            case 6:
              _c = _d;
              if (_c)
                return [3, 8];
              return [4, embedProp("mask-image", clonedNode, options)];
            case 7:
              _c = _e.sent();
              _e.label = 8;
            case 8:
              _b = _c;
              if (_b)
                return [3, 10];
              return [4, embedProp("-webkit-mask-image", clonedNode, options)];
            case 9:
              _b = _e.sent();
              _e.label = 10;
            case 10:
              _b;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    function embedImageNode(clonedNode, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var isImageElement, url, dataURL;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              isImageElement = (0, util_1.isInstanceOfElement)(clonedNode, HTMLImageElement);
              if (!(isImageElement && !(0, dataurl_1.isDataUrl)(clonedNode.src)) && !((0, util_1.isInstanceOfElement)(clonedNode, SVGImageElement) && !(0, dataurl_1.isDataUrl)(clonedNode.href.baseVal))) {
                return [
                  2
                  /*return*/
                ];
              }
              url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
              return [4, (0, dataurl_1.resourceToDataURL)(url, (0, mimes_1.getMimeType)(url), options)];
            case 1:
              dataURL = _a.sent();
              return [4, new Promise(function(resolve, reject) {
                clonedNode.onload = resolve;
                clonedNode.onerror = options.onImageErrorHandler ? function() {
                  var attributes = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    attributes[_i] = arguments[_i];
                  }
                  try {
                    resolve(options.onImageErrorHandler.apply(options, attributes));
                  } catch (error) {
                    reject(error);
                  }
                } : reject;
                var image = clonedNode;
                if (image.decode) {
                  image.decode = resolve;
                }
                if (image.loading === "lazy") {
                  image.loading = "eager";
                }
                if (isImageElement) {
                  clonedNode.srcset = "";
                  clonedNode.src = dataURL;
                } else {
                  clonedNode.href.baseVal = dataURL;
                }
              })];
            case 2:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    function embedChildren(clonedNode, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var children, deferreds;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              children = (0, util_1.toArray)(clonedNode.childNodes);
              deferreds = children.map(function(child) {
                return embedImages(child, options);
              });
              return [4, Promise.all(deferreds).then(function() {
                return clonedNode;
              })];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    function embedImages(clonedNode, options) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!(0, util_1.isInstanceOfElement)(clonedNode, Element))
                return [3, 4];
              return [4, embedBackground(clonedNode, options)];
            case 1:
              _a.sent();
              return [4, embedImageNode(clonedNode, options)];
            case 2:
              _a.sent();
              return [4, embedChildren(clonedNode, options)];
            case 3:
              _a.sent();
              _a.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.embedImages = embedImages;
  }
});

// node_modules/html-to-image/lib/apply-style.js
var require_apply_style = __commonJS({
  "node_modules/html-to-image/lib/apply-style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyStyle = void 0;
    function applyStyle(node, options) {
      var style = node.style;
      if (options.backgroundColor) {
        style.backgroundColor = options.backgroundColor;
      }
      if (options.width) {
        style.width = "".concat(options.width, "px");
      }
      if (options.height) {
        style.height = "".concat(options.height, "px");
      }
      var manual = options.style;
      if (manual != null) {
        Object.keys(manual).forEach(function(key) {
          style[key] = manual[key];
        });
      }
      return node;
    }
    exports.applyStyle = applyStyle;
  }
});

// node_modules/html-to-image/lib/embed-webfonts.js
var require_embed_webfonts = __commonJS({
  "node_modules/html-to-image/lib/embed-webfonts.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.embedWebFonts = exports.getWebFontCSS = void 0;
    var util_1 = require_util();
    var dataurl_1 = require_dataurl();
    var embed_resources_1 = require_embed_resources();
    var cssFetchCache = {};
    function fetchCSS(url) {
      return __awaiter2(this, void 0, void 0, function() {
        var cache, res, cssText;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              cache = cssFetchCache[url];
              if (cache != null) {
                return [2, cache];
              }
              return [4, fetch(url)];
            case 1:
              res = _a.sent();
              return [4, res.text()];
            case 2:
              cssText = _a.sent();
              cache = { url, cssText };
              cssFetchCache[url] = cache;
              return [2, cache];
          }
        });
      });
    }
    function embedFonts(data, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var cssText, regexUrl, fontLocs, loadFonts;
        var _this = this;
        return __generator2(this, function(_a) {
          cssText = data.cssText;
          regexUrl = /url\(["']?([^"')]+)["']?\)/g;
          fontLocs = cssText.match(/url\([^)]+\)/g) || [];
          loadFonts = fontLocs.map(function(loc) {
            return __awaiter2(_this, void 0, void 0, function() {
              var url;
              return __generator2(this, function(_a2) {
                url = loc.replace(regexUrl, "$1");
                if (!url.startsWith("https://")) {
                  url = new URL(url, data.url).href;
                }
                return [2, (0, dataurl_1.fetchAsDataURL)(url, options.fetchRequestInit, function(_a3) {
                  var result = _a3.result;
                  cssText = cssText.replace(loc, "url(".concat(result, ")"));
                  return [loc, result];
                })];
              });
            });
          });
          return [2, Promise.all(loadFonts).then(function() {
            return cssText;
          })];
        });
      });
    }
    function parseCSS(source) {
      if (source == null) {
        return [];
      }
      var result = [];
      var commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
      var cssText = source.replace(commentsRegex, "");
      var keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
      while (true) {
        var matches = keyframesRegex.exec(cssText);
        if (matches === null) {
          break;
        }
        result.push(matches[0]);
      }
      cssText = cssText.replace(keyframesRegex, "");
      var importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
      var combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
      var unifiedRegex = new RegExp(combinedCSSRegex, "gi");
      while (true) {
        var matches = importRegex.exec(cssText);
        if (matches === null) {
          matches = unifiedRegex.exec(cssText);
          if (matches === null) {
            break;
          } else {
            importRegex.lastIndex = unifiedRegex.lastIndex;
          }
        } else {
          unifiedRegex.lastIndex = importRegex.lastIndex;
        }
        result.push(matches[0]);
      }
      return result;
    }
    function getCSSRules(styleSheets, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var ret, deferreds;
        return __generator2(this, function(_a) {
          ret = [];
          deferreds = [];
          styleSheets.forEach(function(sheet) {
            if ("cssRules" in sheet) {
              try {
                (0, util_1.toArray)(sheet.cssRules || []).forEach(function(item, index) {
                  if (item.type === CSSRule.IMPORT_RULE) {
                    var importIndex_1 = index + 1;
                    var url = item.href;
                    var deferred = fetchCSS(url).then(function(metadata) {
                      return embedFonts(metadata, options);
                    }).then(function(cssText) {
                      return parseCSS(cssText).forEach(function(rule) {
                        try {
                          sheet.insertRule(rule, rule.startsWith("@import") ? importIndex_1 += 1 : sheet.cssRules.length);
                        } catch (error) {
                          console.error("Error inserting rule from remote css", {
                            rule,
                            error
                          });
                        }
                      });
                    }).catch(function(e) {
                      console.error("Error loading remote css", e.toString());
                    });
                    deferreds.push(deferred);
                  }
                });
              } catch (e) {
                var inline_1 = styleSheets.find(function(a) {
                  return a.href == null;
                }) || document.styleSheets[0];
                if (sheet.href != null) {
                  deferreds.push(fetchCSS(sheet.href).then(function(metadata) {
                    return embedFonts(metadata, options);
                  }).then(function(cssText) {
                    return parseCSS(cssText).forEach(function(rule) {
                      inline_1.insertRule(rule, inline_1.cssRules.length);
                    });
                  }).catch(function(err) {
                    console.error("Error loading remote stylesheet", err);
                  }));
                }
                console.error("Error inlining remote css file", e);
              }
            }
          });
          return [2, Promise.all(deferreds).then(function() {
            styleSheets.forEach(function(sheet) {
              if ("cssRules" in sheet) {
                try {
                  (0, util_1.toArray)(sheet.cssRules || []).forEach(function(item) {
                    ret.push(item);
                  });
                } catch (e) {
                  console.error("Error while reading CSS rules from ".concat(sheet.href), e);
                }
              }
            });
            return ret;
          })];
        });
      });
    }
    function getWebFontRules(cssRules) {
      return cssRules.filter(function(rule) {
        return rule.type === CSSRule.FONT_FACE_RULE;
      }).filter(function(rule) {
        return (0, embed_resources_1.shouldEmbed)(rule.style.getPropertyValue("src"));
      });
    }
    function parseWebFontRules(node, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var styleSheets, cssRules;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (node.ownerDocument == null) {
                throw new Error("Provided element is not within a Document");
              }
              styleSheets = (0, util_1.toArray)(node.ownerDocument.styleSheets);
              return [4, getCSSRules(styleSheets, options)];
            case 1:
              cssRules = _a.sent();
              return [2, getWebFontRules(cssRules)];
          }
        });
      });
    }
    function normalizeFontFamily(font) {
      return font.trim().replace(/["']/g, "");
    }
    function getUsedFonts(node) {
      var fonts = /* @__PURE__ */ new Set();
      function traverse(node2) {
        var fontFamily = node2.style.fontFamily || getComputedStyle(node2).fontFamily;
        fontFamily.split(",").forEach(function(font) {
          fonts.add(normalizeFontFamily(font));
        });
        Array.from(node2.children).forEach(function(child) {
          if (child instanceof HTMLElement) {
            traverse(child);
          }
        });
      }
      traverse(node);
      return fonts;
    }
    function getWebFontCSS(node, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var rules, usedFonts, cssTexts;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, parseWebFontRules(node, options)];
            case 1:
              rules = _a.sent();
              usedFonts = getUsedFonts(node);
              return [4, Promise.all(rules.filter(function(rule) {
                return usedFonts.has(normalizeFontFamily(rule.style.fontFamily));
              }).map(function(rule) {
                var baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
                return (0, embed_resources_1.embedResources)(rule.cssText, baseUrl, options);
              }))];
            case 2:
              cssTexts = _a.sent();
              return [2, cssTexts.join("\n")];
          }
        });
      });
    }
    exports.getWebFontCSS = getWebFontCSS;
    function embedWebFonts(clonedNode, options) {
      return __awaiter2(this, void 0, void 0, function() {
        var cssText, _a, _b, styleNode, sytleContent;
        return __generator2(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (!(options.fontEmbedCSS != null))
                return [3, 1];
              _a = options.fontEmbedCSS;
              return [3, 5];
            case 1:
              if (!options.skipFonts)
                return [3, 2];
              _b = null;
              return [3, 4];
            case 2:
              return [4, getWebFontCSS(clonedNode, options)];
            case 3:
              _b = _c.sent();
              _c.label = 4;
            case 4:
              _a = _b;
              _c.label = 5;
            case 5:
              cssText = _a;
              if (cssText) {
                styleNode = document.createElement("style");
                sytleContent = document.createTextNode(cssText);
                styleNode.appendChild(sytleContent);
                if (clonedNode.firstChild) {
                  clonedNode.insertBefore(styleNode, clonedNode.firstChild);
                } else {
                  clonedNode.appendChild(styleNode);
                }
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.embedWebFonts = embedWebFonts;
  }
});

// node_modules/html-to-image/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/html-to-image/lib/index.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFontEmbedCSS = exports.toBlob = exports.toJpeg = exports.toPng = exports.toPixelData = exports.toCanvas = exports.toSvg = void 0;
    var clone_node_1 = require_clone_node();
    var embed_images_1 = require_embed_images();
    var apply_style_1 = require_apply_style();
    var embed_webfonts_1 = require_embed_webfonts();
    var util_1 = require_util();
    function toSvg(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, width, height, clonedNode, datauri;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = (0, util_1.getImageSize)(node, options), width = _a.width, height = _a.height;
              return [4, (0, clone_node_1.cloneNode)(node, options, true)];
            case 1:
              clonedNode = _b.sent();
              return [4, (0, embed_webfonts_1.embedWebFonts)(clonedNode, options)];
            case 2:
              _b.sent();
              return [4, (0, embed_images_1.embedImages)(clonedNode, options)];
            case 3:
              _b.sent();
              (0, apply_style_1.applyStyle)(clonedNode, options);
              return [4, (0, util_1.nodeToDataURL)(clonedNode, width, height)];
            case 4:
              datauri = _b.sent();
              return [2, datauri];
          }
        });
      });
    }
    exports.toSvg = toSvg;
    function toCanvas(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, width, height, svg, img, canvas, context, ratio, canvasWidth, canvasHeight;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = (0, util_1.getImageSize)(node, options), width = _a.width, height = _a.height;
              return [4, toSvg(node, options)];
            case 1:
              svg = _b.sent();
              return [4, (0, util_1.createImage)(svg)];
            case 2:
              img = _b.sent();
              canvas = document.createElement("canvas");
              context = canvas.getContext("2d");
              ratio = options.pixelRatio || (0, util_1.getPixelRatio)();
              canvasWidth = options.canvasWidth || width;
              canvasHeight = options.canvasHeight || height;
              canvas.width = canvasWidth * ratio;
              canvas.height = canvasHeight * ratio;
              if (!options.skipAutoScale) {
                (0, util_1.checkCanvasDimensions)(canvas);
              }
              canvas.style.width = "".concat(canvasWidth);
              canvas.style.height = "".concat(canvasHeight);
              if (options.backgroundColor) {
                context.fillStyle = options.backgroundColor;
                context.fillRect(0, 0, canvas.width, canvas.height);
              }
              context.drawImage(img, 0, 0, canvas.width, canvas.height);
              return [2, canvas];
          }
        });
      });
    }
    exports.toCanvas = toCanvas;
    function toPixelData(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, width, height, canvas, ctx;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = (0, util_1.getImageSize)(node, options), width = _a.width, height = _a.height;
              return [4, toCanvas(node, options)];
            case 1:
              canvas = _b.sent();
              ctx = canvas.getContext("2d");
              return [2, ctx.getImageData(0, 0, width, height).data];
          }
        });
      });
    }
    exports.toPixelData = toPixelData;
    function toPng(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var canvas;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, toCanvas(node, options)];
            case 1:
              canvas = _a.sent();
              return [2, canvas.toDataURL()];
          }
        });
      });
    }
    exports.toPng = toPng;
    function toJpeg(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var canvas;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, toCanvas(node, options)];
            case 1:
              canvas = _a.sent();
              return [2, canvas.toDataURL("image/jpeg", options.quality || 1)];
          }
        });
      });
    }
    exports.toJpeg = toJpeg;
    function toBlob(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var canvas, blob;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, toCanvas(node, options)];
            case 1:
              canvas = _a.sent();
              return [4, (0, util_1.canvasToBlob)(canvas)];
            case 2:
              blob = _a.sent();
              return [2, blob];
          }
        });
      });
    }
    exports.toBlob = toBlob;
    function getFontEmbedCSS(node, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          return [2, (0, embed_webfonts_1.getWebFontCSS)(node, options)];
        });
      });
    }
    exports.getFontEmbedCSS = getFontEmbedCSS;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BookSmithPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/views/BookSmithView.ts
var import_obsidian13 = require("obsidian");

// src/modals/CreateBookModal.ts
var import_obsidian2 = require("obsidian");

// src/i18n/i18n.ts
var import_obsidian = require("obsidian");
var I18n = class {
  constructor() {
    this.locale = this.getSystemLocale();
    this.translations = {};
    this.loadTranslations();
  }
  // 获取系统语言
  getSystemLocale() {
    const systemLocale = import_obsidian.moment.locale();
    if (systemLocale.startsWith("zh"))
      return "zh-CN";
    if (systemLocale.startsWith("en"))
      return "en";
    if (systemLocale.startsWith("ja"))
      return "ja";
    if (systemLocale.startsWith("ko"))
      return "ko";
    if (systemLocale.startsWith("fr"))
      return "fr";
    if (systemLocale.startsWith("de"))
      return "de";
    if (systemLocale.startsWith("es"))
      return "es";
    if (systemLocale.startsWith("pt"))
      return "pt";
    if (systemLocale.startsWith("ru"))
      return "ru";
    return "en";
  }
  // 加载翻译文件
  loadTranslations() {
    Promise.resolve().then(() => (init_zh_CN(), zh_CN_exports)).then((module2) => {
      this.translations["zh-CN"] = module2.default;
    });
    Promise.resolve().then(() => (init_en(), en_exports)).then((module2) => {
      this.translations["en"] = module2.default;
    });
  }
  // 获取翻译文本
  t(key, params) {
    let text;
    if (!this.translations[this.locale]) {
      text = this.translations["en"][key] || key;
    } else {
      text = this.translations[this.locale][key] || this.translations["en"][key] || key;
    }
    if (params) {
      Object.keys(params).forEach((paramKey) => {
        text = text.replace(new RegExp(`{${paramKey}}`, "g"), params[paramKey]);
      });
    }
    return text;
  }
};
var i18n = new I18n();

// src/services/TemplateManager.ts
var TemplateManager = class {
  constructor(settings) {
    this.settings = settings;
  }
  getTemplate(templateType) {
    const template = this.settings.templates.custom[templateType];
    if (!template) {
      throw new Error(i18n.t("TEMPLATE_TYPE_NOT_FOUND", { type: templateType }));
    }
    return JSON.parse(JSON.stringify(template.structure));
  }
  getAllTemplates() {
    return this.settings.templates.custom;
  }
  getAllTemplateTypes() {
    return Object.entries(this.settings.templates.custom).map(([key, template]) => ({
      key,
      name: template.name
    }));
  }
};

// src/modals/CreateBookModal.ts
var CreateBookModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, onBookCreated) {
    super(app);
    this.plugin = plugin;
    this.onBookCreated = onBookCreated;
    this.bookInfo = {
      author: this.plugin.settings.defaultAuthor ? [this.plugin.settings.defaultAuthor] : []
    };
    this.selectedTemplate = "default";
    this.targetTotalWords = 1e4;
    this.templateManager = new TemplateManager(this.plugin.settings);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("book-smith-create-book-modal");
    contentEl.createEl("h2", { text: i18n.t("CREATE_BOOK_TITLE") });
    new import_obsidian2.Setting(contentEl).setName(i18n.t("BOOK_TEMPLATE")).setDesc(i18n.t("TEMPLATE_CHECK_DESC")).addDropdown((dropdown) => {
      const templates = this.templateManager.getAllTemplateTypes();
      templates.forEach((template) => {
        dropdown.addOption(template.key, template.name);
        if (template.key === this.plugin.settings.templates.default) {
          this.selectedTemplate = template.key;
        }
      });
      dropdown.setValue(this.selectedTemplate).onChange((value) => this.selectedTemplate = value);
    });
    new import_obsidian2.Setting(contentEl).setName(i18n.t("COVER")).setDesc(i18n.t("COVER_DESC")).addButton((button) => button.setButtonText(i18n.t("SELECT_IMAGE")).onClick(async () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async () => {
        var _a;
        const file = (_a = input.files) == null ? void 0 : _a[0];
        if (file) {
          try {
            const coversPath = `${this.plugin.settings.defaultBookPath}/covers`;
            if (!await this.plugin.app.vault.adapter.exists(coversPath)) {
              await this.plugin.app.vault.adapter.mkdir(coversPath);
            }
            const fileName = `cover-${Date.now()}.${file.name.split(".").pop()}`;
            const coverPath = `${coversPath}/${fileName}`;
            await this.plugin.app.vault.adapter.writeBinary(coverPath, await file.arrayBuffer());
            this.bookInfo.cover = coverPath;
            new import_obsidian2.Notice(i18n.t("COVER_UPLOAD_SUCCESS"));
          } catch (error) {
            new import_obsidian2.Notice(i18n.t("COVER_UPLOAD_FAILED") + error.message);
          }
        }
      };
      input.click();
    }));
    new import_obsidian2.Setting(contentEl).setName(i18n.t("BOOK_TITLE")).setDesc(i18n.t("BOOK_TITLE_DESC")).addText((text) => text.setPlaceholder(i18n.t("BOOK_TITLE_PLACEHOLDER")).onChange((value) => this.bookInfo.title = value));
    new import_obsidian2.Setting(contentEl).setName(i18n.t("SUBTITLE")).setDesc(i18n.t("SUBTITLE_DESC")).addText((text) => text.setPlaceholder(i18n.t("SUBTITLE_PLACEHOLDER")).onChange((value) => this.bookInfo.subtitle = value));
    new import_obsidian2.Setting(contentEl).setName(i18n.t("TARGET_WORDS")).setDesc(i18n.t("TARGET_WORDS_DESC")).addText((text) => text.setPlaceholder(i18n.t("TARGET_WORDS_PLACEHOLDER")).onChange((value) => {
      const match = value.match(/^(\d+(?:\.\d+)?)万?$/);
      if (match) {
        const num = parseFloat(match[1]) * 1e4;
        this.targetTotalWords = Math.round(num);
      } else {
        this.targetTotalWords = 1e4;
      }
    }));
    new import_obsidian2.Setting(contentEl).setName(i18n.t("AUTHOR")).setDesc(i18n.t("AUTHOR_DESC")).addText((text) => text.setPlaceholder(i18n.t("AUTHOR_PLACEHOLDER")).setValue(this.plugin.settings.defaultAuthor || "").onChange((value) => this.bookInfo.author = value ? value.split(",") : []));
    new import_obsidian2.Setting(contentEl).setName(i18n.t("DESCRIPTION")).setDesc(i18n.t("DESCRIPTION_DESC")).addTextArea((text) => text.setPlaceholder(i18n.t("DESCRIPTION_PLACEHOLDER")).onChange((value) => this.bookInfo.desc = value));
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText(i18n.t("CREATE")).setCta().onClick(async () => {
      if (!this.validateBookInfo()) {
        new import_obsidian2.Notice(i18n.t("REQUIRED_FIELDS"));
        return;
      }
      try {
        const newBook = await this.plugin.bookManager.createBook(
          this.bookInfo,
          this.selectedTemplate,
          this.targetTotalWords
        );
        new import_obsidian2.Notice(i18n.t("CREATE_SUCCESS"));
        if (this.onBookCreated) {
          this.onBookCreated(newBook);
        }
        this.close();
      } catch (error) {
        new import_obsidian2.Notice(i18n.t("CREATE_FAILED") + error.message);
      }
    }));
  }
  validateBookInfo() {
    var _a;
    return !!(this.bookInfo.title && ((_a = this.bookInfo.author) == null ? void 0 : _a.length));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/ManageBooksModal.ts
var import_obsidian6 = require("obsidian");

// src/modals/EditBookModal.ts
var import_obsidian3 = require("obsidian");
var EditBookModal = class extends import_obsidian3.Modal {
  constructor(app, book, bookManager, plugin, onSaved) {
    super(app);
    this.book = book;
    this.bookManager = bookManager;
    this.plugin = plugin;
    this.onSaved = onSaved;
    this.bookInfo = { ...book.basic };
    this.targetTotalWords = book.stats.target_total_words || 1e4;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("book-smith-edit-book-modal");
    contentEl.createEl("h2", { text: i18n.t("EDIT_BOOK_TITLE") });
    new import_obsidian3.Setting(contentEl).setName(i18n.t("COVER")).setDesc(i18n.t("COVER_DESC")).addButton((button) => button.setButtonText(this.bookInfo.cover ? i18n.t("CHANGE_COVER") : i18n.t("SELECT_COVER")).onClick(async () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async () => {
        var _a;
        const file = (_a = input.files) == null ? void 0 : _a[0];
        if (file) {
          try {
            const coversPath = `${this.plugin.settings.defaultBookPath}/covers`;
            if (!await this.app.vault.adapter.exists(coversPath)) {
              await this.app.vault.adapter.mkdir(coversPath);
            }
            const fileName = `cover-${Date.now()}.${file.name.split(".").pop()}`;
            const coverPath = `${coversPath}/${fileName}`;
            await this.app.vault.adapter.writeBinary(coverPath, await file.arrayBuffer());
            this.bookInfo.cover = coverPath;
            new import_obsidian3.Notice(i18n.t("COVER_UPDATE_SUCCESS"));
          } catch (error) {
            new import_obsidian3.Notice(i18n.t("COVER_UPDATE_FAILED") + error.message);
          }
        }
      };
      input.click();
    }));
    new import_obsidian3.Setting(contentEl).setName(i18n.t("BOOK_TITLE")).setDesc(i18n.t("BOOK_TITLE_DESC")).addText((text) => text.setValue(this.bookInfo.title || "").onChange((value) => this.bookInfo.title = value));
    new import_obsidian3.Setting(contentEl).setName(i18n.t("SUBTITLE")).setDesc(i18n.t("SUBTITLE_DESC")).addText((text) => text.setValue(this.bookInfo.subtitle || "").onChange((value) => this.bookInfo.subtitle = value));
    new import_obsidian3.Setting(contentEl).setName(i18n.t("TARGET_WORDS")).setDesc(i18n.t("TARGET_WORDS_DESC")).addText((text) => text.setPlaceholder(i18n.t("TARGET_WORDS_PLACEHOLDER")).setValue(`${Math.floor(this.targetTotalWords / 1e4)}\u4E07`).onChange((value) => {
      const match = value.match(/^(\d+(?:\.\d+)?)万?$/);
      if (match) {
        const num = parseFloat(match[1]) * 1e4;
        this.targetTotalWords = Math.round(num);
      } else {
        this.targetTotalWords = 1e4;
      }
    }));
    new import_obsidian3.Setting(contentEl).setName(i18n.t("AUTHOR")).setDesc(i18n.t("AUTHOR_DESC")).addText((text) => {
      var _a;
      return text.setValue(((_a = this.bookInfo.author) == null ? void 0 : _a.join(",")) || "").onChange((value) => this.bookInfo.author = value ? value.split(",") : []);
    });
    new import_obsidian3.Setting(contentEl).setName(i18n.t("DESCRIPTION")).setDesc(i18n.t("DESCRIPTION_DESC")).addTextArea((text) => text.setValue(this.bookInfo.desc || "").onChange((value) => this.bookInfo.desc = value));
    new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText(i18n.t("SAVE")).setCta().onClick(async () => {
      var _a;
      if (!this.validateBookInfo()) {
        new import_obsidian3.Notice(i18n.t("REQUIRED_FIELDS"));
        return;
      }
      try {
        await this.bookManager.updateBook(this.book.basic.uuid, {
          basic: this.bookInfo,
          stats: {
            ...this.book.stats,
            target_total_words: this.targetTotalWords
          }
        });
        new import_obsidian3.Notice(i18n.t("SAVE_SUCCESS"));
        this.close();
        (_a = this.onSaved) == null ? void 0 : _a.call(this, { type: "edited", bookId: this.book.basic.uuid });
      } catch (error) {
        new import_obsidian3.Notice(i18n.t("SAVE_FAILED") + error.message);
      }
    }));
  }
  validateBookInfo() {
    var _a;
    return !!(this.bookInfo.title && ((_a = this.bookInfo.author) == null ? void 0 : _a.length));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/ConfirmModal.ts
var import_obsidian4 = require("obsidian");
var ConfirmModal = class extends import_obsidian4.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.confirmed = false;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: i18n.t("CANCEL") }).addEventListener("click", () => this.close());
    const confirmButton = buttonContainer.createEl("button", {
      cls: "mod-cta",
      text: i18n.t("CONFIRM")
    });
    confirmButton.addEventListener("click", () => {
      this.confirmed = true;
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.confirmed) {
      this.onConfirm();
    }
  }
};

// src/modals/UnimportedBooksModal.ts
var import_obsidian5 = require("obsidian");
var UnimportedBooksModal = class extends import_obsidian5.Modal {
  constructor(app, folders, booksPath, onChoose) {
    super(app);
    this.folders = folders;
    this.booksPath = booksPath;
    this.onChoose = onChoose;
    this.result = null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("book-smith-unimported-books-modal");
    contentEl.createEl("h2", { text: i18n.t("UNIMPORTED_BOOKS_TITLE") });
    if (this.folders.length === 0) {
      contentEl.createEl("p", {
        cls: "book-smith-unimported-empty-message",
        text: i18n.t("NO_UNIMPORTED_FOLDERS")
      });
      const buttonContainer2 = contentEl.createEl("div", { cls: "book-smith-unimported-buttons" });
      const closeButton = buttonContainer2.createEl("button", {
        text: i18n.t("CLOSE"),
        cls: "book-smith-unimported-button-cancel"
      });
      closeButton.addEventListener("click", () => {
        this.close();
        this.onChoose(null);
      });
      return;
    }
    const searchContainer = contentEl.createEl("div", { cls: "book-smith-unimported-search-container" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: i18n.t("SEARCH_FOLDERS_PLACEHOLDER"),
      cls: "book-smith-unimported-search-input"
    });
    const listEl = contentEl.createEl("div", { cls: "book-smith-unimported-list" });
    const renderFolders = (folders) => {
      listEl.empty();
      if (folders.length === 0) {
        listEl.createEl("div", {
          cls: "book-smith-unimported-empty-result",
          text: i18n.t("NO_MATCHING_FOLDERS")
        });
        return;
      }
      for (const folder of folders) {
        const item = listEl.createEl("div", {
          cls: "book-smith-unimported-item"
        });
        const icon = item.createEl("span", { cls: "book-smith-unimported-folder-icon" });
        (0, import_obsidian5.setIcon)(icon, "folder");
        item.createEl("span", { text: folder, cls: "book-smith-unimported-folder-name" });
        item.addEventListener("click", () => {
          listEl.querySelectorAll(".selected").forEach(
            (el) => el.removeClass("selected")
          );
          item.addClass("selected");
          this.result = folder;
        });
      }
    };
    renderFolders(this.folders);
    searchInput.addEventListener("input", () => {
      const searchTerm = searchInput.value.toLowerCase();
      if (!searchTerm) {
        renderFolders(this.folders);
        return;
      }
      const filteredFolders = this.folders.filter(
        (folder) => folder.toLowerCase().includes(searchTerm)
      );
      renderFolders(filteredFolders);
    });
    const buttonContainer = contentEl.createEl("div", { cls: "book-smith-unimported-buttons" });
    const cancelButton = buttonContainer.createEl("button", {
      text: i18n.t("CANCEL"),
      cls: "book-smith-unimported-button-cancel"
    });
    const importButton = buttonContainer.createEl("button", {
      text: i18n.t("IMPORT"),
      cls: "book-smith-unimported-button-import"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
      this.onChoose(null);
    });
    importButton.addEventListener("click", () => {
      if (!this.result) {
        const notice = contentEl.createEl("div", {
          cls: "book-smith-unimported-notice",
          text: i18n.t("SELECT_FOLDER_FIRST")
        });
        setTimeout(() => {
          notice.remove();
        }, 2e3);
        return;
      }
      this.close();
      this.onChoose(this.result);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/ManageBooksModal.ts
var ManageBooksModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, onBookChange) {
    super(app);
    this.plugin = plugin;
    this.onBookChange = onBookChange;
    this.books = [];
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("book-smith-manage-books-modal");
    contentEl.createEl("h2", { text: i18n.t("MANAGE_BOOKS_TITLE") });
    const topContainer = contentEl.createDiv({ cls: "book-smith-manage-top-container" });
    const searchContainer = topContainer.createDiv({ cls: "book-smith-manage-search-container" });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: i18n.t("SEARCH_BOOKS_PLACEHOLDER"),
      cls: "book-smith-manage-search-input"
    });
    const importButton = topContainer.createEl("button", {
      text: i18n.t("IMPORT_BOOK"),
      cls: "book-smith-import-button"
    });
    importButton.addEventListener("click", () => {
      this.importBook();
    });
    contentEl.createDiv({ cls: "book-smith-manage-divider" });
    this.bookList = contentEl.createDiv({ cls: "book-smith-manage-book-list" });
    this.books = await this.plugin.bookManager.getAllBooks();
    this.renderBooks(this.books);
  }
  renderBooks(books) {
    this.bookList.empty();
    for (const book of books) {
      const bookContainer = this.bookList.createDiv({ cls: "book-smith-book-container" });
      const coverContainer = bookContainer.createDiv({ cls: "book-smith-book-cover" });
      if (book.basic.cover) {
        coverContainer.createEl("img", {
          attr: {
            src: this.app.vault.adapter.getResourcePath(book.basic.cover),
            alt: book.basic.title
          }
        });
      }
      const setting = new import_obsidian6.Setting(bookContainer).setName(createFragment((el) => {
        el.createEl("span", { text: `\u300A${book.basic.title}\u300B` });
        if (book.basic.subtitle) {
          el.createEl("span", {
            text: book.basic.subtitle,
            cls: "subtitle"
          });
        }
      })).setDesc(
        `${i18n.t("BOOK_AUTHOR_PREFIX")}${book.basic.author.join("\u3001")}
                    ${book.basic.desc ? `${i18n.t("BOOK_DESC_PREFIX")}${book.basic.desc}` : ""}
                    ${i18n.t("BOOK_PROGRESS_PREFIX")}${book.stats.total_words}${book.stats.target_total_words ? ` / ${(book.stats.target_total_words / 1e4).toFixed(1)}\u4E07` : " / 0\u4E07"}`
      );
      setting.addButton((btn) => btn.setButtonText(i18n.t("DELETE_BOOK")).setWarning().onClick(() => {
        new ConfirmModal(
          this.app,
          i18n.t("DELETE_BOOK_TITLE"),
          i18n.t("DELETE_BOOK_DESC", { title: book.basic.title }),
          async () => {
            var _a;
            try {
              await this.plugin.bookManager.deleteBook(book.basic.uuid);
              new import_obsidian6.Notice(i18n.t("DELETE_SUCCESS"));
              (_a = this.onBookChange) == null ? void 0 : _a.call(this, { type: "deleted", bookId: book.basic.uuid });
              this.onOpen();
            } catch (error) {
              new import_obsidian6.Notice(i18n.t("DELETE_FAILED") + error.message);
            }
          }
        ).open();
      })).addButton((btn) => btn.setButtonText(i18n.t("EDIT_BOOK")).onClick(() => {
        new EditBookModal(
          this.app,
          book,
          this.plugin.bookManager,
          this.plugin,
          () => {
            var _a;
            this.onOpen();
            (_a = this.onBookChange) == null ? void 0 : _a.call(this, { type: "edited", bookId: book.basic.uuid });
          }
        ).open();
      }));
    }
  }
  // 导入书籍方法
  async importBook() {
    try {
      const booksPath = this.plugin.settings.defaultBookPath;
      const rootFolder = this.app.vault.getAbstractFileByPath(booksPath);
      if (!(rootFolder instanceof import_obsidian6.TFolder)) {
        new import_obsidian6.Notice(i18n.t("BOOKS_ROOT_NOT_FOUND"));
        return;
      }
      const unimportedBooks = [];
      for (const child of rootFolder.children) {
        if (child instanceof import_obsidian6.TFolder && child.name !== "covers") {
          const configPath = `${child.path}/book-config.json`;
          const configFile = this.app.vault.getAbstractFileByPath(configPath);
          if (!configFile) {
            unimportedBooks.push(child.name);
          }
        }
      }
      if (unimportedBooks.length === 0) {
        new import_obsidian6.Notice(i18n.t("NO_UNIMPORTED_BOOKS"));
        return;
      }
      new UnimportedBooksModal(
        this.app,
        unimportedBooks,
        this.plugin.settings.defaultBookPath,
        async (selectedFolder) => {
          if (selectedFolder) {
            await this.createBookConfig(selectedFolder);
          }
        }
      ).open();
    } catch (error) {
      new import_obsidian6.Notice(i18n.t("DETECT_UNIMPORTED_FAILED") + error.message);
    }
  }
  // 创建书籍配置文件
  // 重构后的 createBookConfig 方法
  async createBookConfig(folderName) {
    var _a;
    try {
      const newBook = await this.plugin.bookManager.importBookFromFolder(folderName);
      this.books = await this.plugin.bookManager.getAllBooks();
      this.renderBooks(this.books);
      (_a = this.onBookChange) == null ? void 0 : _a.call(this, {
        type: "imported",
        bookId: newBook.basic.uuid
      });
      new import_obsidian6.Notice(i18n.t("IMPORT_SUCCESS", { title: newBook.basic.title }));
    } catch (error) {
      new import_obsidian6.Notice(i18n.t("IMPORT_FAILED") + error.message);
    }
  }
};

// src/modals/SwitchBookModal.ts
var import_obsidian7 = require("obsidian");
var SwitchBookModal = class extends import_obsidian7.Modal {
  constructor(app, books, onSelect) {
    super(app);
    this.books = books;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("book-smith-switch-book-modal");
    contentEl.createEl("h2", { text: i18n.t("SWITCH_BOOK_TITLE") });
    const searchContainer = contentEl.createDiv({ cls: "book-smith-search-container" });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: i18n.t("SEARCH_BOOK_PLACEHOLDER"),
      cls: "book-smith-search-input"
    });
    this.searchInput.addEventListener("input", () => {
      this.renderBooks(this.filterBooks(this.books));
    });
    contentEl.createDiv({ cls: "book-smith-switch-book-divider" });
    this.bookList = contentEl.createDiv({ cls: "book-smith-book-list" });
    this.renderBooks(this.books);
  }
  filterBooks(books) {
    const searchTerm = this.searchInput.value.toLowerCase();
    if (!searchTerm)
      return books;
    return books.filter(
      (book) => {
        var _a, _b;
        return book.basic.title.toLowerCase().includes(searchTerm) || ((_a = book.basic.subtitle) == null ? void 0 : _a.toLowerCase().includes(searchTerm)) || book.basic.author.some((author) => author.toLowerCase().includes(searchTerm)) || ((_b = book.basic.desc) == null ? void 0 : _b.toLowerCase().includes(searchTerm));
      }
    );
  }
  renderBooks(books) {
    this.bookList.empty();
    for (const book of books) {
      new import_obsidian7.Setting(this.bookList).setName(`\u300A${book.basic.title}\u300B${book.basic.subtitle ? ` - ${book.basic.subtitle}` : ""}`).setDesc(
        `${i18n.t("BOOK_AUTHOR_LABEL")}\uFF1A${book.basic.author.join("\u3001")}
                    
 | ${i18n.t("BOOK_PROGRESS_LABEL")}\uFF1A${Math.round(book.stats.progress_by_chapter * 100)}% | ${i18n.t("BOOK_WORDCOUNT_LABEL")}\uFF1A${(book.stats.target_total_words / 1e4).toFixed(1)}\u4E07
                    
 | ${i18n.t("BOOK_LASTMOD_LABEL")}\uFF1A${new Date(book.stats.last_modified).toLocaleString()}`
      ).addButton((btn) => btn.setButtonText(i18n.t("SELECT_BOOK")).setCta().onClick(() => {
        this.onSelect(book);
        this.close();
      }));
    }
  }
};

// src/components/ChapterTree.ts
var import_obsidian9 = require("obsidian");

// src/modals/NamePromptModal.ts
var import_obsidian8 = require("obsidian");
var NamePromptModal = class extends import_obsidian8.Modal {
  constructor(app, placeholder, onSubmit, defaultValue) {
    super(app);
    this.placeholder = placeholder;
    this.defaultValue = defaultValue;
    this.onSubmit = onSubmit;
    this.result = defaultValue || "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.placeholder });
    new import_obsidian8.Setting(contentEl).setName(i18n.t("NAME_LABEL")).addText((text) => {
      text.setValue(this.defaultValue || "").onChange((value) => {
        this.result = value;
      });
      setTimeout(() => {
        const input = text.inputEl;
        input.focus();
        input.select();
      }, 50);
    });
    new import_obsidian8.Setting(contentEl).addButton((btn) => btn.setButtonText(i18n.t("CONFIRM")).setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    })).addButton((btn) => btn.setButtonText(i18n.t("CANCEL")).onClick(() => {
      this.close();
      this.onSubmit(null);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/ChapterTree.ts
var ChapterTree = class {
  constructor(container, app, bookPath, bookManager, onDragComplete) {
    this.container = container;
    this.app = app;
    this.bookPath = bookPath;
    this.bookManager = bookManager;
    this.onDragComplete = onDragComplete;
    // === 属性 ===
    this.draggedNode = null;
  }
  // === 核心渲染方法 ===
  render(book) {
    this.book = { ...book };
    this.container.addEventListener("contextmenu", (e) => {
      if (e.target === this.container) {
        const menu = new import_obsidian9.Menu();
        menu.addItem((item) => {
          item.setTitle(i18n.t("NEW_FILE"));
          item.setIcon("file-plus");
          item.onClick(() => this.createNode("file"));
        });
        menu.addItem((item) => {
          item.setTitle(i18n.t("NEW_FOLDER"));
          item.setIcon("folder-plus");
          item.onClick(() => this.createNode("group"));
        });
        menu.showAtPosition({ x: e.clientX, y: e.clientY });
      }
    });
    const list = this.container.createEl("ul", { cls: "book-smith-tree-list" });
    this.book.structure.tree.forEach((node) => this.renderNode(list, node));
  }
  // 在类的开头添加一个工具方法
  updateNodesOrder(nodes, startOrder = 1) {
    let currentOrder = startOrder;
    nodes.forEach((node) => {
      var _a;
      node.order = currentOrder++;
      if (node.type === "group" && ((_a = node.children) == null ? void 0 : _a.length)) {
        currentOrder = this.updateNodesOrder(node.children, currentOrder);
      }
    });
    return currentOrder;
  }
  renderNode(parent, node) {
    var _a;
    const item = parent.createEl("li", { cls: "book-smith-tree-item" });
    const header = item.createDiv({ cls: "book-smith-tree-header" });
    if (node.type === "group" && ((_a = node.children) == null ? void 0 : _a.length)) {
      this.setupFolderBehavior(header, item, node);
    }
    this.setupNodeIcon(header, node);
    this.setupNodeTitle(header, node);
    this.setupDragAndDrop(header, item, node);
    this.setupContextMenu(header, node);
    if (node.type === "group" && node.children) {
      this.renderChildren(item, node.children, node);
    }
  }
  renderChildren(item, children, parentNode) {
    const childContainer = item.createDiv({
      cls: "book-smith-tree-children"
    });
    if (parentNode.is_expanded) {
      childContainer.addClass("is-expanded");
    }
    children.forEach((child) => this.renderNode(childContainer, child));
  }
  // === 节点基础设置 ===
  setupNodeIcon(header, node) {
    const icon = header.createSpan({ cls: "book-smith-tree-icon" });
    (0, import_obsidian9.setIcon)(icon, node.type === "file" ? "document" : "folder");
  }
  // 添加检查文件夹状态的方法
  isFolderComplete(node) {
    var _a;
    if (node.type === "file") {
      return node.default_status === "done";
    }
    if (!((_a = node.children) == null ? void 0 : _a.length)) {
      return false;
    }
    return node.children.every((child) => this.isFolderComplete(child));
  }
  // 添加检查文件夹是否所有内容都排除的方法
  isFolderExcluded(node) {
    var _a;
    if (node.type === "file") {
      return !!node.exclude;
    }
    if (!((_a = node.children) == null ? void 0 : _a.length)) {
      return false;
    }
    return node.children.every((child) => this.isFolderExcluded(child));
  }
  setupNodeTitle(header, node) {
    const titleSpan = header.createSpan({
      text: node.title,
      cls: "book-smith-tree-title"
    });
    if (node.type === "file") {
      titleSpan.addClass("book-smith-file-link");
      header.addEventListener("click", async () => {
        const filePath = `${this.bookPath}/${node.path}`;
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian9.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
      });
    }
    if (node.type === "file" && node.exclude || node.type === "group" && this.isFolderExcluded(node)) {
      titleSpan.addClass("exclude-from-stats");
    }
    if (node.type === "file" && node.default_status === "done" || node.type === "group" && this.isFolderComplete(node)) {
      titleSpan.addClass("is-done");
    }
  }
  setupFolderBehavior(header, item, node) {
    var _a;
    const toggleBtn = header.createSpan({ cls: "book-smith-tree-toggle" });
    (0, import_obsidian9.setIcon)(toggleBtn, node.is_expanded ? "chevron-down" : "chevron-right");
    if (node.is_expanded) {
      toggleBtn.addClass("is-expanded");
      (_a = item.querySelector(".book-smith-tree-children")) == null ? void 0 : _a.addClass("is-expanded");
    }
    const toggleFolder = async () => {
      const childContainer = item.querySelector(".book-smith-tree-children");
      if (childContainer) {
        const isExpanded = toggleBtn.hasClass("is-expanded");
        toggleBtn.toggleClass("is-expanded", !isExpanded);
        childContainer.toggleClass("is-expanded", !isExpanded);
        (0, import_obsidian9.setIcon)(toggleBtn, isExpanded ? "chevron-right" : "chevron-down");
        node.is_expanded = !isExpanded;
        await this.bookManager.updateBook(this.book.basic.uuid, {
          structure: this.book.structure
        });
      }
    };
    header.addEventListener("click", (e) => {
      if (!e.target.closest(".book-smith-file-link")) {
        toggleFolder();
      }
    });
  }
  // === 右键菜单相关 ===
  calculateChapterProgress(nodes) {
    let totalChapters = 0;
    let completedChapters = 0;
    const countChapters = (nodeList) => {
      for (const node of nodeList) {
        if (node.type === "file") {
          totalChapters++;
          if (node.default_status === "done") {
            completedChapters++;
          }
        }
        if (node.children) {
          countChapters(node.children);
        }
      }
    };
    countChapters(nodes);
    return totalChapters > 0 ? completedChapters / totalChapters : 0;
  }
  setupContextMenu(header, node) {
    header.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      const filePath = `${this.bookPath}/${node.path}`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        const menu = new import_obsidian9.Menu();
        if (node.type === "group") {
          menu.addItem((item) => {
            item.setTitle(i18n.t("NEW_FILE"));
            item.setIcon("file-plus");
            item.onClick(() => {
              this.createNode("file", node.path, node);
            });
          });
          menu.addItem((item) => {
            item.setTitle(i18n.t("NEW_FOLDER"));
            item.setIcon("folder-plus");
            item.onClick(() => {
              this.createNode("group", node.path, node);
            });
          });
          menu.addSeparator();
        }
        if (node.type === "file") {
          menu.addItem((item) => {
            item.setTitle(i18n.t("OPEN_IN_NEW_TAB"));
            item.setIcon("file-plus");
            item.onClick(() => {
              if (file instanceof import_obsidian9.TFile) {
                this.app.workspace.getLeaf("tab").openFile(file);
              }
            });
          });
          menu.addItem((item) => {
            item.setTitle(i18n.t("OPEN_IN_NEW_PANE"));
            item.setIcon("files");
            item.onClick(() => {
              if (file instanceof import_obsidian9.TFile) {
                this.app.workspace.getLeaf("split").openFile(file);
              }
            });
          });
          menu.addSeparator();
          if (!node.exclude) {
            menu.addItem((item) => {
              item.setTitle(node.default_status === "done" ? i18n.t("MARK_AS_DRAFT") : i18n.t("MARK_AS_COMPLETE"));
              item.setIcon(node.default_status === "done" ? "x-circle" : "check-circle");
              item.onClick(async () => {
                var _a;
                node.default_status = node.default_status === "done" ? "draft" : "done";
                const progress = this.calculateChapterProgress(this.book.structure.tree);
                await this.bookManager.updateBook(this.book.basic.uuid, {
                  structure: this.book.structure,
                  stats: {
                    ...this.book.stats,
                    progress_by_chapter: progress
                  }
                });
                await ((_a = this.onDragComplete) == null ? void 0 : _a.call(this));
              });
            });
          }
          menu.addItem((item) => {
            item.setTitle(node.exclude ? i18n.t("INCLUDE_IN_STATS") : i18n.t("EXCLUDE_FROM_STATS"));
            item.setIcon(node.exclude ? "plus-circle" : "minus-circle");
            item.onClick(async () => {
              var _a, _b, _c;
              node.exclude = !node.exclude;
              node.default_status = "draft";
              if (node.type === "group" && node.exclude && ((_a = node.children) == null ? void 0 : _a.length)) {
                this.recursiveExclude(node.children, true);
              }
              if (node.type === "group" && !node.exclude && ((_b = node.children) == null ? void 0 : _b.length)) {
                this.recursiveExclude(node.children, false);
              }
              this.updateParentExcludeStatus(node);
              const progress = this.calculateChapterProgress(this.book.structure.tree);
              await this.bookManager.updateBook(this.book.basic.uuid, {
                structure: this.book.structure,
                stats: {
                  ...this.book.stats,
                  progress_by_chapter: progress
                }
              });
              await ((_c = this.onDragComplete) == null ? void 0 : _c.call(this));
              new import_obsidian9.Notice(node.exclude ? i18n.t("EXCLUDED_NOTICE", { title: node.title }) : i18n.t("INCLUDED_NOTICE", { title: node.title }));
            });
          });
          menu.addSeparator();
        }
        menu.addItem((item) => {
          item.setTitle(i18n.t("CREATE_COPY"));
          item.setIcon("copy");
          item.onClick(async () => {
            var _a, _b;
            try {
              const parentPath = node.path.substring(0, node.path.lastIndexOf("/"));
              const baseName = node.title;
              const newName = i18n.t("COPY_NAME", { name: baseName });
              const newPath = parentPath ? `${this.bookPath}/${parentPath}/${newName}${node.type === "file" ? ".md" : ""}` : `${this.bookPath}/${newName}${node.type === "file" ? ".md" : ""}`;
              if (node.type === "file" && file instanceof import_obsidian9.TFile) {
                const content = await this.app.vault.read(file);
                await this.app.vault.create(newPath, content);
              } else {
                await this.app.vault.createFolder(newPath);
                if ((_a = node.children) == null ? void 0 : _a.length) {
                  await this.copyFolderContents(node.children, newPath, `${this.bookPath}/${node.path}`);
                }
              }
              const newNode = {
                id: crypto.randomUUID(),
                title: newName,
                type: node.type,
                path: parentPath ? `${parentPath}/${newName}${node.type === "file" ? ".md" : ""}` : `${newName}${node.type === "file" ? ".md" : ""}`,
                order: this.book.structure.tree.length + 1,
                default_status: node.default_status,
                created_at: new Date().toISOString(),
                last_modified: new Date().toISOString(),
                ...node.type === "group" ? {
                  children: node.children ? this.cloneNodes(node.children, newName, parentPath) : []
                } : {}
              };
              this.insertNodeAfter(node, newNode);
              await this.bookManager.updateBook(this.book.basic.uuid, {
                structure: this.book.structure
              });
              await ((_b = this.onDragComplete) == null ? void 0 : _b.call(this));
              new import_obsidian9.Notice(i18n.t("COPY_SUCCESS"));
            } catch (error) {
              new import_obsidian9.Notice(i18n.t("COPY_FAILED", { error: error.message }));
            }
          });
        });
        menu.addItem((item) => {
          item.setTitle(i18n.t("RENAME"));
          item.setIcon("pencil");
          item.onClick(async () => {
            var _a;
            const currentName = node.type === "file" ? node.title.replace(/\.md$/, "") : node.title;
            const newName = await this.promptForName(i18n.t("ENTER_NEW_NAME"), currentName);
            if (!newName)
              return;
            try {
              const parentPath = node.path.substring(0, node.path.lastIndexOf("/"));
              const newPath = parentPath ? `${this.bookPath}/${parentPath}/${newName}${node.type === "file" ? ".md" : ""}` : `${this.bookPath}/${newName}${node.type === "file" ? ".md" : ""}`;
              await this.app.vault.rename(file, newPath);
              node.title = newName;
              node.path = parentPath ? `${parentPath}/${newName}${node.type === "file" ? ".md" : ""}` : `${newName}${node.type === "file" ? ".md" : ""}`;
              if (node.type === "group" && node.children) {
                this.updateChildrenPaths(node.children, parentPath ? `${parentPath}/${newName}` : newName);
              }
              await this.bookManager.updateBook(this.book.basic.uuid, {
                structure: this.book.structure
              });
              await ((_a = this.onDragComplete) == null ? void 0 : _a.call(this));
              new import_obsidian9.Notice(i18n.t("RENAME_SUCCESS"));
            } catch (error) {
              new import_obsidian9.Notice(i18n.t("RENAME_FAILED", { error: error.message }));
            }
          });
        });
        menu.addItem((item) => {
          item.setTitle(i18n.t("DELETE"));
          item.setIcon("trash");
          item.onClick(() => {
            const title = node.type === "file" ? i18n.t("DELETE_FILE_TITLE") : i18n.t("DELETE_FOLDER_TITLE");
            const message = node.type === "file" ? i18n.t("DELETE_FILE_DESC", { title: node.title }) : i18n.t("DELETE_FOLDER_DESC", { title: node.title });
            new ConfirmModal(this.app, title, message, async () => {
              var _a;
              try {
                await this.app.vault.trash(file, true);
                this.removeNodeFromTree(node);
                await this.bookManager.updateBook(this.book.basic.uuid, {
                  structure: this.book.structure
                });
                await ((_a = this.onDragComplete) == null ? void 0 : _a.call(this));
                new import_obsidian9.Notice(i18n.t("DELETE_SUCCESS"));
              } catch (error) {
                new import_obsidian9.Notice(i18n.t("DELETE_FAILED", { error: error.message }));
              }
            }).open();
          });
        });
        menu.addSeparator();
        menu.showAtPosition({ x: e.clientX, y: e.clientY });
      }
    });
  }
  // 添加一个新方法来更新父目录的排除状态
  updateParentExcludeStatus(node) {
    var _a;
    const findParentNode = (searchNode, nodes) => {
      var _a2, _b;
      for (const n of nodes) {
        if ((_a2 = n.children) == null ? void 0 : _a2.some((child) => child.id === searchNode.id)) {
          return n;
        }
        if ((_b = n.children) == null ? void 0 : _b.length) {
          const parent2 = findParentNode(searchNode, n.children);
          if (parent2)
            return parent2;
        }
      }
      return null;
    };
    const parent = findParentNode(node, this.book.structure.tree);
    if (parent && parent.type === "group") {
      const allExcluded = (_a = parent.children) == null ? void 0 : _a.every(
        (child) => child.exclude || child.type === "group" && this.isFolderExcluded(child)
      );
      if (allExcluded !== parent.exclude) {
        parent.exclude = allExcluded;
        this.updateParentExcludeStatus(parent);
      }
    }
  }
  // 添加递归排除/包含子节点的方法
  recursiveExclude(nodes, exclude) {
    var _a;
    for (const node of nodes) {
      node.exclude = exclude;
      if (node.type === "group" && ((_a = node.children) == null ? void 0 : _a.length)) {
        this.recursiveExclude(node.children, exclude);
      }
    }
  }
  // === 拖拽相关 ===
  setupDragAndDrop(header, item, node) {
    header.setAttribute("draggable", "true");
    let dropPosition = "inside";
    header.addEventListener("dragstart", (e) => {
      var _a;
      this.draggedNode = node;
      item.addClass("book-smith-dragging");
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", node.id);
    });
    header.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (!this.draggedNode || this.draggedNode === node)
        return;
      if (this.isDescendant(node, this.draggedNode))
        return;
      const rect = header.getBoundingClientRect();
      const mouseY = e.clientY;
      const threshold = rect.height / 4;
      header.classList.remove(
        "book-smith-dragover-before",
        "book-smith-dragover-after",
        "book-smith-dragover-inside"
      );
      if (mouseY < rect.top + threshold) {
        dropPosition = "before";
        header.addClass("book-smith-dragover-before");
      } else if (mouseY > rect.bottom - threshold) {
        dropPosition = "after";
        header.addClass("book-smith-dragover-after");
      } else if (node.type === "group") {
        dropPosition = "inside";
        header.addClass("book-smith-dragover-inside");
      } else {
        dropPosition = "after";
        header.addClass("book-smith-dragover-after");
      }
    });
    header.addEventListener("dragleave", () => {
      header.classList.remove(
        "book-smith-dragover-before",
        "book-smith-dragover-after",
        "book-smith-dragover-inside"
      );
    });
    header.addEventListener("drop", async (e) => {
      e.preventDefault();
      header.classList.remove(
        "book-smith-dragover-before",
        "book-smith-dragover-after",
        "book-smith-dragover-inside"
      );
      if (this.draggedNode && this.draggedNode !== node && !this.isDescendant(node, this.draggedNode)) {
        await this.handleNodeMove(node, dropPosition);
      }
    });
    header.addEventListener("dragend", () => {
      item.removeClass("book-smith-dragging");
      document.querySelectorAll(".book-smith-dragover-before, .book-smith-dragover-after, .book-smith-dragover-inside").forEach((el) => {
        el.classList.remove(
          "book-smith-dragover-before",
          "book-smith-dragover-after",
          "book-smith-dragover-inside"
        );
      });
    });
  }
  isDescendant(parent, child) {
    if (parent.type !== "group" || !parent.children)
      return false;
    return parent.children.some(
      (node) => node === child || this.isDescendant(node, child)
    );
  }
  async handleNodeMove(targetNode, position) {
    var _a;
    if (!this.draggedNode)
      return;
    const movingNode = this.draggedNode;
    try {
      const sourcePath = `${this.bookPath}/${this.draggedNode.path}`;
      let targetPath;
      const fileName = this.draggedNode.type === "file" ? this.draggedNode.path.endsWith(".md") ? `${this.draggedNode.title}.md` : this.draggedNode.title : this.draggedNode.title;
      if (position === "inside" && targetNode.type === "group") {
        targetPath = `${this.bookPath}/${targetNode.path}/${fileName}`;
      } else {
        const targetParentPath = targetNode.path.substring(0, targetNode.path.lastIndexOf("/"));
        targetPath = targetParentPath ? `${this.bookPath}/${targetParentPath}/${fileName}` : `${this.bookPath}/${fileName}`;
      }
      const sourceFile = this.app.vault.getAbstractFileByPath(sourcePath);
      if (!sourceFile) {
        throw new Error(i18n.t("SOURCE_NOT_FOUND"));
      }
      const existingFile = this.app.vault.getAbstractFileByPath(targetPath);
      if (existingFile && existingFile !== sourceFile) {
        throw new Error(i18n.t("TARGET_EXISTS"));
      }
      if (position === "inside") {
        const targetFolder = this.app.vault.getAbstractFileByPath(`${this.bookPath}/${targetNode.path}`);
        if (!targetFolder) {
          throw new Error(i18n.t("TARGET_FOLDER_NOT_FOUND"));
        }
      }
      await this.app.vault.rename(sourceFile, targetPath);
      this.updateTreeStructure(targetNode, targetPath, position, movingNode);
      await this.bookManager.updateBook(this.book.basic.uuid, {
        structure: this.book.structure
      });
      await ((_a = this.onDragComplete) == null ? void 0 : _a.call(this));
    } catch (error) {
      console.error("\u79FB\u52A8\u5931\u8D25:", error);
      new import_obsidian9.Notice(i18n.t("MOVE_FAILED"));
    } finally {
      this.draggedNode = null;
    }
  }
  updateTreeStructure(targetNode, targetPath, position, draggedNode) {
    const removeNode = (nodes) => {
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i] === draggedNode) {
          return nodes.splice(i, 1)[0];
        }
        if (nodes[i].type === "group" && nodes[i].children) {
          const children = nodes[i].children;
          const found = removeNode(children);
          if (found)
            return found;
        }
      }
      return null;
    };
    const insertNode = (nodes, position2) => {
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i] === targetNode) {
          if (position2 === "inside" && nodes[i].type === "group") {
            if (!nodes[i].children) {
              nodes[i].children = [];
            }
            const children = nodes[i].children;
            children.push(draggedNode);
          } else {
            const insertIndex = position2 === "before" ? i : i + 1;
            nodes.splice(insertIndex, 0, draggedNode);
          }
          return true;
        }
        if (nodes[i].type === "group" && nodes[i].children) {
          const children = nodes[i].children;
          if (insertNode(children, position2)) {
            return true;
          }
        }
      }
      return false;
    };
    removeNode(this.book.structure.tree);
    const relativePath = targetPath.substring(this.bookPath.length + 1);
    draggedNode.path = relativePath;
    draggedNode.last_modified = new Date().toISOString();
    insertNode(this.book.structure.tree, position);
    this.updateNodesOrder(this.book.structure.tree);
  }
  // === 节点操作相关 ===
  async createNode(type, parentPath = "", parentNode) {
    var _a;
    const isFile = type === "file";
    const name = await this.promptForName(
      isFile ? i18n.t("ENTER_FILE_NAME") : i18n.t("ENTER_FOLDER_NAME")
    );
    if (!name)
      return;
    const newPath = parentPath ? `${this.bookPath}/${parentPath}/${name}${isFile ? ".md" : ""}` : `${this.bookPath}/${name}${isFile ? ".md" : ""}`;
    try {
      if (isFile) {
        await this.app.vault.create(newPath, "");
      } else {
        await this.app.vault.createFolder(newPath);
      }
      const newNode = {
        order: 0,
        // 临时值，将在插入后更新
        id: crypto.randomUUID(),
        title: name,
        type,
        path: parentPath ? `${parentPath}/${name}${isFile ? ".md" : ""}` : `${name}${isFile ? ".md" : ""}`,
        default_status: "draft",
        created_at: new Date().toISOString(),
        last_modified: new Date().toISOString(),
        ...type === "group" ? { children: [] } : {}
      };
      if (parentNode) {
        parentNode.children = parentNode.children || [];
        parentNode.children.push(newNode);
        this.updateNodesOrder(parentNode.children);
      } else {
        this.book.structure.tree.push(newNode);
        this.updateNodesOrder(this.book.structure.tree);
      }
      await this.bookManager.updateBook(this.book.basic.uuid, {
        structure: this.book.structure
      });
      await ((_a = this.onDragComplete) == null ? void 0 : _a.call(this));
    } catch (error) {
      new import_obsidian9.Notice(`\u521B\u5EFA${isFile ? "\u6587\u4EF6" : "\u6587\u4EF6\u5939"}\u5931\u8D25: ${error.message}`);
    }
  }
  // === 辅助方法 ===
  insertNodeAfter(referenceNode, newNode) {
    const insertInArray = (nodes) => {
      const index = nodes.findIndex((node) => node === referenceNode);
      if (index !== -1) {
        nodes.splice(index + 1, 0, newNode);
        return true;
      }
      for (const node of nodes) {
        if (node.type === "group" && node.children) {
          if (insertInArray(node.children)) {
            return true;
          }
        }
      }
      return false;
    };
    insertInArray(this.book.structure.tree);
  }
  async copyFolderContents(nodes, newFolderPath, sourceFolderPath) {
    var _a;
    for (const node of nodes) {
      const sourceFilePath = `${sourceFolderPath}/${node.title}${node.type === "file" ? ".md" : ""}`;
      const targetFilePath = `${newFolderPath}/${node.title}${node.type === "file" ? ".md" : ""}`;
      if (node.type === "file") {
        const sourceFile = this.app.vault.getAbstractFileByPath(sourceFilePath);
        if (sourceFile instanceof import_obsidian9.TFile) {
          const content = await this.app.vault.read(sourceFile);
          await this.app.vault.create(targetFilePath, content);
        }
      } else {
        await this.app.vault.createFolder(targetFilePath);
        if ((_a = node.children) == null ? void 0 : _a.length) {
          await this.copyFolderContents(node.children, targetFilePath, sourceFilePath);
        }
      }
    }
  }
  cloneNodes(nodes, newParentName, parentPath) {
    return nodes.map((node) => {
      const newPath = parentPath ? `${parentPath}/${newParentName}/${node.title}${node.type === "file" ? ".md" : ""}` : `${newParentName}/${node.title}${node.type === "file" ? ".md" : ""}`;
      return {
        id: crypto.randomUUID(),
        title: node.title,
        type: node.type,
        path: newPath,
        order: 0,
        // 临时值，将在插入后更新
        default_status: node.default_status,
        created_at: new Date().toISOString(),
        last_modified: new Date().toISOString(),
        ...node.type === "group" ? {
          children: node.children ? this.cloneNodes(node.children, node.title, newPath.replace(/\/[^/]+$/, "")) : []
        } : {}
      };
    });
  }
  updateChildrenPaths(children, newParentPath) {
    children.forEach((child) => {
      const childName = child.path.split("/").pop();
      child.path = `${newParentPath}/${childName}`;
      if (child.type === "group" && child.children) {
        this.updateChildrenPaths(child.children, child.path);
      }
    });
  }
  removeNodeFromTree(nodeToRemove) {
    const removeFromArray = (nodes) => {
      const index = nodes.findIndex((node) => node === nodeToRemove);
      if (index !== -1) {
        nodes.splice(index, 1);
        return true;
      }
      for (const node of nodes) {
        if (node.type === "group" && node.children) {
          if (removeFromArray(node.children)) {
            return true;
          }
        }
      }
      return false;
    };
    removeFromArray(this.book.structure.tree);
  }
  async promptForName(placeholder, defaultValue) {
    return new Promise((resolve) => {
      const modal = new NamePromptModal(this.app, placeholder, (result) => {
        resolve(result);
      }, defaultValue);
      modal.open();
    });
  }
};

// src/services/FileEventManager.ts
var import_obsidian10 = require("obsidian");
var FileEventManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async handleBookModify(file, currentBook, oldPath) {
    const bookPath = `${this.plugin.settings.defaultBookPath}/${currentBook.basic.title}`;
    if (file.path.startsWith(bookPath)) {
      const updateNode = (nodes) => {
        for (const node of nodes) {
          if (node.type === "file" && file instanceof import_obsidian10.TFile) {
            const nodePath = `${bookPath}/${node.path}`;
            if (oldPath && nodePath === oldPath || nodePath === file.path) {
              node.title = file.basename;
              node.path = file.path.replace(bookPath + "/", "");
              node.last_modified = new Date().toISOString();
              return true;
            }
          }
          if (node.type === "group" && node.children) {
            const oldNodePath = `${bookPath}/${node.path}`;
            if (oldPath && oldNodePath === oldPath || oldNodePath === file.path) {
              node.path = file.path.replace(bookPath + "/", "");
              node.title = file instanceof import_obsidian10.TFile ? file.basename : file.name;
              node.last_modified = new Date().toISOString();
              return true;
            }
            if (updateNode(node.children))
              return true;
          }
        }
        return false;
      };
      if (updateNode(currentBook.structure.tree)) {
        await this.plugin.bookManager.updateBook(currentBook.basic.uuid, currentBook);
        await this.plugin.statsManager.updateStatsForFile();
        return currentBook;
      }
    }
    return null;
  }
};

// src/services/ReferenceManager.ts
var import_obsidian12 = require("obsidian");

// src/modals/ReferenceModal.ts
var import_obsidian11 = require("obsidian");
var ReferenceModal = class extends import_obsidian11.Modal {
  constructor(app, onSubmit, defaultContent) {
    super(app);
    this.defaultContent = defaultContent;
    this.onSubmit = onSubmit;
    this.result = defaultContent || "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: i18n.t("REFERENCE_MODAL_TITLE") });
    new import_obsidian11.Setting(contentEl).setName(i18n.t("REFERENCE_CONTENT")).setDesc(i18n.t("REFERENCE_CONTENT_DESC")).addTextArea((text) => {
      text.setValue(this.result).onChange((value) => {
        this.result = value;
      });
    });
    new import_obsidian11.Setting(contentEl).addButton((btn) => btn.setButtonText(i18n.t("CONFIRM")).setCta().onClick(() => {
      this.onSubmit(this.result);
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/services/ReferenceManager.ts
var ReferenceManager = class {
  // === 1. 初始化 ===
  constructor(app, plugin, getCurrentBook) {
    this.app = app;
    this.plugin = plugin;
    this.getCurrentBook = getCurrentBook;
  }
  registerEditorMenu() {
    this.plugin.registerEvent(
      this.app.workspace.on("editor-menu", async (menu, editor, view) => {
        if (!this.isValidContext(view.file))
          return;
        const bookPath = this.getBookPath();
        if (!bookPath)
          return;
        await this.handleEditorMenu(menu, editor, bookPath, view.file);
      })
    );
  }
  // === 2. 路径和上下文验证 ===
  getBookPath() {
    const currentBook = this.getCurrentBook();
    return currentBook ? `${this.plugin.settings.defaultBookPath}/${currentBook.basic.title}` : null;
  }
  isValidContext(file) {
    if (!file || !this.getCurrentBook())
      return false;
    const bookPath = this.getBookPath();
    if (!bookPath)
      return false;
    return file.path.startsWith(bookPath);
  }
  checkReferenceFile(bookPath) {
    const referencePath = `${bookPath}/${i18n.t("REFERENCE_FILE_NAME")}`;
    const file = this.app.vault.getAbstractFileByPath(referencePath);
    if (!file) {
      new import_obsidian12.Notice(i18n.t("REFERENCE_FILE_NOT_FOUND"));
      return false;
    }
    return true;
  }
  // === 3. 节点查找和路径处理 ===
  findCurrentNode(file) {
    const currentBook = this.getCurrentBook();
    if (!file || !currentBook)
      return null;
    const bookBasePath = `${this.plugin.settings.defaultBookPath}/${currentBook.basic.title}/`;
    if (!(file == null ? void 0 : file.path) || !file.path.startsWith(bookBasePath))
      return null;
    const relativePath = file.path.slice(bookBasePath.length);
    const findNode = (nodes) => {
      for (const node of nodes) {
        if (node.path === relativePath)
          return node;
        if (node.children) {
          const found = findNode(node.children);
          if (found)
            return found;
        }
      }
      return null;
    };
    return findNode(currentBook.structure.tree);
  }
  findNodePath(id) {
    const currentBook = this.getCurrentBook();
    if (!currentBook)
      return [];
    const findPath = (nodes, parentOrder = []) => {
      for (const node of nodes) {
        const currentPath = [...parentOrder, node.order];
        if (node.id === id)
          return currentPath;
        if (node.children) {
          const found = findPath(node.children, currentPath);
          if (found.length > 0)
            return found;
        }
      }
      return [];
    };
    return findPath(currentBook.structure.tree);
  }
  // === 4. 引用数据管理 ===
  generateRandomId() {
    return Math.random().toString(36).substring(2, 15);
  }
  // === 4. 引用数据管理 ===
  async getReferenceData(bookPath) {
    const referenceConfigPath = `${bookPath}/references.json`;
    try {
      const configFile = this.app.vault.getAbstractFileByPath(referenceConfigPath);
      if (configFile instanceof import_obsidian12.TFile) {
        const data = await this.app.vault.read(configFile);
        const references = JSON.parse(data);
        await this.syncChaptersInfo(references);
        return references;
      }
    } catch (error) {
      console.error("\u8BFB\u53D6\u5F15\u7528\u914D\u7F6E\u5931\u8D25:", error);
    }
    return { chapters: [] };
  }
  async syncChaptersInfo(references) {
    const currentBook = this.getCurrentBook();
    if (!currentBook)
      return;
    const chaptersMap = /* @__PURE__ */ new Map();
    const traverse = (nodes) => {
      for (const node of nodes) {
        const orderPath = this.findNodePath(node.id);
        chaptersMap.set(node.id, {
          title: node.title,
          orderPath
        });
        if (node.children) {
          traverse(node.children);
        }
      }
    };
    traverse(currentBook.structure.tree);
    references.chapters = references.chapters.filter((chapter) => {
      const latestInfo = chaptersMap.get(chapter.chapterId);
      if (latestInfo) {
        chapter.chapterTitle = latestInfo.title;
        chapter.orderPath = latestInfo.orderPath;
        return true;
      }
      return false;
    });
  }
  findReferenceById(references, refId) {
    for (const chapter of references.chapters) {
      const index = chapter.references.findIndex((r) => r.id === refId);
      if (index !== -1) {
        return {
          ref: chapter.references[index],
          chapter,
          order: index + 1
        };
      }
    }
    return null;
  }
  findReferenceByText(references, text) {
    for (const chapter of references.chapters) {
      const ref = chapter.references.find((r) => r.text === text);
      if (ref) {
        return { ref, chapter };
      }
    }
    return null;
  }
  findChapterByNode(references, node) {
    let chapter = references.chapters.find((c) => c.chapterId === node.id);
    if (!chapter) {
      chapter = {
        chapterId: node.id,
        chapterTitle: node.title,
        orderPath: this.findNodePath(node.id),
        references: []
      };
      references.chapters.push(chapter);
    }
    return chapter;
  }
  async updateReferenceFiles(bookPath, references) {
    const referenceConfigPath = `${bookPath}/references.json`;
    const configFile = this.app.vault.getAbstractFileByPath(referenceConfigPath);
    const jsonContent = JSON.stringify(references, null, 2);
    if (configFile instanceof import_obsidian12.TFile) {
      await this.app.vault.modify(configFile, jsonContent);
    } else {
      await this.app.vault.create(referenceConfigPath, jsonContent);
    }
    if (!this.checkReferenceFile(bookPath))
      return;
    const referencePath = `${bookPath}/${i18n.t("REFERENCE_FILE_NAME")}`;
    const file = this.app.vault.getAbstractFileByPath(referencePath);
    if (!(file instanceof import_obsidian12.TFile)) {
      throw new Error(i18n.t("REFERENCE_FILE_ERROR"));
    }
    references.chapters.sort((a, b) => {
      const pathA = a.orderPath;
      const pathB = b.orderPath;
      for (let i = 0; i < Math.min(pathA.length, pathB.length); i++) {
        if (pathA[i] !== pathB[i]) {
          return pathA[i] - pathB[i];
        }
      }
      return pathA.length - pathB.length;
    });
    let content = "";
    for (const chapter of references.chapters) {
      content += `#### ${chapter.chapterTitle}
`;
      chapter.references.forEach((ref, index) => {
        ref.order = index + 1;
        content += `${ref.order}. ${ref.content} ^${ref.id}
`;
      });
      content += "\n";
    }
    await this.app.vault.modify(file, content);
  }
  // === 5. 工具方法 ===
  toSuperscript(num) {
    const superscripts = ["\u2070", "\xB9", "\xB2", "\xB3", "\u2074", "\u2075", "\u2076", "\u2077", "\u2078", "\u2079"];
    return num.toString().split("").map((d) => superscripts[parseInt(d)]).join("");
  }
  // === 6. 菜单处理 ===
  async handleEditorMenu(menu, editor, bookPath, file) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const selectedText = editor.getSelection().trim();
    const pattern = /(\[\[.*?#\^(.*?)\|.*?\]\])([\^⁰¹²³⁴⁵⁶⁷⁸⁹]+)/g;
    let match;
    let currentRef = null;
    while ((match = pattern.exec(line)) !== null) {
      if (cursor.ch >= match.index && cursor.ch <= match.index + match[0].length) {
        currentRef = match;
      }
    }
    if (currentRef) {
      this.addEditReferenceMenuItem(menu, editor, bookPath, currentRef[2]);
      this.addDeleteReferenceMenuItem(menu, editor, bookPath, currentRef[2], currentRef[1], currentRef[3]);
    } else if (selectedText) {
      this.addNewReferenceMenuItem(menu, editor, file);
    }
  }
  addEditReferenceMenuItem(menu, editor, bookPath, refId) {
    menu.addItem((item) => {
      item.setTitle(i18n.t("EDIT_REFERENCE")).setIcon("edit").onClick(async () => {
        const references = await this.getReferenceData(bookPath);
        const found = this.findReferenceById(references, refId);
        if (found) {
          this.openReferenceEditModal(found.ref, references, bookPath, editor);
        }
      });
    });
  }
  addDeleteReferenceMenuItem(menu, editor, bookPath, refId, linkPart, orderPart) {
    menu.addItem((item) => {
      item.setTitle(i18n.t("DELETE_REFERENCE")).setIcon("trash").onClick(async () => {
        const references = await this.getReferenceData(bookPath);
        const found = this.findReferenceById(references, refId);
        if (found) {
          found.chapter.references = found.chapter.references.filter((r) => r.id !== refId);
          await this.updateReferenceFiles(bookPath, references);
          const cursor = editor.getCursor();
          const line = editor.getLine(cursor.line);
          const fullMatch = linkPart + orderPart;
          const start2 = line.indexOf(fullMatch);
          const end2 = start2 + fullMatch.length;
          const textMatch = linkPart.match(/\[\[.*?\|(.*?)\]\]/);
          const originalText = textMatch ? textMatch[1] : "";
          editor.replaceRange(
            originalText,
            { line: cursor.line, ch: start2 },
            { line: cursor.line, ch: end2 }
          );
        }
      });
    });
  }
  addNewReferenceMenuItem(menu, editor, file) {
    menu.addItem((item) => {
      item.setTitle(i18n.t("INSERT_REFERENCE")).setIcon("quote-glyph").onClick(async () => {
        await this.handleReferenceInsertion(editor, file);
      });
    });
  }
  // === 7. 引用操作处理 ===
  async handleReferenceInsertion(editor, file) {
    const selectedText = editor.getSelection().trim();
    if (!selectedText || selectedText.length === 0) {
      new import_obsidian12.Notice(i18n.t("SELECT_TEXT_TO_REFERENCE"));
      return;
    }
    const bookPath = this.getBookPath();
    if (!bookPath)
      return;
    if (!this.checkReferenceFile(bookPath))
      return;
    const references = await this.getReferenceData(bookPath);
    const existingRef = this.findReferenceByText(references, selectedText);
    if (existingRef) {
      this.openReferenceEditModal(existingRef.ref, references, bookPath, editor, selectedText);
      return;
    }
    this.openReferenceCreateModal(references, bookPath, editor, selectedText, file);
  }
  openReferenceEditModal(ref, references, bookPath, editor, selectedText) {
    new ReferenceModal(this.app, async (referenceContent) => {
      if (!referenceContent)
        return;
      ref.content = referenceContent;
      ref.createTime = new Date().toISOString();
      await this.updateReferenceFiles(bookPath, references);
      if (editor && selectedText) {
        const found = this.findReferenceById(references, ref.id);
        if (found) {
          const referenceLink = `[[${bookPath}/${i18n.t("REFERENCE_FILE_NAME")}#^${ref.id}|${selectedText}]]${this.toSuperscript(found.order)}`;
          editor.replaceSelection(referenceLink);
        }
      }
    }, ref.content).open();
  }
  openReferenceCreateModal(references, bookPath, editor, selectedText, file) {
    new ReferenceModal(this.app, async (referenceContent) => {
      if (!referenceContent)
        return;
      const currentNode = this.findCurrentNode(file);
      if (!currentNode) {
        new import_obsidian12.Notice(i18n.t("CHAPTER_INFO_ERROR"));
        return;
      }
      const chapter = this.findChapterByNode(references, currentNode);
      const newRef = {
        id: this.generateRandomId(),
        text: selectedText,
        content: referenceContent,
        createTime: new Date().toISOString(),
        order: chapter.references.length + 1
      };
      chapter.references.push(newRef);
      await this.updateReferenceFiles(bookPath, references);
      const referenceLink = `[[${bookPath}/${i18n.t("REFERENCE_FILE_NAME")}#^${newRef.id}|${selectedText}]]${this.toSuperscript(newRef.order)}`;
      editor.replaceSelection(referenceLink);
    }).open();
  }
};

// src/views/BookSmithView.ts
var BookSmithView = class extends import_obsidian13.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    // === 属性定义 ===
    this.currentBook = null;
    this.isRenamingFile = false;
    this.fileEventManager = new FileEventManager(this.app, this.plugin);
    this.referenceManager = new ReferenceManager(
      this.app,
      this.plugin,
      () => this.currentBook
    );
    this.registerFileEvents();
    this.referenceManager.registerEditorMenu();
    this.registerEvent(
      this.plugin.statsManager.onStatsChange(() => {
        this.renderStats(this.containerEl.children[1]);
      })
    );
  }
  // === 视图状态管理 ===
  async refreshView() {
    await this.loadBook();
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("book-smith-view-content");
    this.renderToolbar(container);
    this.renderContent(container);
    this.renderStats(container);
  }
  // === 文件事件监听 ===
  registerFileEvents() {
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (this.isRenamingFile)
          return;
        if (file instanceof import_obsidian13.TFile && this.currentBook) {
          if (file.path.endsWith("book-config.json"))
            return;
          const bookPath = `${this.plugin.settings.defaultBookPath}/${this.currentBook.basic.title}`;
          if (file.path.startsWith(bookPath)) {
            const result = await this.fileEventManager.handleBookModify(file, this.currentBook);
            if (result) {
              await this.refreshView();
            }
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        this.isRenamingFile = true;
        if ((file instanceof import_obsidian13.TFile || file instanceof import_obsidian13.TFolder) && this.currentBook) {
          const updatedBook = await this.fileEventManager.handleBookModify(file, this.currentBook, oldPath);
          if (updatedBook) {
            await this.refreshView();
          }
        }
        this.isRenamingFile = false;
      })
    );
  }
  // === 数据加载 ===
  async loadBook() {
    const bookId = this.plugin.settings.lastBookId;
    if (bookId) {
      this.currentBook = await this.plugin.bookManager.getBookById(bookId);
      this.plugin.statsManager.setCurrentBook(this.currentBook);
    } else {
      this.currentBook = null;
      this.plugin.statsManager.setCurrentBook(null);
    }
  }
  // === 视图基础方法 ===
  getViewType() {
    return "book-smith-view";
  }
  getDisplayText() {
    return i18n.t("BOOK_MANAGER");
  }
  getIcon() {
    return "book";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("book-smith-view-content");
    await this.loadBook();
    this.renderToolbar(container);
    this.renderContent(container);
    this.renderStats(container);
  }
  // === 界面渲染方法 ===
  renderToolbar(container) {
    const toolbar = container.createDiv({ cls: "book-smith-toolbar" });
    const newBookBtn = toolbar.createEl("button", { cls: "book-smith-toolbar-btn" });
    (0, import_obsidian13.setIcon)(newBookBtn, "create-new");
    newBookBtn.appendChild(createSpan({ text: ` ${i18n.t("NEW_BOOK")}` }));
    newBookBtn.addEventListener("click", () => {
      new CreateBookModal(this.app, this.plugin, async (newBook) => {
        if (newBook) {
          this.plugin.settings.lastBookId = newBook.basic.uuid;
          await this.plugin.saveSettings();
          await this.refreshView();
          new import_obsidian13.Notice(i18n.t("SWITCHED_TO_BOOK", { title: newBook.basic.title }));
        }
      }).open();
    });
    const switchBookBtn = toolbar.createEl("button", { cls: "book-smith-toolbar-btn" });
    (0, import_obsidian13.setIcon)(switchBookBtn, "switch");
    switchBookBtn.appendChild(createSpan({ text: ` ${i18n.t("SWITCH_BOOK")}` }));
    switchBookBtn.addEventListener("click", () => {
      this.switchBook();
    });
    const manageBookBtn = toolbar.createEl("button", { cls: "book-smith-toolbar-btn" });
    (0, import_obsidian13.setIcon)(manageBookBtn, "library");
    manageBookBtn.appendChild(createSpan({ text: ` ${i18n.t("MANAGE_BOOK")}` }));
    manageBookBtn.addEventListener("click", async () => {
      new ManageBooksModal(this.app, this.plugin, async (result) => {
        var _a;
        if (result.type === "imported" && result.bookId) {
          this.plugin.settings.lastBookId = result.bookId;
          await this.plugin.saveSettings();
          await this.refreshView();
          new import_obsidian13.Notice(i18n.t("IMPORTED_AND_SWITCHED"));
        } else if (result.bookId === ((_a = this.currentBook) == null ? void 0 : _a.basic.uuid)) {
          if (result.type === "deleted") {
            this.plugin.settings.lastBookId = void 0;
            await this.plugin.saveSettings();
            this.currentBook = null;
            await this.refreshView();
            new import_obsidian13.Notice(i18n.t("CURRENT_BOOK_DELETED"));
          } else if (result.type === "edited") {
            await this.refreshView();
          }
        }
      }).open();
    });
    const helpBtnContainer = toolbar.createDiv({ cls: "book-smith-help-container" });
    const helpBtn = helpBtnContainer.createEl("button", { cls: "book-smith-toolbar-btn" });
    (0, import_obsidian13.setIcon)(helpBtn, "help-circle");
    helpBtnContainer.createEl("div", {
      cls: "book-smith-help-tooltip",
      text: i18n.t("HELP_TOOLTIP")
    });
  }
  async renderContent(container) {
    container.createDiv({ cls: "book-smith-divider" });
    const bookContent = container.createDiv({ cls: "book-smith-content" });
    const currentBookId = this.plugin.settings.lastBookId;
    if (!currentBookId || !this.currentBook) {
      this.renderEmptyState(bookContent);
      container.createDiv({ cls: "book-smith-bottom-divider" });
      return;
    }
    const titleSection = bookContent.createDiv({ cls: "book-smith-book-header" });
    const coverContainer = titleSection.createDiv({ cls: "book-smith-header-cover" });
    if (this.currentBook.basic.cover) {
      coverContainer.createEl("img", {
        attr: {
          src: this.app.vault.adapter.getResourcePath(this.currentBook.basic.cover)
        }
      });
    }
    const titleContent = titleSection.createDiv({ cls: "book-smith-header-content" });
    titleContent.createEl("h2", {
      text: `\u300A${this.currentBook.basic.title}\u300B`,
      cls: "book-smith-title"
    });
    if (this.currentBook.basic.subtitle) {
      titleContent.createEl("p", {
        text: this.currentBook.basic.subtitle,
        cls: "book-smith-subtitle"
      });
    }
    const infoSection = bookContent.createDiv({ cls: "book-smith-book-info" });
    const authorRow = infoSection.createDiv({ cls: "book-smith-info-row" });
    authorRow.createSpan({ text: i18n.t("BOOK_AUTHOR"), cls: "book-smith-info-label" });
    authorRow.createSpan({
      text: this.currentBook.basic.author.join(", "),
      cls: "book-smith-info-value"
    });
    const descRow = infoSection.createDiv({ cls: "book-smith-info-row" });
    descRow.createSpan({ text: i18n.t("BOOK_DESCRIPTION"), cls: "book-smith-info-label" });
    descRow.createSpan({
      text: this.currentBook.basic.desc || "",
      cls: "book-smith-info-value description"
    });
    const treeSection = bookContent.createDiv({ cls: "book-smith-chapter-tree" });
    this.renderChapterTree(treeSection);
    container.createDiv({ cls: "book-smith-bottom-divider" });
  }
  renderChapterTree(container) {
    if (!this.currentBook)
      return;
    const bookPath = `${this.plugin.settings.defaultBookPath}/${this.currentBook.basic.title}`;
    new ChapterTree(
      container,
      this.app,
      bookPath,
      this.plugin.bookManager,
      async () => {
        await this.loadBook();
        await this.onOpen();
      }
    ).render(this.currentBook);
  }
  renderEmptyState(container) {
    const emptyState = container.createDiv({ cls: "book-smith-empty-state" });
    emptyState.createEl("p", {
      text: i18n.t("WELCOME_MESSAGE"),
      cls: "book-smith-empty-title"
    });
    emptyState.createEl("p", {
      text: i18n.t("EMPTY_STATE_HINT"),
      cls: "book-smith-empty-desc"
    });
  }
  renderStats(container) {
    const statsContainer = container.createDiv({ cls: "book-smith-stats" });
    if (!this.currentBook)
      return;
    const today = new Date().toISOString().split("T")[0];
    const todayWords = statsContainer.createDiv({ cls: "book-smith-stat-item" });
    const todayWordsLabel = todayWords.createSpan();
    (0, import_obsidian13.setIcon)(todayWordsLabel, "pencil");
    todayWordsLabel.appendChild(createSpan({ text: ` ${i18n.t("TODAY_WORDS")}` }));
    todayWords.createEl("span", {
      cls: "book-smith-stat-value",
      text: `${this.currentBook.stats.daily_words[today] || 0}${i18n.t("WORD_UNIT")}`
    });
    const wordCount = statsContainer.createDiv({ cls: "book-smith-stat-item" });
    const wordCountLabel = wordCount.createSpan();
    (0, import_obsidian13.setIcon)(wordCountLabel, "document");
    wordCountLabel.appendChild(createSpan({ text: ` ${i18n.t("TOTAL_WORDS")}` }));
    wordCount.createEl("span", {
      cls: "book-smith-stat-value",
      text: `${this.currentBook.stats.total_words}${this.currentBook.stats.target_total_words ? ` / ${(this.currentBook.stats.target_total_words / 1e4).toFixed(1)}${i18n.t("TEN_THOUSAND")}` : ""}`
    });
    const progress = statsContainer.createDiv({ cls: "book-smith-stat-item" });
    const progressLabel = progress.createSpan();
    (0, import_obsidian13.setIcon)(progressLabel, "target");
    progressLabel.appendChild(createSpan({ text: ` ${i18n.t("CHAPTER_COMPLETION")}` }));
    progress.createEl("span", {
      cls: "book-smith-stat-value",
      text: `${Math.round(this.currentBook.stats.progress_by_chapter * 100)}%`
    });
    const duration = statsContainer.createDiv({ cls: "book-smith-stat-item" });
    const durationLabel = duration.createSpan();
    (0, import_obsidian13.setIcon)(durationLabel, "clock");
    durationLabel.appendChild(createSpan({ text: ` ${i18n.t("WRITING_DAYS")}` }));
    duration.createEl("span", {
      cls: "book-smith-stat-value",
      text: `${this.currentBook.stats.writing_days}${i18n.t("DAY_UNIT")}`
    });
    const average = statsContainer.createDiv({ cls: "book-smith-stat-item" });
    const averageLabel = average.createSpan();
    (0, import_obsidian13.setIcon)(averageLabel, "calendar-clock");
    averageLabel.appendChild(createSpan({ text: ` ${i18n.t("AVERAGE_DAILY_WORDS")}` }));
    average.createEl("span", {
      cls: "book-smith-stat-value",
      text: `${Math.round(this.currentBook.stats.average_daily_words)}${i18n.t("WORD_UNIT")}`
    });
  }
  // === 交互处理方法 ===
  async switchBook() {
    const books = await this.plugin.bookManager.getAllBooks();
    if (books.length === 0) {
      new import_obsidian13.Notice(i18n.t("NO_BOOKS_TO_SWITCH"));
      return;
    }
    new SwitchBookModal(this.app, books, async (selectedBook) => {
      this.plugin.settings.lastBookId = selectedBook.basic.uuid;
      await this.plugin.saveSettings();
      await this.refreshView();
      new import_obsidian13.Notice(i18n.t("SWITCHED_TO_BOOK", { title: selectedBook.basic.title }));
    }).open();
  }
};

// src/views/ToolsView.ts
var import_obsidian23 = require("obsidian");

// src/components/FocusToolView.ts
var import_obsidian15 = require("obsidian");

// src/services/FocusManager.ts
var import_obsidian14 = require("obsidian");
var FocusManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.timer = null;
    this.startTime = 0;
    this.remainingTime = 0;
    this.state = "idle" /* IDLE */;
    this.stats = {
      interruptions: 0,
      completedSessions: 0,
      totalWords: 0
    };
    this.updateListeners = [];
    // 字数统计相关
    this.currentWords = 0;
    this.lastContent = "";
    this.activeLeafHandler = null;
    this.modifyHandler = null;
    this.loadTodayStats();
  }
  // =============== 状态管理方法 ===============
  getState() {
    return this.state;
  }
  getStats() {
    return { ...this.stats };
  }
  getCurrentWords() {
    return this.currentWords;
  }
  getCurrentTime() {
    const minutes = Math.floor(this.remainingTime / 60);
    const seconds = this.remainingTime % 60;
    const totalTime = this.state === "break" /* BREAK */ ? this.plugin.settings.focus.breakDuration * 60 : this.plugin.settings.focus.workDuration * 60;
    const progress = this.state === "paused" /* PAUSED */ ? 1 - this.remainingTime / totalTime : Math.max(0, Math.min(1, 1 - this.remainingTime / totalTime));
    return { minutes, seconds, progress };
  }
  // =============== 专注控制方法 ===============
  startFocus() {
    if (this.state !== "idle" /* IDLE */)
      return;
    this.setupWordCounter();
    this.state = "working" /* WORKING */;
    this.startTime = Date.now();
    this.remainingTime = this.plugin.settings.focus.workDuration * 60;
    this.startTimer();
    this.notifyUpdate();
  }
  pauseFocus() {
    if (this.state !== "working" /* WORKING */)
      return;
    this.state = "paused" /* PAUSED */;
    this.clearTimer();
    this.notifyUpdate();
  }
  resumeFocus() {
    if (this.state !== "paused" /* PAUSED */)
      return;
    this.state = "working" /* WORKING */;
    this.startTimer();
    this.notifyUpdate();
  }
  endFocus() {
    if (this.state === "idle" /* IDLE */)
      return;
    this.clearTimer();
    if (this.state !== "break" /* BREAK */) {
      this.stats.interruptions++;
      this.updateTotalWords();
    }
    this.removeWordCounter();
    this.state = "idle" /* IDLE */;
    this.saveStats();
    this.showSummary();
    this.notifyUpdate();
  }
  // =============== 统计管理方法 ===============
  updateTotalWords() {
    if (this.currentWords > 0) {
      this.stats.totalWords += this.currentWords;
      this.saveStats();
    }
  }
  loadTodayStats() {
    var _a;
    const today = new Date().toISOString().split("T")[0];
    const dailyStats = (_a = this.plugin.settings.focus.stats) == null ? void 0 : _a.dailyStats[today];
    this.stats = dailyStats ? { ...dailyStats } : {
      interruptions: 0,
      completedSessions: 0,
      totalWords: 0
    };
  }
  saveStats() {
    const today = new Date().toISOString().split("T")[0];
    if (!this.plugin.settings.focus.stats) {
      this.plugin.settings.focus.stats = { dailyStats: {} };
    }
    this.plugin.settings.focus.stats.dailyStats[today] = { ...this.stats };
    this.plugin.saveSettings();
  }
  // =============== 字数统计方法 ===============
  setupWordCounter() {
    this.lastContent = "";
    this.currentWords = 0;
    this.activeLeafHandler = () => {
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
      if (activeView) {
        this.lastContent = activeView.editor.getValue();
      }
    };
    this.modifyHandler = (file) => {
      const activeFile = this.plugin.app.workspace.getActiveFile();
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
      if (!activeFile || !activeView || file !== activeFile)
        return;
      const content = activeView.editor.getValue();
      const wordDiff = this.getWordDiff(this.lastContent, content);
      this.currentWords += wordDiff;
      this.lastContent = content;
      this.notifyUpdate();
    };
    this.plugin.app.workspace.on("active-leaf-change", this.activeLeafHandler);
    this.plugin.app.vault.on("modify", this.modifyHandler);
  }
  removeWordCounter() {
    if (this.activeLeafHandler) {
      this.plugin.app.workspace.off("active-leaf-change", this.activeLeafHandler);
      this.activeLeafHandler = null;
    }
    if (this.modifyHandler) {
      this.plugin.app.vault.off("modify", this.modifyHandler);
      this.modifyHandler = null;
    }
    this.currentWords = 0;
    this.lastContent = "";
  }
  getWordDiff(oldText, newText) {
    const oldCount = this.countWords(oldText);
    const newCount = this.countWords(newText);
    return newCount - oldCount;
  }
  countWords(text) {
    const cleanText = text.replace(
      /(```[\s\S]*?```)|(`.*?`)|(\[.*?\]\(.*?\))|(\*\*.*?\*\*)|(\*.*?\*)|(\n>)|(^\s*[-+*]\s)|(^\s*\d+\.\s)|(\!\[.*?\]\(.*?\))/gm,
      ""
    );
    let chineseCount = 0;
    for (let i = 0; i < cleanText.length; i++) {
      if (cleanText.charCodeAt(i) >= 19968 && cleanText.charCodeAt(i) <= 40869) {
        chineseCount++;
      }
    }
    const words = cleanText.replace(/[\u4e00-\u9fa5]/g, "").trim().split(/\s+/);
    const englishCount = words[0] === "" ? 0 : words.length;
    return chineseCount + englishCount;
  }
  // =============== 定时器管理方法 ===============
  startTimer() {
    this.clearTimer();
    this.timer = window.setInterval(() => {
      this.remainingTime--;
      this.notifyUpdate();
      if (this.remainingTime <= 0) {
        if (this.state === "working" /* WORKING */) {
          this.startBreak();
        } else if (this.state === "break" /* BREAK */) {
          this.endFocus();
        }
      }
    }, 1e3);
  }
  clearTimer() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  startBreak() {
    this.stats.completedSessions++;
    this.updateTotalWords();
    this.saveStats();
    this.state = "break" /* BREAK */;
    this.remainingTime = this.plugin.settings.focus.breakDuration * 60;
    this.startTimer();
    new import_obsidian14.Notice(i18n.t("BREAK_TIME_START"));
    this.notifyUpdate();
  }
  showSummary() {
    new import_obsidian14.Notice(i18n.t("FOCUS_SUMMARY", {
      duration: this.plugin.settings.focus.workDuration,
      interruptions: this.stats.interruptions,
      words: this.currentWords
    }));
  }
  // =============== 事件监听方法 ===============
  onUpdate(callback) {
    this.updateListeners.push(callback);
  }
  removeUpdateListener(callback) {
    this.updateListeners = this.updateListeners.filter((fn2) => fn2 !== callback);
  }
  notifyUpdate() {
    this.updateListeners.forEach((callback) => callback());
  }
  // =============== 工具方法 ===============
  debounce(func, wait) {
    let timeout = null;
    return (...args) => {
      if (timeout) {
        window.clearTimeout(timeout);
      }
      timeout = window.setTimeout(() => {
        func.apply(this, args);
        timeout = null;
      }, wait);
    };
  }
};

// src/components/FocusToolView.ts
var FocusToolView = class {
  // ================ 构造函数 ================
  constructor(app, plugin, parentEl, onExit) {
    this.app = app;
    this.plugin = plugin;
    this.parentEl = parentEl;
    this.onExit = onExit;
    this.removeCallbacks = [];
    this.focusManager = new FocusManager(this.plugin);
    this.createUI();
    this.setupEventListeners();
  }
  // ================ UI 创建方法 ================
  createUI() {
    this.container = this.parentEl.createDiv({ cls: "book-smith-focus-tool" });
    this.createHeader();
    this.createTimerSection();
    this.createStatusSection();
    this.createControlSection();
    this.createStatsSection();
  }
  createHeader() {
    const header = this.container.createDiv({ cls: "focus-tool-header" });
    (0, import_obsidian15.setIcon)(header.createSpan({ cls: "focus-tool-header-icon" }), "target");
    header.createSpan({ text: i18n.t("FOCUS_MODE"), cls: "focus-tool-title" });
  }
  createTimerSection() {
    const timerContainer = this.container.createDiv({ cls: "focus-tool-timer-container" });
    const svg = this.createProgressRing();
    timerContainer.appendChild(svg);
    this.createTimerAdjustButton(timerContainer, "up");
    this.createTimerAdjustButton(timerContainer, "down");
    this.timerEl = timerContainer.createDiv({ cls: "focus-tool-timer" });
    this.updateTimer();
  }
  createProgressRing() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "focus-tool-progress-circle");
    svg.setAttribute("viewBox", "0 0 100 100");
    const bgCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    bgCircle.setAttribute("cx", "50");
    bgCircle.setAttribute("cy", "50");
    bgCircle.setAttribute("r", "45");
    bgCircle.setAttribute("class", "focus-tool-progress-bg");
    this.progressEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.progressEl.setAttribute("cx", "50");
    this.progressEl.setAttribute("cy", "50");
    this.progressEl.setAttribute("r", "45");
    this.progressEl.setAttribute("class", "focus-tool-progress-ring");
    svg.appendChild(bgCircle);
    svg.appendChild(this.progressEl);
    return svg;
  }
  createTimerAdjustButton(container, direction) {
    const button = container.createDiv({
      cls: `focus-tool-timer-adjust ${direction}`
    });
    button.addEventListener("click", () => {
      const currentDuration = this.plugin.settings.focus.workDuration;
      const newDuration = direction === "up" ? Math.min(currentDuration + 5, 60) : Math.max(currentDuration - 5, 5);
      if (newDuration !== currentDuration) {
        this.plugin.settings.focus.workDuration = newDuration;
        this.plugin.saveSettings();
        this.updateTimer();
      }
    });
  }
  createStatusSection() {
    this.statusEl = this.container.createDiv({ cls: "focus-tool-status" });
    this.statusEl.setText(i18n.t("READY_TO_START"));
  }
  createControlSection() {
    const controls = this.container.createDiv({ cls: "focus-tool-controls" });
    this.createInitialControls(controls);
  }
  createInitialControls(controls) {
    this.createButton(controls, i18n.t("START_FOCUS"), true, () => {
      this.focusManager.startFocus();
      controls.empty();
      this.createControlButtons(controls);
    });
    this.createButton(controls, i18n.t("EXIT"), false, () => this.handleExit());
  }
  createStatsSection() {
    const statsContainer = this.container.createDiv({ cls: "focus-tool-stats-container" });
    const stats = this.focusManager.getStats();
    this.completedEl = this.createStatItem(statsContainer, i18n.t("FOCUS_SESSIONS"), stats.completedSessions.toString());
    this.interruptedEl = this.createStatItem(statsContainer, i18n.t("INTERRUPTIONS"), stats.interruptions.toString());
    this.wordCountEl = this.createStatItem(statsContainer, i18n.t("CURRENT_WORDS"), "0");
    this.wordGoalEl = this.createStatItem(statsContainer, i18n.t("WORD_GOAL"), this.plugin.settings.focus.wordGoal.toString());
    this.totalWordsEl = this.createStatItem(statsContainer, i18n.t("TOTAL_FOCUS_WORDS"), stats.totalWords.toString());
  }
  createControlButtons(controls) {
    controls.empty();
    const state = this.focusManager.getState();
    if (state === "working" /* WORKING */) {
      this.createButton(controls, i18n.t("PAUSE"), false, () => this.focusManager.pauseFocus());
    } else if (state === "paused" /* PAUSED */) {
      this.createButton(controls, i18n.t("RESUME"), true, () => this.focusManager.resumeFocus());
      this.createButton(controls, i18n.t("END"), false, () => this.showEndConfirmation());
    }
    this.createButton(controls, i18n.t("EXIT"), false, () => this.handleExit());
  }
  createButton(container, text, solid, onClick) {
    const btn = container.createDiv({
      cls: `focus-tool-btn ${solid ? "focus-tool-btn-solid" : "focus-tool-btn-outline"}`
    });
    btn.setText(text);
    btn.addEventListener("click", onClick);
    return btn;
  }
  createStatItem(container, label, value) {
    const item = container.createDiv({ cls: "focus-tool-stat-item" });
    item.createSpan({ text: label });
    const valueSpan = item.createSpan({ text: value });
    return valueSpan;
  }
  // ================ UI 更新方法 ================
  updateTimer(minutes, seconds) {
    var _a;
    if (minutes === void 0) {
      this.timerEl.textContent = `${this.plugin.settings.focus.workDuration.toString().padStart(2, "0")}:00`;
    } else {
      this.timerEl.textContent = `${minutes.toString().padStart(2, "0")}:${(_a = seconds == null ? void 0 : seconds.toString().padStart(2, "0")) != null ? _a : "00"}`;
    }
  }
  updateProgress(progress) {
    const circumference = 2 * Math.PI * 45;
    const offset2 = circumference * (1 - progress);
    this.progressEl.style.strokeDashoffset = offset2.toString();
  }
  updateStatus(text) {
    this.statusEl.setText(text);
  }
  updateStats(completed, interrupted) {
    this.completedEl.setText(completed.toString());
    this.interruptedEl.setText(interrupted.toString());
  }
  getRandomEncouragement() {
    const messages = [
      "\u{1F389} \u592A\u68D2\u4E86\uFF01\u5DF2\u8FBE\u5230\u76EE\u6807\u5B57\u6570\uFF01\u7EE7\u7EED\u4FDD\u6301\uFF5E",
      "\u2728 \u5389\u5BB3\uFF01\u76EE\u6807\u8FBE\u6210\uFF01\u8BA9\u6211\u4EEC\u7EE7\u7EED\u524D\u8FDB\uFF01",
      "\u{1F31F} \u5B8C\u7F8E\uFF01\u8FBE\u5230\u76EE\u6807\u4E86\uFF01\u4FDD\u6301\u8FD9\u4EFD\u70ED\u60C5\uFF01",
      "\u{1F3AF} \u76EE\u6807\u8FBE\u6210\uFF01\u4F60\u7684\u575A\u6301\u503C\u5F97\u8868\u626C\uFF01",
      "\u{1F4AA} \u51FA\u8272\u7684\u8868\u73B0\uFF01\u76EE\u6807\u5B8C\u6210\uFF01\u518D\u63A5\u518D\u5389\uFF01"
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  }
  showCelebration() {
    const celebration = document.createElement("div");
    celebration.className = "focus-celebration";
    const text = document.createElement("div");
    text.className = "celebration-text";
    text.textContent = this.getRandomEncouragement();
    celebration.appendChild(text);
    this.container.appendChild(celebration);
    celebration.addEventListener("animationend", () => {
      celebration.remove();
    });
  }
  updateWordCount(current) {
    this.wordCountEl.setText(current.toString());
    const goalReached = current >= this.plugin.settings.focus.wordGoal;
    const wordCountItem = this.wordCountEl.parentElement;
    if (wordCountItem) {
      wordCountItem.toggleClass("goal-reached", goalReached);
      if (goalReached && !wordCountItem.hasClass("goal-reached-notified")) {
        wordCountItem.addClass("goal-reached-notified");
        this.showCelebration();
      }
    }
  }
  handleIdleState(controls) {
    controls.empty();
    this.updateProgress(0);
    this.updateTimer();
    const wordCountItem = this.wordCountEl.parentElement;
    if (wordCountItem) {
      wordCountItem.removeClass("goal-reached-notified");
      wordCountItem.removeClass("goal-reached");
    }
    this.createInitialControls(controls);
  }
  updateTimerAdjustButtons(state) {
    const adjustButtons = this.container.querySelectorAll(".focus-tool-timer-adjust");
    adjustButtons.forEach((button) => {
      button.classList.toggle("hidden", state !== "idle" /* IDLE */);
    });
  }
  // ================ 事件处理方法 ================
  setupEventListeners() {
    let lastState = this.focusManager.getState();
    const updateListener = () => {
      const currentState = this.focusManager.getState();
      this.updateUIState();
      if (currentState !== lastState) {
        this.handleStateChange(lastState, currentState);
        lastState = currentState;
      }
    };
    this.focusManager.onUpdate(updateListener);
    this.onRemove(() => this.focusManager.removeUpdateListener(updateListener));
  }
  handleStateChange(oldState, newState) {
    const controls = this.container.querySelector(".focus-tool-controls");
    if (!controls)
      return;
    if (newState === "idle" /* IDLE */) {
      this.handleIdleState(controls);
    } else if (newState === "break" /* BREAK */) {
      this.handleBreakState(controls);
    } else {
      this.createControlButtons(controls);
    }
  }
  updateUIState() {
    const state = this.focusManager.getState();
    const { minutes, seconds, progress } = this.focusManager.getCurrentTime();
    const stats = this.focusManager.getStats();
    this.updateTimerAdjustButtons(state);
    this.updateTimer(minutes, seconds);
    this.updateProgress(progress);
    this.updateStats(stats.completedSessions, stats.interruptions);
    this.updateStatus(this.getStatusText(state));
    this.updateWordCount(this.focusManager.getCurrentWords());
    this.totalWordsEl.setText(stats.totalWords.toString());
  }
  handleBreakState(controls) {
    this.createControlButtons(controls);
  }
  handleExit() {
    const state = this.focusManager.getState();
    if (state === "working" /* WORKING */ || state === "paused" /* PAUSED */) {
      new ConfirmModal(
        this.app,
        i18n.t("EXIT_FOCUS"),
        i18n.t("EXIT_FOCUS_DESC"),
        () => {
          this.focusManager.endFocus();
          this.onExit();
        }
      ).open();
    } else {
      if (state !== "idle" /* IDLE */) {
        this.focusManager.endFocus();
      }
      this.onExit();
    }
  }
  showEndConfirmation() {
    new ConfirmModal(
      this.app,
      i18n.t("END_FOCUS"),
      i18n.t("END_FOCUS_DESC"),
      () => {
        this.focusManager.endFocus();
        this.onExit();
      }
    ).open();
  }
  // ================ 工具方法 ================
  getStatusText(state) {
    switch (state) {
      case "working" /* WORKING */:
        return i18n.t("FOCUSING");
      case "paused" /* PAUSED */:
        return i18n.t("PAUSED");
      case "break" /* BREAK */:
        return i18n.t("BREAK_TIME");
      default:
        return i18n.t("READY_TO_START");
    }
  }
  onRemove(callback) {
    this.removeCallbacks.push(callback);
  }
  remove() {
    this.removeCallbacks.forEach((callback) => callback());
    this.container.remove();
  }
};

// src/modals/BaseModal.ts
var import_obsidian16 = require("obsidian");
var BaseModal = class {
  constructor(container, title) {
    this.container = container;
    this.title = title;
    this.element = container.createDiv({ cls: "book-smith-modal vertical" });
    const closeBtn = this.element.createDiv({ cls: "modal-close" });
    closeBtn.addEventListener("click", () => this.close());
  }
  open() {
    const overlay = this.container.createDiv({ cls: "book-smith-modal-overlay" });
    overlay.addEventListener("click", () => this.close());
    this.createHeader();
    this.createContent();
  }
  createHeader() {
    const header = this.element.createDiv({ cls: "book-smith-modal-header" });
    header.createEl("h2", { text: this.title });
  }
  createContent() {
  }
  showNotice(message, duration = 3e3) {
    new import_obsidian16.Notice(message, duration);
  }
  close() {
    const overlay = this.container.querySelector(".book-smith-modal-overlay");
    overlay == null ? void 0 : overlay.remove();
    this.element.remove();
  }
  remove() {
    this.close();
  }
};

// src/assets/wechat-qrcode.ts
var WechatQRCode = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAMgCAYAAAD/YBzEAAAACXBIWXMAAAdiAAAHYgE4epnbAAAExWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDI1LTA0LTA2PC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPjk1ZjBiZjcxLWMyOTgtNDAzYS05ZDM1LTlmYjNlMTA2YTY0MTwvQXR0cmliOkV4dElkPgogICAgIDxBdHRyaWI6RmJJZD41MjUyNjU5MTQxNzk1ODA8L0F0dHJpYjpGYklkPgogICAgIDxBdHRyaWI6VG91Y2hUeXBlPjI8L0F0dHJpYjpUb3VjaFR5cGU+CiAgICA8L3JkZjpsaT4KICAgPC9yZGY6U2VxPgogIDwvQXR0cmliOkFkcz4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6ZGM9J2h0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvJz4KICA8ZGM6dGl0bGU+CiAgIDxyZGY6QWx0PgogICAgPHJkZjpsaSB4bWw6bGFuZz0neC1kZWZhdWx0Jz7mnKrlkb3lkI3nmoTorr7orqEgLSAxPC9yZGY6bGk+CiAgIDwvcmRmOkFsdD4KICA8L2RjOnRpdGxlPgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlw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fyYLebvId8eOHfz4xz/mK1/5Co899hhBEGCtZdWqVfzqV7/itNNOazFwfHaxhzRcGwEc72d72mZvMRGBbLd62BPRzKdYn0rvlifVe6XPetpEd+/uR14IXqvV2LRpE0EQMH/+fEqlElImajOZuwcurwNzYBVOOKyIcTQRtoGL6rioho0jSBzDncW3KwpLoDtxqor4/+y9eZwV1Zn//z6n6q690c3SDd3si9IgSECJIiAuaHCJa3RMcH1NXOI2M05MNCQ6MYkZx4wxEzGZmHGLjnGLy88FBXRUiGwKKLLvNEsvQO/3VtU5vz/qVlH39u2mMThfR+qTV6e776062wXrw+d5ns+jDQQSiQSF30II6PI8c888mH/o/VmPRqOce+65vPvuu6xfv57KykpuvfXWw5ozFiLE/wWEBCvEEQHvIWkYBgMHDmT27NnU19eTSCQYMGBAh//4B/+l7f18KKpSvuuXLFnCvffey5w5c2htbfXVCw9eHssXF/bqesyu5swXFsytCstdd768s67GDYYngyG0fKQuODd07cqfj2B153xz5+j6vkMjbR7p3rdvH7NmzeLNN98kGo1yww03cP3117o2FNoGJFK44VtFppciGnQKLQVaNaGbdtKw7RNa9mzCadlPqr0OO51CarcCUGmQhomRLENESijoWUWPquEU9BqOiPTKuNkb7legmMDfuwjWbB7Ix/LOJLgv7/eRI0fyX//1X9TX19OjRw8qKyv/V8O5IUJ8GRASrBBHJMrLy/2KwKAPFpCX5HSncqwzEpJOp3n22We58847qampyRrTcRyi0SgXXnghU6dO7aCk/a+g66hQ9qU5ZMdzt49Go1mv50IIQXt7O0opIhnndm+83D07jkM6nUZK6ef3BK8NJlN74V3PKDRXdfTuS6VSfu6QN3dneVC2bZNKpZBSEo1GD+tnkUsg165dy3PPPUddXR1CCB566CFmzvwOBYUJV10SrscWWmUIFkidxm6vp2XbQnatXUzrnnU4TbswDQVGFCkcJAojE00UGpQQtO+VCKVoWWexM1ZEpOxoCirGUDFqGoXFFSAKENLdr0vnwPfJ8EiW9lw3RNb5QfY/RAzDoF+/flRUVHQIv4ckK8SRgpBghTgi4VVlQXYpuvfe34LgA2f16tU8+OCDPP74435uijeH1pqqqiquueYabrrpJr8hdL7QWD4l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ejEZtpKikbuk6HcY6rHe7bUSkdEv9WEfgIh8sCrDQ3I0BqBQKBAEAS+//DLXXXcd55xzDtdffz21tbVDjjQlw0x0/csvv8yBAwc4/fTT49GjvXv3smLFCmbOnMnKlSuZPHkyYRjS3d3Njh07aGlpIZVKHfQolrU2DmnRcVSOPA11WfI4K/+NXoe3336b119/nenTp2Otpb29Heccc+bMoba2lvXr17Nu3Trq6urIZrMUCoX4eFpbW/nsZz/L4sWLGTduXNlIV/RaRa+JiIwdClgiY0AUJtra2mhvb49rg6JAEgQBqVSKbDbLAw88wFlnncVxxx1HX19fWUBLpVLU1tYyc+bMOKRs2bKFa665hl27dvH73/+eBQsWxLfdv38/NTU1ZXVbTzzxBCtWrOC73/0uV1xxBdbaYWuUohGxtWvXctttt7Fs2TIuu+yy+LhzuRxdXV10d3dz1FFHld03Gl2y1pLP59m3bx8A06ZNi3/3VCpFe3s7q1atYu3atYwfP558Pk8YhvT09HDHHXfwxS9+kUceeYR7772XbDYbB9ToGNrb2+np6eEzn/kMtbW1vPDCC6xYsYIFCxZw3XXX0dDQUFaXJSJjgwKWyBjgvSefz/OHP/yB3/72t6TTafL5POl0uqzIvauri76+Pq688krS6XRZrVVUtH3GGWdw66230tTURD6fp7m5mcWLF7Ny5Up+/etfc/PNNzNlypT4MaM6JO89bW1trFmzhp6eHubNm/eugSMKhVu3bmX16tXk83m++MUvxnVYBw4cIJPJsHbtWtatW8dtt91GU1MTxhhqamqAYs1WT08P3d3dLF++nMbGRu644w4KhQK1tbXx83R1dQFwyimn0NjYyLZt23jqqafI5/Px402aNInLLruMefPmxaNSb775JjfddFMcvPL5PHPmzOHEE09kzZo1nH766XzpS19SPZbIGKSAJTJGpFIp5s+fzwUXXBAHrp07dzJu3DimTJkSh67W1lZyuRyTJ08mlSp+RER1RtZaZs+eTTabjWu5jDF861vf4plnnuHhhx9m4cKFfP3rXx9U5G6M4c9//jNPPvkkS5YsYeHChfFjDCUMQ/L5POvWrePFF1/k6quvprm5mTAM2bNnD3feeSctLS20trbS2trK1q1b+fWvf81pp53GeeedRxAEvPbaa9x9990sXLiQPXv24L3nqaee4sknn+Siiy6iubk5nrpramripptuoqmpifvvv5/nnnsungotFArU1dXx6U9/mtNOOy0+7ldffZXa2tp4hM57T01NDYsXL+Zvf/sbd911FwsXLqSxsfGgivpFZPRQwBIZ5aJgZIzhzDPP5JOf/CQAL730EldccQWLFi3iqquuwhjDvn37WLlyJZ2dndx2222DCr6j6cRMJlNWAD958mR++MMfcskll/D444/zhS98IQ5l0f0OHDjAmjVrmDJlCt/+9rcHtXqoLDA3xtDT08MjjzxCfX09Z599dnx5Lpdjz549rF27lrq6Onp6erjxxhsBmDt3LrlcjtraWtrb29m8eTMPP/wwPT097Nu3jxtuuIHm5mZ6enriY4y+GhoaSKVSZDIZgiCgpqYm/p1zuRydnZ3xiFc6naa9vT0e5YpuB3Dccccxb948HnnkETZu3MiXv/xlBSyRMUYBS2SUq2y9kEqlSKfTPP744+zcuZNjjjmGcePGkc/n2b59O//4xz+oq6vj7rvvjuuUcrkcu3fv5vTTT+fcc88te7xCoUBXVxfz589n1apVHHPMMdTW1tLd3R3XevX29jJ+/HhuvPFG+vv7aWlpKTu2oY7ZWsumTZvYtm0bLS0tfOQjHwGKRe/Tp09n1apVrFq1ijvvvJNcLkddXR2//OUvOfnkk0mlUoRhyEknncTPfvYzbrjhBp544gny+TznnnsuN998MzNnziQIApxz8crHnp4e6uvr4+Po6+uLX4MDBw5w++23c99995HP50mlUrS2ttLd3R0fczR9OW3aNObOncvDDz/ME088wfnnn69wJTLGKGCJjAHJFXPee/bt28df//pXZsyYwamnnhpPGd5///309fURBAF33nlnfP+enh7a2tq44IILOOuss+IA09fXx5o1a9iwYQNBEMQjZYVCgf7+fnbv3k1HRwcrVqwgCIJ4Bd69995LGIZcdtll8YhaZQAxxrB582ZaW1tpaWmhrq4uvnz//v3ccccdPPvss0yaNIne3l6cc9xyyy185zvfYfHixdTU1LBp0yZ+/vOf89Zbb1FbW0tDQwM7duzg1ltv5fLLL+eEE06IR/jCMGTr1q3s2rWL7du3E4ZhHJiiUaq2tra48N8YQ19fX1zvBcSvcRAEzJ49m3Q6zaZNm3jnnXeYPn26RrFExhAFLJExIPlH3TnH6tWreemll1i6dCnNzc1kMhk2bNjA+vXrWbBgAcuWLcMYE0+VPfXUU/ziF79g5syZZDKZOJB47+ns7KStrS1uSeCcI51O09vbi/eeXC5Ha2srqVSqbPVdVGOVnH6E8r5Wb775Jt77uKVDMqAEQcA3vvEN9uzZw6OPPsrVV1/Nxo0byeVy8chUXV0dU6dOZcmSJdx1111MnjyZb33rWzz77LPx43nvSafT7Ny5k6uvvjqegszlcvFxRdOHP/nJTzjppJPiAv633nqLpUuXDuoY771n1qxZ1NXVsW/fPnbu3Mm0adMUrkTGEAUskTHEOcc///lP7rnnHlKpFCeddBINDQ1s2bKFn/70pxQKBS655BLa29vZuHEjP/rRj5g+fToPPfQQ3nvOOOOMeMTGWkttbS0XXnghX/3qV8tGfKJ6ru9///vMmDGDn/zkJ0yYMCFucRAFoIkTJw4ZOqIA1tHRQRAENDQ0xKNjYRhy1FFHsXz5crLZLL/5zW+w1rJgwQLOPvtsrLVxcf7HPvYxfvzjH9PV1cW9995LJpPh85//PGeffXbc5wsgn88zfvx4LrroIhobG/nXv/7Fn/70pziAhWFIOp1m4sSJTJ8+PQ6KXV1dZSshk4X/jY2NZLNZ+vr66OjoAN57ayARGT0UsETGgKhz+/bt21m1ahW7du2isbGRKVOm8MILL3DllVfy0ksvcfzxx9Pc3Mxjjz3Ghg0b2L59OxdffDF///vfOfnkk5k/f/6g5pmNjY2DGmlGq+nS6TTpdJqmpiamTp1aFjCS3c8r2zWEYUhvby9tbW3U1NQwfvz4QY1GJ02aBMA3vvENFi9ezFFHHRX33Eq2lqivr6e2tpZVq1ZRU1NDTU1N3KIhahhqrWXSpElceumlNDY20tTUxEMPPRQfYyqVoq+vj71799LR0UFXVxfZbJZdu3YNOQIXhc/Gxkb27t1LZ2fnoNsoaImMbgpYImNA1Dhz9erVPPPMM0yZMoVcLhe3QXjzzTf5xCc+wfbt2/njH//I8uXLmT17NrfffjvXX389PT09XHvttUyZMgUY6Kq+d+9e+vv74+dJBpv9+/fT399PLpdjx44ddHV1xSNcyf396uvrmThxIjCw12D0+FExeTSdF63Si0aQwjBk6tSpNDU1lT1/dJvoWKKaqMrjTKfT8bRm1McqGrGKasmcc/T399Pe3s6NN95INpuNQ2Z/fz89PT2DOslHv0P03LlcriyIKVyJjH4KWCJjRCqVorm5mS9/+cv09vbywAMPYK3lvPPOo7GxkTPPPJNf/epXrF27lpaWFs4//3w2b97Myy+/zOc+97m4yScUA0rU6fz5558vG9VKhpXdu3ezf/9+li9fHq/GS3Y1D8OQRYsWcemll1JfX182zVhTU0NdXR35fJ7+/v74OaJieijf1Dn6OZLsr5XcuiYZ7qLfJVpJWLnJdSqVolAo0N7ezsSJEznzzDPJZrNAMSh1dnbyzjvvlO3TmAxffX19ZDKZuEC/kkayREYvBSyRMcBaSzabZenSpZx33nncdddd8cjNcccdx0c+8hHS6TTLli1jy5Yt3H777WzevJmNGzcyc+ZMrrnmGqZOnRrvWxgVwDc1NfHRj3500HSftZbOzk7efPPNeGudbDY7ZKCYPHlyWfCJbhN1T8/n83R0dJQFoGQIqpxyHC6wRMEnuYVOMrAVCgXeeOMNpkyZwp49e8jlchhj6O/vZ8eOHTQ3N3PdddfFU5/GGN566y0eeOCBsmL9KLj19vbGU4mNjY0f4P9dETkSKWCJjCHjxo1j/PjxAPT398cjQOl0miAIWLBgAVdccQVXXXUV99xzD5MmTeLmm2/mlFNOiVfbRSEmnU5zzTXXlDUyjUaDoiL3pUuXMn36dG699dY4SFWOEkH5yFNSQ0MDhUIh3kcwOYU4lMpwNVx9VHKq0TlHKpVi9+7dXHTRRfHoW3d3d7x/49tvv81ZZ53FxIkTy1YfJvuKVYa9qKVDfX09EyZMGLTKUFOFIqObApbIKJccWYr+oDvn4u1uohGnAwcO8Nprr7Fhw4a4Nqq/v58nn3yS5uZmWlpa4iacUXBJTsNVTtNF/wZBEI96Rf9Gt0+OfFVeZq3lxBNPpKamhldeeSWebkuOFA3VHqGy+3xSciov+ZzRY82dO7esSerxxx/P448/TmdnJ/PmzYs3xQbikJnL5SgUCvEIWVTX9eqrr8Z7Lh5zzDEKVCJjjAKWyBgSBZAgCOJQ0N3dzYsvvsjf/vY31q9fz86dO5k7dy4XXngh69ev5y9/+QtPP/00n//85/nc5z7HCSecwNSpU+ORnGiqbahGocmareQoV7JuKjnqk7yv955TTjmFpqYmtm7dSmtrKw0NDcOOelVODw7X/iEZvKJwmc1mmTNnDj/72c9oaGigr68PKHZyv++++2hqauLUU0+NN4/es2cP1lreeOMNCoVC/PzRas3u7m5effVVnHOceuqpNDQ0qN5KZIxRwBIZ5ZKjVtH3hUIhbhS6ZcsWLr/88rgZ5uWXX87555/Psccey2c+8xkefPBBVq9eze9+9zvWrFnDueeey8qVK8t6WCXDTnJkqLe3N36e5PEkVwQOF7jCMOToo4/mxBNP5NFHH+Xll19m1qxZ7/l7HuzrET1nXV0dl156KQcOHGDGjBkYY6ivr8d7zy233MLzzz/P9773PWbPno21lv/85z+sWLGC/fv309bWRnd3N9OmTYtbPwDs2rWL5557joaGBhYtWjTo+BS0REY/BSyRMaDyD3o2m6W+vp5MJkNLSwsf//jHOe2007jyyiuZM2dOXPg9bdo0Lr74YpYsWcKf/vQn1q1bx4IFC+JVccONykSF3lOnTqWurm7IAFV5bJV9tADq6ur4yle+wsaNG3nwwQc555xzhq2/+m9E03zHH398PMWXnP5csmQJW7du5Wtf+1pcu9bU1MTRRx9NX18fEyZM4LOf/Szf/OY3yWazcfH8K6+8wrZt21iyZAmnn356vDpSRMYOU/PYssGFCnIE8RgP+ABvABPijMMTkC4AKYvr7uWW477D/85ehCfEGAvoDFmKkjVLUTjZsWMHe/fuZdasWdTX11MoFMr6TVWOSEUBoaenh1QqRSaTia8frrA8DENef/11amtrmTZtWll7hfeaLkuuFHznnXe46aabWL9+Pffccw+f+tSnqvPCDHHMlTVh0RRqJpOJC/yj1yO6XzqdLlvd2NHRwdVXX80rr7zC6tWrmTNnTtmInYxt3juMcXhvAIv3IdYavLdgDHdsfYgV2+7FjM+A/jqPaBrBEhkDki0QAGbMmMHRRx8dh4JMJhO3L4i2sUkGoOiyqMnmcKNR0WXR/WfPnj2oEP1gRLcPw5CmpiZ+8IMfMGvWLHp7e9/nK/Hekr+79z7eUqdyH8Ro9WFyCtRaS29vL6eccgpLly5l1qxZZVOgmhoUGTsUsETGiMo/9NGIVvIPf2ULhWQ39OTo08GIektV1lrBwdUgJY9j/vz5fOxjH6vq9GClZDBMbgWUDFvRisNoNWRyX8XotZs6dSoXX3wxmUwmHhE82N9ZREaPD+7TSkSOGMn+U8nWDMnRmmjEqLKfUzJoVbZiqAxbldvBVLZlSN7+3YJa5e2iXlPJqclqSo7KJTeLTtZkRdclR/iSX9FlqVSK2tra+PWObh9NK4rI2KARLJExIBl8omadyTYKkXQ6XfbzcAXoUeAarmAdKAtlUcAb7raVKntZRf2lPmjJMAmDW0EkR/SSv1Oyx9hQNWzJoCkiY4MClsgoVxmSDqUWaKjeUu9Vg5W83ft1KFOK1XyuoX6/4erNDuYyERl7FLBExoD/tgfTuwWo4VSzmPvDCisKSSLyfqkGS0QOyXsVuSuciIgoYInIIVKAEhF5bwpYIvKBONh2DiIio5ECloh8IDTSJSJjmQKWiIiISJUpYImIiIhUmQKWiIiISJUpYImIiIhUmQKWiIiISJUpYI0KWq0lIjIyGPSZPTYoYB3JvAUM3hh8xfsx8OCxWB/9L/R44ziUN666FImIHD6eqH1J9LntsNbiSx/whtJG48ZgjFWrkxFOAWsEMH6o2GQqbmMw8WUH96bUW1dE5PAZ+MwdOL0t7t1ZeenAdTJyKWCNFD75rQFvyv7vmfi/ik0iIiOa9wpXo4AC1gjhk2c4BjAOvPsQj0hERN4vTQOOXgpYI0AyXHkA7xM/OcDz7lHLD9xXREQ+VA6DK01EeE9cgxUxxih4jQKpD/sA5OB4U4pUpjQJ6EpxyXi88XhTjFpUDCsX36OeaOqwMmTpLSwicnh4Xzzd9XgcpjTCUayedfhBIx4GnRiPZBrBOpKZ0riUNxgPpQiFBywpjA/x3uOMxXpXug1giisPi+nKgw+BsDil6B0eR7zeUO9eEZEPWHG2wZhiDa3DYo3BlC73gPUe46CQAnyAd6Y09yAjlQLWEW3oiT+LxXgIrMUbT+g8zpjim9eU3zN6g0bjV8URLY1biYgcbi7xeRytDo8/ko0BY3H44gmyH+4vgIwUClhHvGSPhmJfrOikxpmA0FhsEFCwAz1WollCXxrr8qbYZ8X4qN9KYrpQWUtE5DDxRF2wbOmjvVjeYeL5Ces8zhRPoI3+RI9o+r83QlkTEFJ8uwbeUPBuICsZXxp6jrJYqWFpsQCAgSoADT+LiBwuw00gRKe8xZIPF9fSGrVqGNEUsI54AyNWprRi0BtDGBY7AFsMJnT0+Dx5fNxsNPkeLo5UFVelFMevTClyafhKRORwieYPogVLAMbb+PM4Zx1dPo81gHP6hB7hFLCOaKW3nR8ITQZfWlJo8a641NemA17v2M3+sBPvCuBCjHeAK54RUfGGLj6q3rwiIoeZp7Tqe+DcGe88xnj2uW62te0ilTKE1jOwcklGIgWsI5k3ydOc6EIsnnTK4pzHOYepSbFl1+ts72kl74uXeecwvjgJaOKarNJXsfHKwIUiIvKBG9TBsFQz6x3knOPtng5e27OjtNowxFVuQisjigLWkcw4MMWCx6gRnfUG4z19LoexKQJfLI/ck9vP5t5ddAEWg6OAL223YFzpDW0MzpbaN5hi5xWdIYmIVJkfqIH1icscxc/vwDmsLy0TdMW41e8NL3bvYXd/KwQe60OMCz6c45eqUMA6gllnwZvicLKNRqM8AQZrLSEhxhpC6+gZ5/n7tv9HZ6GL/sCSs2lC70jhsBSL203pK2oE770d1EFYRETeJzN4d9iolaEJDc4UP9etd2Dy9FvHDneA+7c8Svf4EGfSQBpj8x/O8UtVKGAdwaIqKV/qCOpNsejR+WJVlQ0Mxni8c/TXwjNtr/LUO6/QZjy50JIKUjgXEuLK3ujGlH+JiMgHqdicIbAGrMGEHusNfTh6A0+3CXly1xZe6N9JZypHiCuWemiGYURTwDqCxY3Zy5qFls5+vMO5Aq4QYkKPDzydmX7WbH2C17p2ElqHDyFwBusDii3uSlOC3uF9GH+JiEg1+cS/AyGp4EKcC7HGYp2hxqQIvWHLgR08+NrTvBP2kRpXgwkKGOsIvf5Ej2Tai/AI5kqtfo33pREoizPFNg3GF8+AjLFYA2HoCK3jub63WP3KQ3z/f85hXs10gnRA4CHw0c45iTLLaBWLV79gEZFDY4acAfC+PFQVlcoxrMU4T+gLOFuspX0p3Mvvt6xnU882zDiLdwVcWCBlUlhSgE6CRyoFrCOYN6Wuv8lVgMbiKf6Pcx7CqADeGJzxtGV7eHDPs+y1PVzacg4Lsx+lwWZxPmrMUNr4OdqnMH5kERE5eJ6h+oBGK7VtfEJr8Di8txB6wjDEpC37fTebcv/hrhf+zv91vEp3XY7QWLxzQArjDMbo5HckMzWPLdNf1xGnFJIAvC2tBIy2EPUUrCdVMMzJTeLCY89m0TGnMSPTRMakigsTncdaT4oQ7wvqhyUicqj80Cv8vIGQkMBBqtRpJ28NOeOwZDDOsa13Fw/ufZHfv/Io76R76fV9xYfzIeDAGjymuCehjFgKWCPS0AHL43CmQApLIXSkbA11nQELGpr59KRmjp0wnVkTZzIlNYE60tR6W3wso3l+EZFD8a5bjcVDW8WZhT4KdPb38ELr67zUtZv/63iDTa1vUBgHubCPdDZDwRWAYsNRD2AtzqtQeiRTwBp1HKkQsMUVKmmTJtPvGJc3TMjUMzU7gbpgHJag2IcFr5UqIiKHaPhPTT9wDmwMHk/Bh/Tl+tnb38le10t3xmHThsA78qa40tvGLXN8cfSK0vZm2o9wxFIN1ihigCBME1pDiMe6EJ9y9I5zdDtDqz/AW7kuDFCwDmdL7R40zS8icmi8HTJkGRMtI/IYY8CFBBgCE+AzBlKW0BUoAIEBEzoCY4qTEaXHNdGOaApXI5oC1mjiDUGYKu4z6AsYGxC6kGLPLA/OFcebvSHli43inTGEVvP8IiKHZujNmA0QlEajQjwEFqyl4DxBCD5XoMYaMJD3IWRSFPJ5Ah8MbI1GsfLDGoPTIqQRSwFrJPImscWNY2AbaEN3Jk/gPcb54vLDaCVLwRc3jfYWZ4PSEHSxBYTm+EVEDlFUwzrUVTi8MXFA8hTDVgaLN6Z44msMxhpy/f2kMzW40GNLn8amtIms9x6tQhq5FLBGIlP5w8CG0NYUe6aYVLHjuy+NUKUKKaw3eGOL21+V+mAZY3BGfVZERA6NZbj044tLAgmMBedxBY+1KXpSYL0n8AEFE+KtwQQpQuew2GJrntL2aL50cmyUsEYsBawRKXnWZMout97jjKEAeGsx3habjGKLm0bj41HoaBDMDrPcWEREhnEwPaq8i9sOehzGWzyGgnGALfV79lhfDF7eEH8wewwYG+/kISOPAtYo46JNRr0h8IagWMeOs+FAsCp9DWQznSGJiHzQ4sqOUp/n6Od4xCph6BJ6GUkUsEab0t5VloE3b/S+daUL4st98drKN7aIiHwAEqNeAx+7xVouHxfND1TFRqsJZWRSwBplkgXrzhS/oDhFaIc8IdJZkojI4RDFq+QMwsAolkEtCUcXBawxoLQgpTgqbcovj8eqRUTkAzXUYJQvpa2hToA1ejWyKWCNMlHTBjtode/A9GD8ptWbV0TksEmGqHcPT4miLG34PGIpYI0y0RShznxERI4sB/+5nKiAlxFLPSZFREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREqkwBS0RERKTKFLBEREREquz/AwAA///svdeSJDmSpvspzJwESZ5Fmk61yMjKnr091/sU583P1cquzM5Md1cXyUoW3N0N0L1QAAYzd4/MrI7eLqKfSGZEuBuFEfxQBhdYjuM4juM4D4wLLMdxHMdxnAfGBZbjOI7jOM4D4wLLcRzHcRzngXGB5TiO4ziO88C4wHIcx3Ecx3lgXGA5juM4juM8MC6wHMdxHMdxHhgXWI7jOI7jOA+MCyzHcRzHcZwHxgWW4ziO4zjOA+MCy3Ecx3Ec54FxgeU4juM4jvPAuMByHMdxHMd5YFxgOY7jOI7jPDAusBzHcRzHcR4YF1iO4ziO4zgPjAssx3Ecx3GcB8YFluM4juM4zgPjAstxHMdxHOeBcYHlOI7jOI7zwLjAchzHcRzHeWBcYDmO4ziO4zwwLrAcx3Ecx3EeGBdYjuM4juM4D4wLLMdxHMdxnAfGBZbjOI7jOM4D4wLLcRzHcRzngXGB5TiO4ziO88C4wHIcx3Ecx3lgXGA5juM4juM8MC6wHMdxHMdxHhgXWI7jOI7jOA+MCyzHcRzHcZwHxgWW4ziO4zjOA+MCy3Ecx3Ec54FxgeU4juM4jvPAuMByHMdxHMd5YFxgOY7jOI7jPDAusBzHcRzHcR4YF1iO4ziO4zgPjAssx3Ecx3GcB8YFluM4juM4zgPjAstxHMdxHOeBcYHlOI7jOI7zwLjAchzHcRzHeWBcYDmO4ziO4zwwLrAcx3Ecx3EeGBdYjuM4juM4D4wLLMdxHMdxnAfGBZbjOI7jOM4D4wLLcRzHcRzngXGB5TiO4ziO88C4wHIcx3Ecx3lgXGA5juM4juM8MC6wHMdxHMdxHhgXWI7jOI7jOA+MCyzHcRzHcZwHxgWW4ziO4zjOA9MnMY2lKAKI2j8QJC+kYt+Tl3Ecx3Ecx/nloIgIiqCqqCoigSyHmsW0WqaCZmUk04WSgAJ9h5JUm12ACAQFUUHUFk5iqweF6HYvx3Ecx3F+IUTJRqYslIoGQqBKJEn2I/99yOQkSl2h72JEsoCa7kxAbFcJSGG0brm+chzHcRznl4Jmq1NISlDokCyW8nciqNoy8/XsvyyiFLr8XR9Dyp+ZbKpuwuwShFAtWoC7CB3HcRzH+UURNEA2IAlZSElqPHiSxZXWn6L9vuJq6IeQlZc5Eem07EzMPAaEYuFSCKi7CB3HcRzH+cXQp/xLtlgl01skUVRAsttPGkU1Sq4RlepPpBft0aLIVEgKASEho8UrCywNasKLhOM4juM4zi+BkIPbCyauSviUgip9jtAaXYexegfHNRPZF0jfRyGJ6bBUNyp0CiGHwqsAIUFWceoWLMdxHMdxfiGUzD/JcVZFSIXq1TP9syAQFFSVbQdCspj24ghsQqz6hSo7VbQL1e+YgrKTgU6Uni7vIJklCwXtkazqVJUggiY1X+InIlq9kxMz26duqd3Ose8L43KjKW+OHvzUcRzHcX7dfKi//TEc741//LYOIQd7d7Ne7bLxaKFCH6GnCXCXAQViKpathIZAoIcYka74FJUgHQGhX+2EPggRGDSSgiI5XTFK4i4oBFuxS4FOhSEoJKsZISGYO7ED0TQRMvVk72mx9ru/p2E/dLEPf39cRt23uWNruShzHMdxfuk8tLiCh+0779/W4d479kIiEdSyBSMgYtompi2RAP2apB0aEqo7QhzoFZYskC0E6ehDjwyRjkD//3313/nf3/+Vv1684p3ccbMcuCYyiIJ0FlKvCYmWZ6ga6DTHYKllGcYcw9U9UCvVGhP/cLXy43ydY37lSPG6Oo7jOI7zafwjrGKfRFI6Lf24kjrz2CUUZEHXL4ga0LijU0U0wm7FSjrWu8DpRvjt8gl/evIF/+WzP/H5k5fIv8U3ei0D3w4X/I/Xf+H/f/Xv/Ofl97zaXfJ2uOIy3jB0A9opqRMTXjGZsivFSKFWM/3UBipBZSIy+cwKo378xh7SvPghEoelmVuwHMdxHOefy7E0vKZa1b720JB1jUWji1gIFKGHFOiHSB8TiwSPwgnn4YQn3QueLU/5b5/9kf/3D/+Vr5ZP+VxPOA+nrMIS2SVTM4MqiciGyJvtBV9fveJ/X37H/7p6xV+Gt/zl9ge+2bzhvd6RgG0a2EokFpeiSJ1OpzD1Fh6Ic1IlyGgRKsuHe9Yp262R/OQsR6bpk+OSJbUy1/maTwOE7onC+/y3x4/KcRzHcX5ZPLRH6Vj/2hpJ/t5dHY6qLhMCtkuMS3apIyRTMREIIiylZ0nHiXZ83p3xu5Mn/Hb9jD+sv+QPj3/Lv66f8+Wj5zySJWtZ0KkQsr7oAIkpaS0Pr1aqfSdK1MSAckPiarjj9d17/nL3PX+5/oH/uPiWr6/e8HW64JVe83p7xYadFdGSWqIrl37QnJmYBY6MqZAmsEzgqGqtJi8ieZoeqcuVz8ECzILOBFZJpWwvn4w6tksWxM94tvkYtdatUNnbwkECfHKsmeM4juP83DjU1wG5NtTx7w5+zj0CS4oxpCl4LnLcHHVkP6pqVdjrJ2OBq2qMkYBIl6svmCZZDLCMwuPulCfdGc/DGX84fckfz17w1fnn/Mv6Cz4/f8Kz9RlnuuSEJSFAlyu/i4S6/YCVfRBtCz/kg0iqqAo2W47kzxI7BnYpcZl2vI63/G14x9ebd/z7xXf8+c23/HnzDW82F7y7ueJGd6RVx24Bu94aT5MiCSRFCBAFJAaLvg9Z7IzTTtOrQiqNY4Ir5LmBIokkY02K4jel0ahJbB8JpZPRgWcplWbv6nT/gkvWifGA008Fuibgql3in+5DdhzHcZwHRJNU44ZkOwxYfz1VWCGXKLAinWBlDVrPUjG9SBZnqXwbhJC09uUJRQloECRXKEhAUqUXoUNIMdGJkFRJQax8lCY6hEGAXWKhQtd17DQSO2URFixisKy/zcBqUB53K56fPuLz5W/4/dPP+NOjL/nq0Zf8bvmcl3LO027BSQisZEGHgIQ8R6EQpFEIB2KEDgisvGxjNdL8t+ayDGlQQhBCECTALQMX6Y6/3L7ju9t3/OfN9/zb3Xf8z6tv+B8Xf+X723es+gWxE4vj0gElWcYiwfYlakHy0S5gCkKUga5YpkKe5TqCaCB1JsKCKiGaIgoacg2LaOIqBFIIxA66uBtPup5kQBoLlqllHd2PMg0qK78WITUPdneB5TiO4/ySSG3Qjo79p4rWKucVFSTP4deG8UAWVwJBTEhpUqurKTY5TRTFihuYwIq53xcxA08EOhE6TQRN1v/GwEI6+z7YHMoigY7AUjqIiTgkutATFNIucqJLfnf6nP/27Pf8l9Pf8K+rz/jq8Wf88eQpZ4s1nQaCdFYDKwpdCITiNZOsQwCVQP+BtrtXYE0CzxlFVtBQBQYkSEoikULPDrhjx0Y2XA5XvL57xw937/mf77/lPy5e8Z83r/khXvFebrkcbrliQxIYSKBKCB0xW480ZL9pDjoLdmAEzOIVNWVDYMiR/h2oFUmVVESSXdWhH6q6Dkq+CSxuLJa7oKj0slxqnYn7gfyt5dJrrzqO4zi/NKK08cvTeYlFzdakkxqYCim00UKjQSJbrkLxU2VBxrho3UZ1Jwbr35MmpDN3nqgl2mkIMCiC0HdLq3awU5YaOO1XPOlOeR7O+P3qKV+df8bvzp/xL+ef85uTZ3y+eMKjcIrQoxLo4o5F6JCkdJLLeqYEElDJIUak0U+WLWn3cVRgFXtXK7QUc/MVJSoIqsmESpDa2DZBtFmYIomdRm7Y8n645T0b3gxXfH3zA3+9eMXXm/f8cP2O72/e82Z7yevNJTchosuOrUS2wdIlRZQuJYLAcpfQQC4lUaxdkLRcPMk/7TQUU8HTILrGcKnj760aD+hEsZdWcYHlOI7j/BpIuQcsFqnQKAYVtX5QSgyVfdnnWlKT7TTGibJFQYv1pibKqZTvBFLKSiQQsixTApIESYllEjoV1rLkxfIRv10+4YvVY/50/pIXp0/48vwFn62e8iKc8bQ74VG35Izs6quuzvKvoxMzzphlTpFkXrYcwJ11jRVdtyO8v+f/oMCafKIJ1UQMYzBap0CxaOXG1kbCVLWXApJyLS0SQ4hsJXIbB94PG74Z3vNtvOBvwzv+7c03/PnN3/j+5i2v0w3XumOXtqQU0QAxiNWo6ISk0WLGOosZC2qWMDstzRc+sBh6QC3uS5pgt0ZB281EDdRXSaOp80ALucByHMdxfg20bj/RXM08mBgpFqdCp9N46NYapZq9YaJN3xpIEim9baCji0KXoFelGxLL2LFgQR+WnPYnnC9O+NPZF/zry9/xx7OX/G7xmN8sHvGsO+FJf8oq9HTaIVEIXV/jx0KwwHYUNCixxGGL0mutN9D8X86gYD2/ZNfm/W32kQJLNYFEa7QIMcAgZi3qaA9qjNkStdgoFUW0p8bE5SDxYlpUYAhK0oEkVrb0jh2v4iV/vnzN/3rzDf/x/jv+/foV3+4u+U5vuNjesukTWxlIISF9h6RoAqs0QCuB1LylRViV39HUBPObRTAFsw/mChbZNJosYE8sDVPFAu48BstxHMf55TL2o3MLFljfGRsBIiLsGBDCmAkIuc8POcks2XzHKtavKmz7YJaqAfpt4DQuOA8rHsmS590JX52+4KtHX/Avz7/kX5/9li9On3KmK85lSVCzNoXQZ7uSzRcYzMKCJpuUOQTrrTUIuxQJobOQIoXEYP29dCCSnYFNPHZuiyIIDwW1z7lHYE2xQHQTWNWmUwLhyT7WlJAQoCRJJija1WadlnpgkjMAh7oFyzgwn2YkpQQhEBG2mrhlx1vZ8EO65buLb/n27Su+3b7nm9u3vL694N32mu+2F1zKjl0XuQsDg1hFetWEWAi9nUvJZRALiK82t6xkY/a5lkYN2YRJ9vtm+9bERmdnIY1mL8vc0/i1dY5/1/5dWvP/noabiezZsfx42rNxHMf56XLoPTz9dh5EcqgP+JS35vy9eMw/orNja0RO89f8CGvguUzz+7R2OvmYc6acSrQAcXKOv4TRWIJCyH1rymFFYglqIYesi1pNKUFIarKgU2GBsNTASepYROFFd8aj1SnP10/4YvWM35+85Muz5/zh/Eu+OHnK07BmRWBBxwlCn7BAqZQLn0tHyrHaKiV8CbOaodiEgMHKKGiO6S4yKh+fJs3dvtT+v9jZlET1d019nUf5NIFVfpe2sx1LJWiOcxJt5UGq65TtiAVw5YNvbh5VuyC5cRCbpTrWWlq2tx2RDtjowLvdNW+217zaXPLDcM0P8ZJvbt/w56tXfL+94GJ7y+12w43ccRM33KYdsbN5h4aO6l/VtIMY6SQAfdWpKuNtLPkYESGgVckn1RwRJxNRVX7XRsXvi6rjkqn95mMF1jw54e9jvMrHbpIftycXWI7j/Hj+UQPNQ2IkNR/I3tL501oUqjFAVBvI6Ab7uHfexwmsVl5J6Why3DCEsc+tKyiEbDXKf6a8fBAhSZEQSsBKNankYHUSUZO1RddZtn209Sy5TK2MUu4DQwcSA2GrhKQsVTgNa066BSeh59nijMfrR7w8fcYfTl/yxeIJn3XPeLo84fPTc14sznjEgqUscl6h5PAjLACdaFohZYsYVtEgd9ITcXn4RlECsWlfYS6FrI0UJNi/Y5u6h48WWJSdld+zyqs+VJ3r6bJ88VfK5PPxbwuIT+aYNQtRcZZml5ud5Hh2RQWHZPFWscspnUkZSAwMXA4b3sVbvt9e8ubmmq9vXvF6e8k3m3d8s3vP15u3fL+94GrYMARIC2HRBbohshyULgTuuo4IbHVLEqxeFxDiQMiuwpSwxg95okhSznq0NulE8o2cRWVxReaHTTA1PW3X+UWaXYd7rrLUt8F0VKUzu+7kVaCHH+ByXeeU9Nz5svPDaoXkoe/LUvIj/KruinUc5zCH3inZVRSGI+scf0OFNH3fTMsSHHh3Sho/L8Wu898q6aDE2tt7u12ZH3P5bjxPnZUUSiGZcandpGoOzi4WroRKrneZIKQAXUdKCWWwvkotYz+lZEadLltXVFENqHQsBmGhncU77SJ9BPrAGSf89uQZvzt/yufdGZ+tnvDlyRN+c/KE350+43l3zqJf0Hc9C3oWrLNlycwuIWsBSzbL5gqRbA3LsdaE4iPL3iXJRp79Vi7NUwpBjD1UqO1TrsZ4/5hB5VOm7Wv5UQJLNWaTXBMeXhqgNY9m5YvaLNPz7ZiQKirSzIdFYGW9xcT/m3t8iaBdqPu320/rOlawLCGd1cEagFtgS+SOLVfpmje3F7y5ecefd2/4y7vv+evFa76/ec/frl/zevee7VKRRU9cBFhZRuMQB1Ia7KJnX25IY/NZFqNACEgoQkpJKbFmIKXi1w2jRavx9c7b+uEsUccoFVM/bj+TmiZHVplPqzCWiT20l/Ktpwg4jvPxmMfk2NtlHszQiI9mdo/59oCJ1efj377FgnVPyfEP8jABGFrdWtFim0rFzyA2A0oKNeYoipJCIGmywpsLIUZ7K/e90IsgA+wY6EMghEBKiTQoC3rWUTi7iax3gaerx7x8/hmfnz3lt4+e8/+s/sCzk8c8P8mVz2XJCQsWLFkQCCkhg4m2TgI9AfrBjDRarmcgqRAY7FqrWZpMS5huSIIFrNMacT520J6vVzF9NVJo2vceC+SBD/VdP9KCVQRS+dw+E5V6gW2BcqPmVMfJNsq6qYq11u04bhcQrQ+AGbdSo0Et06B+ma9NyibFagqNtp0g0CPV9bdhx60OXO42/JBueMUNf0sXvNq845tXf+bV5Tve7q55dXfBplO2OnC53bLTyJYBDYkokdQpsRNUS70MtZg0yW7i0AjLrKHt+obx8s3uiTKtkFKLX2Br7C8zksreJ/dEYJ7xUAqsHn+wy+iAJpuyXqGPNCHdv1jK/3+6wHJJ5ji/LsoUJNAKrP2h2353OC4zD9Ael8h2kAMCKxZtptNp0kaB176NWtE339l9782x4PU+RQA0b2AtRi7BxEYyi1Q+wBDDdKq5nEyW1ASNkJO0BLoaJgN96i2COkW6qJxox0qWnPQrTmXJWpY8Wz/mi7NnvDx7wp+efM5vVk952p3wZHHKk7DmKQvWYUlPj2iutC5CSMXClM8zZOuZKpISSbpaZUDTzto/CBJyP6TFqGPXc/SQze8Bu1OOGih05msronTW/OPq02r0+9fmOJ8ksO5jz39ZlfQB19GBZT/mIEZ9mmOb0FxqofhHEyUKqgi9ItbGPIdyXJKD3fKNlz9NmtgSGSSy04GNmrvx25t3vN5e8eb2iq83b3kbb3i1u+D17pJXm/e8STfcpR1p2JE0kTqr/2VxaRb8X0tYiCBByqTdVipCzPXWNpaWarWtZm28pVWAVYtgaJ7+6ePdugHHB3kqsmzbYbJOEVijADR7eaim6bq7vE4rw5pz2bvGbasfc1Eevytk765yHOfnyqEJhUsu+PgmsU+KyFFpexeZbGDShTbC5ZjAkUZczSnhEG0GndDGZh0SWIzv7jbCJZlYKt6Y+uaU5h1a5sYtpYaKcaKIrJx1R7D6kyFZ5nyZusaMaV318IhCSFaAO5EgJQIBCZ0lc6lVAliFNY854eXinBfrM16sznixOOP38pKnqzNenj7mxfoxL9aPeBRWLOhY5cmQQ65wTk5US7Kjo8senbEk0t6bXlON6S49Na0IQ2p7TI0BZemDCuPAZ8eZb73s4dDvn8qDCaxjzCdq3l/gyIof8EeVCZ8nlp9iSWP8sPhmKXFcdTnJVsF5IKLJtIjSqVm8VGGQxJaBLUpKyo0MXKY7boY7bna3vNld8XZzzavLt7y6fsd3d+/4fvuet/GW67jhfX/DLkW2mthhE1srxToptchaIo7PXJkIWyQ/qFqn8ikuypQSKSVCNuGG1E3avRBDKe8/PtQWl5kmL53QCLE+FYGluVI+NYagTpC9d2W6sS3Li0XnAisfQx4BHo0B03T05lZxG5bj/FL4kMDSRpCELHTGZefWHcmp9TrZUmuhmlNiiieSrRha6kCw6YwF0K4eX7MlyO/3e3ZEEQFS3oGY0DHPQ/4s5Iy2UiRb88CyHojm4+ty9n3IfYiwCzanMElZpsA6BdZ0nMqaVQo8kTUvTp7wcv2Yl6ePeXn6hN+fP+dl95hn3TmnyxVniyWnsqRjRcBchj1W42pZI5mkSsCSEDBIwipZiQnSfI6qOchf2mtlzWeRNinXlmJsA5TRhcfe+tO+mw9+3rb9vYwWg/x3MWPev9qcf7jA+qmzb8RtxIkImtJkaUFRjfmOKubKUGfkTihb4EIH3smOV+mGH7ZX/Nu7b3h99Zrvrn7g7eYt74ZLrnY3bOOW23THRdyyRdE+kHqb5JIu0OV5Fu86e8gWNoslOxmyeddKYpREgD52NvFlc8xRLHNT8qzfSWxyTCSn0CabOLsQ1My2qcmcKC+sBKSgtdgsmOtyMndl68tuR2/5745gD5CCEqHG55UpGWzpFFKedLwa8O2MNJGk1CRjsq/YPAdu43Kcnxbzrq218kBjndeU3yMBkWCDzZxZjpTMsfHpL+6n+bg8SbJBYZ7PrteFWeRzncN24VDXt0pKJSi8UPtaVfNAZD9KEhuWWzkfy7pLVg7czi9YL9FJIkmoNSK1BHErEJVEQEK2jOkY37vRO/rQ0YWOID2igW7Q/B4FhgjbgTAIJ92Ss+UZ3XLBkp7ny1Nerh7z2ckTXp494atnv+X5yRNe9I95xhlP6DlDWIuwbCd+afqDmMzbYOUhi+EiNNZCi+8aHaZK729fwAXWvgVmFuhWXHATC5yO5li7yUxhJzFvuGAxXxIEDfZgn9CxIXLLjgs2vN5c8ubmkre3V/xwd8H32wt+GC54o1e83r7n/faK95sbbtLOLF7YAxlJ+Z8JpyDFfKykkEhdz5AGNCX6HJOWUszCQ+pkmmgemamNNZLkTEyhTje0C7saH2dZI9YGvQqLVF5QOrpjRerUBhqyabhaGXM6cBaiobglxQIv7UUb0JwuXEaU2epcz7G8oEVH4VtzambX6VOyLx3H+b9PaxWC+cCoWNfNVlLXEeq7CPJ7p1p0criFju+lcXaOubQrA8BgdveUnVM6eg7a989eDKwmm4NXlBS0Cr+gwiIrR8XCQcz7kKi1lOp7SrLXIGUvgeRS42KZfSr0faBTmwlFo7LSnrPFklXoOetP+OzsGZ+vnvFMznkuj3i8OOWPp494uj7nxdkTnncnnNKz0pAHtIIFa9kcfxKsSmSvRfyVC2EJWGV6GCsaaqI3t16WmDlTvg5ulQ/N0fdrwQVW/anTDrl08I032D4pJtocfF5LSxTTptayE3kwVCentBu2PPAdqHnON0TuZGCrW+50w/XmhuvtLTfxlu/iNa83V1xeXXJxe8MP8Zo3wzVXacdV2nKZ7rjSDddpx1YGhuzOE2zCSlCiJnryyCpbjkqtExBiPi5CqmUxBIiUwqr2cpKECboS95UfwpIwoOUBzLoz5JdXaeckOrp1y6eiiGYL1sR8XuaAGi1ik1TpZitzC9nRa+3PvOP85Ji7c6bvW7Uq3eSkJmnfXOMWsmOu/i0lJgixEIQi1GT63iAPJi30wt5pZc68lC1fga5JUJKmluNQ95z3VGO0NFuXlGATEgOSEgSrtRgIaFQ0pjw9SyBIx0J6TsOSx3LCk3DCaVjxVM55vDrl+fqUJ8tTXizPeLE+52l/ynm/4nx1xtnijCU9K5Ysw4JVjGOflN+lNqOK1ne05BIN2lj+5iE947XR6V9lUJ23k8jbLEv8wzPgfx64wOK4K+lQ+QRphzTNViSbdatlCxlFmwoE80ubNdhGAWV4ZBNRS9Yb49yIkcSNDGyIxDgwpIGbtOMdd1zrlqu05WJ7zbvNJe/vrrga7vhm+4rLuxsuN9fcDluudrdcbG7ZxC2xU7Y9xM7cfCmn6YrmLJKSiVKelJL+io0YJVkwZOqyi7AKrRKIKIRcdaOOIOtDLvWh1tqEVjNMuzylguZWSfYKjaFdFtpCfppGq1l1K7Ri7MD19EfecX6iJM1ZZTnrrMbMWhysZCuJEvJ8dhYLKyL5e8Ms26XzLz+rejArU1FWtZZ3mXvE9qtloCm5cnkKzYCu7CxAntatEHKwuKjQD/Z7p1aUU6NN5bKm52yx4tHihLN+zXl/wuPlCc+XZzxbPeZsfcqz1WOeLx/xrD/nrFvyJJ6y7hesuo5l6FhJYEXPMuVMwaBoKEYCK31QKmcFxjAKa0OpRUlLXG2pHRXqIHlu6WsSn7LhoX3L2nZTFaxWmPNH3AO/QH71AuswJSiv3GyzfLa9Jkv1p4A9UEJNjQUQ7UdTdvmXEsWVXarBl/0NaK2Ka5tMNVhf8otFi+mZhBJJmrjVHVfDHRdxw0Xa8jbe8G53yzfpmrfxlu9u3vP95Vt+uH7D27trbtKWze7W6nt1gbAIRFF2aYf2OflXys9SNK9kQCYkjDXBVCPbUowVqdYtgC5SSpdYyQqKudliwEo8QmJ8wIU2yH02gjoSGH+sEs3cQeA4zk+DMgjNCW32aqwDpWJxCWMIQAlZkPFdI9mrUKY7A3veS+52KO/JsLAYWkDzFC8RZci6bKzvaC49AJGuZhBaMLdZmyRld58KMighwgJYhp5H4dTE0fKUz8+f8eXTF7w8f8qXPOO0W/GkW/O4P+Fpd8qT/oQz6VkIBOnz3L5Sx5NDZyLRpoAZ57+V/IZMyeK/uhyrhhYXatNeuS130tii1KbACSG7SHNGH3nbAjmBqp9cr3nv1zhiKaUUHMMF1gHKA5iNUo2iH6vG2oJFCIyf5qxUyL728piX21K1TIYNIYwvBFUlVOd3KZ8Q0DSarUsQp/nws8k8JXsYQyCpcqeaq8wbSWHAXkY7Ehsig+7Ypg1X8Y6LdMf3u/e8ef+et1fvuNhteL+94WJzzV9vX7Mlchsit2Hglh2btK3xX7s4WLG6zmLDUoqw7JCY54BKCSnB6Pmkywzso9ULiCm3ooB0tUBtSEUYFdP+aDHTPIq99zqy/zI4hOcjOs4/D3u08yAtpJrUUkRWtVCnEo6RoBFdILngJMVQjkKNA5IcPwSJXQhWnzC7BsvEvqqgEsx9lyBEsVhT6TgfFixC4EQCa+1Yac9KFjwOZ5yvTnl6+pjn60c8Pznj5ckjnq7O+GL1lJNuwWm35CT0LOlZEOjosxdEcrypHUdHEW9qlXBK7SqBQXZmDWuGiIJlukeKASCLMlNXdDmBSVPKhrsuK6HsOtRiEQRLHJAaUjwpgaNW0EhzXanxfTqtzijkpAQp0s8BF1gHUU2UWKqKlO9KyYTmZm9M1LZQ/Y/RpFxSfe1hSGovCcnLSi7+No7AsgUo+/ctADOP3CxwoI7gNLsmVZWFZBGS8jhHLG7B3JdmTi4yMYmJL9Qe1p3ARiO3DGw1ckdkk3Zc7u54v7vi3eaK680NN8MtV7trLjc3vN/ecD1szRKWBi7SLZvtHXe7DRt2xBDZ5Um3S3zYIBAlkSSCQJQlJYsnJJsFvfj1x2J+Wn9a82dRJtNvu0QVutoOZxtqIdv9Kz/ZR3Xj7i2hzStEp/8XLfiB/bWj7A/Rrnd8+QPjSh3XESFXgtt/+X3c9qfL37dcya76+G3eN9flz+P11HY8bTc4b6tjZ9M6odqznrfdoeo1bWFmgdHSPN9GPZjqUGNMG9G9dbT9o6yvZcBz6JymV749dtHy3Mp00Ko2V13M56F5BgxR6gDKys8IXdIcUhDRzgRXsd+nPDizd0J27RXrUrLEnI7AUm2i4aUG+tSzDgvW/ZLz/oSzbsVJv+RElpz3ax6tz3m0POFJOOV0seTJ+pSnyzPOl2vW/YrHac2qW7EMPR0WiL6U7BbE3h6hBNfn97wy1Pfb2Db5+onkdsrxvcEs+p3mK1ySropbTyGVjGvMI2Ci0S5UsI3mrMeSeZmztzXU6yjWuVDrEbbdXlmH5s6W8SrXokgl6UjqkNjBBdZBDjXJ8QK8xYM9Mg8Q3Ful/aap9bQfGNiWPMido5SbetxHarbZ55fgvNOs9cDa46gicqyRVUZ/ir3AqrC0Nx6aMxh3mriLA7dpx10auB127NLA9XDHdbaMXciGd+mGd7sbLm8vuby74eLuhqu45ZYtN3rHJm7ZqTJozo6MiRgjO42kpDnFWsaSM9gLJgZtRlRa2y+VzEWhZsRI0uZFZy9elTHrpWuWL/EZY27mVCiMV6MvrVZFsRUrlMkFkOb/YpksW5c8aox10lEmn4sWQT6en21NjrpCx7bII3odr33QcpSzTn/UYkdfjPWezskbs5q4s219qsCaytTJfj/yVT0pDfKALorjwm8mduoX5q4pFpHx2/uPyUoElZtmtM6We6HeA82FsulDytGMAmssHzM9OFEl1MzeMVYJrNyLPQNNceNsLa6DhrpvKYdZ55AtH9uxWtma+u7I+wYbWElxcOUbSbL1XkrMplrV76BKUCHkWn1BYRgigwxoEHqFXjr60LOUnoX09KlDJBC6nnW/4qxbcRpWPOrXnC3WPD15xOPVKc8W5zyWFY9ZcdotOeuWZm3qFpyEbHnqV/TBimUWt12gK/LH3Gs5wUkpFje792vc0/xerFa5UYiXJ7Jk441NXJY4/LSXotXNJa6Eum6R0NM30ZS2+vx0D6r7n0/mFT64vY975n8NuMA6gqrWmkrAzDxbRIhWgXXspV4b90gzl5EWHOoYSizYx3UeubvPQmi6fJ3Ap3lxpzxZ9rxmZ91HGh/glojVm2qFneSgUw31E4p0S3kS7p3av1sS17rl/faSq7sbrrdXXA93FpC/u+Zic83l9oY3esOtbrlmx6VuuIobrnZ3bIYtGyzANKJEjTkLMk+rUHq/kM3qOSZunK4oTUfhOxvhpewqKJaeIMVtWxu3ts+8IKLmUWZJtS4dXS2XqKVERd5cczuEWRPXWDu15IkSA1cPQZV+cj9NqoHVV7eFQxT3iU6mCWkLIeZX+/w0J7RTlJT1Dy0njNWuf1zW5qwz0f7gUiJZxjVJDWV3UcYOvT2uVnR87LHN3VWtZGpFaenmJIt0WzxMsnJLQsah7rIW+NVme2rp/zreeHXfZFHSliYpP0vwtzIGi1ucZEBjtopnxSSCbWcoBYJtECc5UFl1nLxeGkWZsDlhbdAnuVxMsbiXiXQln/NYT49cky9pFuvZFbaLOzueZAUqFxroNdAR6GXBarXifHHCI9Y81hWnLHkczjhdrnm6OuPp8ozHizVnYWluu/U5j5cnPOrWnLFkKRZnJCHkwUbIbsJchbxM2afNvaJ2rZbNBBlGnhVEUzbYyKRshF2kmcgdPy6/TX5K3sYHC3PPmIid9p6Xthp6/ujocOX+ORT35/prvzvcr3kWoeECa0bbGDGLn2n3tb/sR43QP9DMh2/I9NHialxjf5nyYO2l4GoxpR+2NkzqyDTjrUDxyx+yOOR1i5jIQZZF/CVVYsrCMuS2FWEH7HLeZiKyzf927LiNO67iLZfbW643d9xsb7lM79mmyNVwx/vNDZfbW3NLxh3bOHCXdtzELTfDlrvhjmEYGFIiijKEROyEQcxqtluVCbftfEw8aD3eOqKXpjhhGKwzrMH20rRN3o7OMlE15fq0JWYuvwTjkEfveUuSY/bM7p+zTvOVLFaBLDDGOkF2kK01SrO7oXSYMZXO2M41NBmYZZ066UbdpwXOlgxPyJ1NOd7GunIMzccbjj4DAY4lLRybnHd239qH+T6XLpuQxu/bYrgwdnTzrc/n+QypLKcTq525oMfzs2OSLEp0b9ujm3j/GMYjbJbTOM6bqqPIsoQYe7Z6DeM2BIu3ScqiG4+jWBwVbAAhJig6xOI7k1myUq91O6WAnYkfkDCm8Ut2MQWFvuvKxbVlc3zpgo4uBfpkyS3dAN1gcUaP+gWrbsF6Ye649WLFoltwwoJVt+R0uebR6pTzxSln/ZJVWHLWn7Barzlfn/CoP+VxOOWEFevU04WOTmwamEW2NNlFU3MLKtUCqOTBTLHKMV5bjbac5ESj8f7Qcvc01yp/qs07eWp6Ojqgpr1m5dIVtylMXIDju/TDIqYONLLgPjaAmD8H5Xzm25uvdQwXWPfjAusA8wbZG3TUMgxzcbX/yU+F+0ZG+0JRD3wzH6HZfzr7aGrapulWWhGXa8RoAk2kLtSAS0k0L6nyQixlMMatxFwkb0tkQ2QTB3ZpYDvs2KbIRrPISjs2ccsmbbnVO+50ZzXE4h3Xuztuhy1v7qyi/iZu2KYtGxnYph1pGBjiwE4TURNDgCElBo02wXcyC0FUJSZbxmIn7BhTsNpfiHVuoQiqPGqPWchJXsZkaxrvIp1aXXJTIJiVpgT8W8JAKYprK4Ycz5GyJcyOR/KLuxVM1oEUYTb+K3Xcmlo61b0xHdHL7M6xwN3x/qnS9ViRsmLJqJa/9qvZKLy5N5TD97PogZF6u5lGXNU4n+p+PXB4k2031yFfqNp2+aeU6yzZGlRN4bklgtTrVI40UTr9cg/Y+p2mxgU91h8qYl5zdnFp2oCw1TLLQQl8zsV7k00CJsksTiEFs7ilUgkduhDoJdCHni7koO8c/N0h9AgLCfQIXehZlX/0rPsF68WSdX/Gql9zsljyaHnCeb9mHZasZMljXbPqek7DgpOwZB0W9NKx6nqWnRXPXErHko6eQE+ZNCOLRZE8MBHGKVjGSLJS26mdMzAbo6wSRDOkaH+Tyb05e1+VOn3tTTC7W/aKUe/1IrkEwoE4p/nWPrYXmS+3f1Qfy6FJq52HwAXWj6Kd173lpyuwPgXd+21+Tnqw04E80s9vtSpBa22a4nYYrUKClWkoQqFsOPc/2QRvy8fW9ZlHYsVEXzq11hKlUDsrRYglVgKrrp9SJKXEkKzERcTmirxjx23achd3bNPANu7YxIFtGthEE1238Y5tGmy5NFiQvw5Wtywvdxd3bNIui76BW26IcWA3bBk0sdVIVMu03KU4LYmBotKh3aIKntq1Kiw1jjFjkuPSVG2ErNkhPAuUGp90HVtIqBN3lzabdDXFUqM6sSaVtoSpyCnio0y3VLaYsmXkUBygdZTjtsdltNY7q1e96is7sDHeUeuBF6vd1OYwNsDe5PKqVWDNibR33L64RIqFRJrrI41glFHMml+sFustAwgRYaCIg1EoByz20N424zpVMeiutm+nQkdPH3oCaoJIhQWBRbdg0fcsQs869Cz7BYuwYCH2+7pf8UhXLAispOMsLC3gO5i1qe8W9F3Pqu9ZhQWrrs8FMc9Zh46T0LGmoy9ZeNKZwAsdXZA86W+wquTZ8los1wmICjsZ6MTkR8jxVqNAZGyXap054PCa3u51UGZ3hOb3SX4nNQs2d950W/e8yn8Kb/lpdNXfgwusfxQusA6MbD+0qBwSWDZ0PbyRB9dd826w/ebIxMkf2lxdqHVshGO72dtw3UQTSF0+l1m7lBBt+zRM189/1Emly0hT8/FkrZZCyfQsmX7WGUtoRqa5Fsz0XHOOTtsgqc386iwQvYx6s5WpuPtKQYmoeV5GzXOdqU1gZAkAka1GdkS2KFvdMsSExEDSSNTBSmYkE143YeB2e8fN1lyct5sN2+2WjW65TbcMMZrIG3ZWGiMmbqVjSGa126UdMUWGGBniliFu2cadRan1Ui/jUFyIQYm5MKGKMoSpYK5uTRljtYrrMIXiHmmLD84EWrAOUpLW1O/c9NNLUQVPaO6D9s45HttoIlknl7d1fU/cPEXUZzGzb0gbp26q2yoWoeZRExm7dfuXw7Wj0CVLlqgNl/8POSArYFlwtTwA5smy+CXhtD+hCx3L0LPoFvQIfegseDv0LHsTT/Z9b4KnW7FcLVgtl5z2a04WJyz6JWdpxUm3ZN31LLVnQceqt7nszKUW6AksEHqBLlcQF8jlADqrLI7NG2pp/VhMo9o5mTst1CwzkWxVxdpBsIGDNUkgZCvQUAZVWZLafam1rS0mrLnK+RlXgmUaKnVaGyTOhHQR8OXN0UoHyaJpHkheboE8DBPGAUr+PKvB9nZpbpL9F+TEUjXnU/uB+/qO+97Nn7QfF1j/KFxgOT9Z9J63i808NN66kpXZGDPRWDbAanLlT/IaIKGOjPe2L+MvQnZPaKrrj525NH+Pna99OC7f7rMI0NIN7BjDghOWRKCYeBuswlh1CZpLMnGnMc8fGRk0sUOJDCSJJMytucWE3JCF3228ZbfbcbfdcjcU69yWXUrEOBBjJKaEpkRKiZgS22gWvpgGc4HmY0gl61MTSc0CmIpVTc1iFSW7SGuPlqccKRbMJuI/1fYtH+VK3Qde+potY6XIrYw3QE0QoCQKiNCFnLWWJMuGErSuVgIg2CS7JirEYnpC/isnSgQtn3dV7PTBxEcnPYvQ0XcdXQgsOjHR0i1Y9QuW/YKu71l3FlO06Dp6Ojrp6MTiiFZDoBPJbrHe3HSY8Omzpa6TPJeomkszSJfFill6FpBFkZa7rQol8l1nQeujAATNrmTJhh0zyUm1NOcBkzB5VsxlJxNRW7epYWKNq3saL0ve82ihLmn+Nq3NKMwI1GOpQsBrLTk/E1xgOT9pjt6ctTOeuZykfDoTWJqqrLExbttxH+jEm83W2KNxWNu425p19wJc57FnJr9qHZvSEeaeZz4eLkbR4hJpRZkUq11ew37LllXNwce5VpiICYog+exLk2RRWjKm1HYzadGSOq7Eyb5MXmm1JGmOkbG4uMRQYtOaLMqkJfuqbGVspaRp2klDE1N2GMt4Gzt5uwSy97OIsOJ2KjsImPUohI5FFuVt3JIlAfR5GpXRqiVki17dVOPKymdULSZVXFhx3lKIuNZoqhe6FDfONjIp+xnPra3KZm7YfD0alypaYu20Ljc+C/vPTBk87KUSN3eiyiTkevwu6eSer1JK5q5grW0weW6beLJJJfCytybxox3cuMByfi64wHJ+hmSZUUfHrRpq0pNVxl4RGyVPPU6lUOv+q1przzeVX0pOW5fS7R7qmGbijnH0PkdyDNaeUGwtbfVfIzjajdWOv4mtorGnia0XoWYOltIB1WpRrQbWqRUhNHatJbU/t0JjhdB2HawcRJrEORU5OHUdj9/u/z0u00bIzNto+rc039TfdHQZV7vmTITnM2Jv9bxwDZieu0KP/FW2PZ5XseRovR/t9hrFiaRucqmn6fwHXtEKlvsqaK6bVdq/FLqc1N1utcxMQo+mpHZAItn91t5LRdznLRzJ7ldAqp+vLRQ8WjPNe18CvptnuDnVSSxeY9205cPs6jvOTw8XWM7PkOkLV6TbX6KKr7EmkL28Py7eQJseZP9VXtwjxxIdtBFtMn4qamUVSiebO906DdJ8H7UzC82ndnB16eo+aY+7mr2qdUNRQoxma5Hi8pnGqcwFi87OfXYU41+5aS32xOoqTawTZYFw/FVz6JupPWuKtcs929vL6qJ27tP09rKvqYweF5G6nLQaQKen0wryNtOxPXzNx1ViNRv5gIzmsGZp9iyK+xyowYTuicHpb431tNrgDjM6CUdLnJRz1NkgotyS2rZxmv0s09LAmGt6OGKpPYOxFle5n11gOT99XGA5P0NagbWfmXZ4jdyRTe72Jitt9hi0fVYJgC6p9eXTQ9S6pJNDasRQ47oZjyx3cpOOOWc/6rHOr5E7MhNHOrV7VSNIANTmJivznCVN1SU2Of9iMctV5i2ouTVb5Zl5Q2nDsVRp/e2jXy3zanOMyqdpu+kqrRVzn1Zg1dgfCZPOXMv6asHcJjrnW9rNJMYofVsbVXuQ5d4MjO5gCJaEMTmH0YIVZ+JzdPGF2T1brndjJSzCtojAya1grrVWSFlIv9Y2KpmOTeNNTklp7uf2fpxbvZr1D7oUEUrVc82DgLLt8ozNy5KMTKuKfUh2Os5PARdYzs+Sw7ftOPXP/je1vjmjqDn+oj7osjoUDN9YRWr6/3y5Eg+U97tX22l/T/a/KKkRHmN3HidZfFCMIrlgalZVtrUS26Lsx640NbcmJ9XMhXe0HxunWimddW1VGTvz8Wymlrgp7cQhH8d+xFrelyqSw7wn+5fR+jI5uMn5lK/Glh6TGNqdTEXFdGqsbDWtx9McA4k6yZHM7r+JxbNt/+mOlVGcl4y4dpZT+6I1reXv6jWRcem8WBArOip13QPtWt3pbeX4aRxdafRJ8dsZ0wFIc+fL/l737amt6HaB5fz0cYHl/EI4JImOfd92v/dNT9FYYiY9834s0bR7PHaE436PHW0RDuMUMNOgZ+svU9OFT60ibdxKu99qwZu4VookuK9r07HzPCCZ5vsaP57bd/RQv10Oes+C9iG0nlW1/zEKkPncCwd2XE1782VkTyAfEpmjYD8m5mW2Ga3tMjuI+nVrwxmPRvf33yzbnsXYHoflqm2nySnUydXJ91i5R+cWpcPP1LiJqvoOLDc99nm77VnA5NjdML/vHOenjQss51fPcYE1napIJ9axYnloFpf7I7t01pUUm8l0nsupwLp37slZkP+HXKWJ1nUzHtPH2o8+9lXx6dNkfLpFokjGw1sLH32sdZ19XZVJB8/nYIxXxaY6mm9vdBce4Mjxytw/uLef8Xjuo7hx93d7vzD60FU5VGlfj0yjBSZ+DxabbdZ3nF8KLrAc5yilE88d9ke8/D9KqNy7/igcbJcfCMa/t6N3/h7+3radC4f7tvf3zun2z5wT7mMGA47za8QFluP8kzjumPuQu9NxHMf5qdP/sw/AcX6tHJdOLqocx3F+7vjkQ47jOI7jOA+MCyzH+SQSR0tYO47jOE7GXYSO80n4mMRxHMf5MN5bOI7jOI7jPDAusBzHcRzHcR6Y/wMAAP//7L1ZkBzHlab7uXtkZu2Fwr4SIAiAAAEBJMWdBEW2RJHiJrFbUm+aO9KMbNps2trGZq7ZPMy9D3PN5mEe7sOYXRv12EjslmTWbU21WkCLIilxBUiCICiCFIh9IXagsBVqQW2ZGe7nPkR6lGdUFtaimiTiN6uqXD08PKLi/PGf47/nBCtHjhw5cuTIkWOSkROsHDly5MiRI0eOSUZOsHLkyJEjR44cOSYZOcHKkSNHjhw5cuSYZOQEK0eOHDly5MiRY5KRE6wcOXLkyJEjR45JRk6wcuTIkSNHjhw5Jhk5wcqRI0eOHDly5Jhk5AQrR44cOXLkyJFjkpETrBw5cuTIkSNHjklGTrByfMIQBPn9bU1+f9vKkSNHjhw5JoKSPCLlyJEjR44cOXJMKnIFK8enHvk9QI4cOXLk+KwhJ1g5PnPICVeOHDly5Pi0I08R5rhshCeKmqCuSlCoum/4n+Q9/+3wU9falxAq8/5Ez8e6J6CvrS85cuTIkSNHFtG/dAdyfDaQ0KSkXF0BiJvgcyb5lDhAUMmHA5qVkCtRyreEqrEfz/WVakx4RCR5T4Hz7fn7A5VQNtXo87Wthtu4ku3myJEjR44cV4pcwcpxWfCniSjwdEXVOJZoQUTQonA4tDJYa8FoQBAXY4xJCJGTlKwp0cnrkvAkJ4I4R8KhhFiBAbRoQCWMSDlQglUaJVLrgydegnYRosEqh0EhDqzSaMCI1Po/th9S++0JWE6xcuTIkSPHZCAnWDkuijEVSBBxiAKFTlQo63AiYDROKRygcBgHBo1zgkVQRoMI4ryGBSDEylFVgkNhJU5ImwgKqW0h+bRCgwJRChHBiFCUItpolALnLNQyfRWVqGZaKYwVlCjEaFytTQ+lgiRnoHSFqleOHDk+vcj/V3N82pGnCHNcNhJS4hCxgEIZjXIJEdIIVkCLAqWoioBSOAWIYHEM6yo98TD9lRH6y4Occ8P0yCgnB0/RN9zHQGWYC9Vhys7ilEIrTVEZOoslpjd3MKdlKrNKU5iiWplV6KKz2ExX1ExH1ESEQrRCi04ImqhEpdIgSnC13OYYccvUZ439Cv7mF+8cOT4ryAlXjk8bcgUrx2XCK1gColCiiLVKSBUKrZILXOQUsRYqxJSJ6Zcy3eUBPu49waGhM3w8dJZzI/30jQ7QFw8zqKpUZISqVLHGUlGOWIGrpe+MggJQcIpmV6DNNdGimphe7GJqSyezW7pY1jmXm9pnsaBtOrOljVZTolDT2UQS1UvrsEYrSRX6ujDjU521a7OvG2NcVVeOHDly5MhxecgJVo6LQjLpM1GCEhDRVGsmH8YlRAjlGHQxPXqE45XzbD+5j23dBzhYOU933EcPI/SbKhKBthbnYlSksSS1WkocOMFojRJNLDFKK5RWVJVgRaGJaoQoxuiIgjV0SQuzaGd21MFtbYu5Z9EtrOicyxSaaaKAtkktl9K+IN4hKKxSOBSRjBEvIE2J1j78+xnoiyB7DK72Lj37Xf88L/K/vvFZVn4+y33P8flHTrByTIi6GXe1QJxQE42DhHtYB1gqxnKuOsCO8hleObqNDd3bOVU5j4uEEWWxBkQ7Ksol7msiKFW7OLokcaecSbapABxOG5RSaFsjdyIYpVFaqEQViB3aCpFEGCmgxFAotDC9XOCursU8uGgNt05ZxGIzhU7VBICWpE4MVK1uLKnjQmo19Lq+VutfGn6/Q4KltR7nBXaxIJNOUMi0M9F3P+0Ba6JL1mT3+2Jj9FnDROfLlZxHnxZM9D/xSW8zi8/CWOX4l0VOsHJMiISG1ObaCThX03VqdVWihGFV5Wj5HO/3HuLdk3vYcmY3x9wFhjo0sY7RzuJq6TaDQosEDavkPWVxDrROSgITvuNANNozOaVwSnBKAIeu2USIUjUTCA1oRBRNMTRVI5ptiaXt8/jywtXcM20py0tz6DIlIoEoKc5CAKc1kmwRI4roU5QZdC7Zz6zS5JxrGFQaXfR9QMq+79vIEomJ2rhUQPl9qQlhf8PHkxVkGxFSGDsGn6XAGh57uPj54Y/9p3X/fB+dc+NuNHy/Pwk1Nnu+pdYvn9JxyvHpQU6wckwIK2P1SBqoVuPkBaOpuJiz8QBvndnFG6d28P7AIQ67figklU1OBIdDfJG5AiUaLYmKlBQ8JYXoY8QpsWEwAsppjCSWDMk7ieIk6UVtzIfLNycoIjS6Wk1EskijYsMM2ljYNIf7Z63isTmrWN48g1ZKRERo65KaMuOwtdSkEVCqlg79F17swDmXXsg9IQpfg3o1olGAzAZZH6ASi4yxQOW/74nKRIpXFmH/YPKIzsXg+xumOY0xk9K2H59wjBqN92cBfl9grN/W2gmJVHj8P20ICZaHf+77/UkRrEb/C58kqcvx+UBOsHJMCLHJhSshNlC2VbSGYRlla99hnjv+Pm/07KaHQaq6glOWCiQKkavVaimwWmF1Qqi0T8X5bUDibZUpeUo0L5dxYq9JSzI+APiide1iIqOxrprYQzjQo4rmYguRLrGmOIdvzbmDh+evYbaaQjMRsRJ8JRjK1LaakMprdZy/FoQX9jiOiaIIay1aa6y1RFGi+DnnGhKBsB3/1wcET6wuFZzCz05UCzbRZyZrDC5GGLOk8lrr0/x4+OfW2pS4fRYDqIjUEd9GalZI2D+tClb23E1LFmrnfvi5ySaIIaEL/+9g/M1N9nGO6xs5wcox5s4ePAeoYCmJwdWI0ogb5QQDvHhsK/+4fxO7pAfXJFTcKK4EcbWMMSWUU0RuzCk9VhpXu+Yl5ErGLbWjXdIHp8CppABdBSqVJ2XKm46SGI0mMwIDE1SxiFY4iYmUQokgSqGURipVpkgrrQOary25lz9f8iVWFWZSsgYpGIpWUE6gWEyMUFH/oqnCRkTIWsu5c+eYMmUKxWIxJQBhoGlESAD6+vp46aWXOH/+PCJCR0cH3/zmN2lpablkmjBMSVpr64K21rqOnHwSwSUMWn7bvb29nDp1isWLF1MqlXDO1QW/Rm34/Zuo/TiOUUpx6tQpenp6uPnmmymVSnVB/bMUPEMyOjg4yObNmzlz5ky6D52dndx3331MnToV+GyQSGttnbp4sXN/MpFNFTZSeidK3ee4PpH7YOWAMTqRLs8nQEFBjEMpYVBGeH/kKM8d3sKrJ7ZxzoxgmxSqWqWgFdWKpckUwSat2ZrqBaBF0BKSqgacXiWWCuH7qW2CjL061oZfLCdZ4TBJ5wlOmcRUVBfAWrRoRAkxMYXI0Ctl+qcVea77Xfb0H+fPlq3liam30UEJMQXEJFsaMyKt2VKk/fQVZZ/8RTS8S/cEZu/evfzgBz+gvb2dp556ilWrVtHe3l4XYCYiEr29vbz55pscOnQIrTVz587liSeeoLW1dcI+ZNWParVKb28vAwMDKKUwxjBr1ixKpdInQq4mSnsCbN++nf/5P/8nixcv5o477uD2229n4cKFE5KsS9WWxXHM+fPn2bp1Ky+99BLDw8P85//8n1m6dClQX7P2WSAiUK+wDA0N8eabb7Jt27Z0H2644QZWrVrFtGnTLpoG/jQgTGGXy2Wee+45SqUSy5cvZ+rUqXR1daXnIUwe2XLOcfToUfbu3Zv+H0ZRxIoVK5gzZ85nNn2c45NHTrCuY9RfUJOCKwFs8ozIQaxiemWI187s4G9PvMNvez5GikJV2YQQFUCcYJSB2NsgUHNep5YmTAjWGELmJGl9lQqWrtEiY1lDSZusNZj0NyFVY0QsedVh0GBBiV8XUYiUIda1NGJcZaTkeK98mIHt/Zyee45nbryPhcUZSQ2XJEvwJAX4oCTTX5UU1f8+LqVh8B8ZGeHNN9/kxIkTOOc4fvw4Dz74IN/+9rfp6OgYG4MJZjxpnSxNVCwWUUpRKBTqCFmj4vEwQDvnGB4eZt26dbzzzjsopZgxYwbf//73WbJkSaqkTeYd/ER1QpVKhX379tHX18eePXvYt28fW7Zs4b/+1/86jjBeqvDfB+4jR47w7LPPcuDAAUZHR7HWsm7dOv7qr/6KlpaWus9+lkgW1KcD/fH5JBXHTwLhuXrs2DHWr1+PtZaOjg7mzZvHypUreeKJJ+jo6BhXN3UtqWOAHTt28OMf/5goiqhUKrS1tfFv/+2/Zc6cOXWf+6yMZY7fD3KClSPhDWHdDUnhObEwGFX455Mf8qP9r7HPnqbSFOOU1BzbwdbIi3KCjTROJC1kN7UJg6L8GoAJ68oqU/6BBBVXCSHzhMv3KvvFQAurFc0b5cDGaGUQBTGJtYOJbeJ9ZcDVbCMi4FCll78+vpGjdoTv3/QHrChOx+jEiMJIMjMxlfZ8dyFc9rp+LK949C8Nnw7Zt28f7777bhoYe3t7OXfu3ITBZCLy5JElQ42Cg6/58oHYqzznz59PXx8dHa0L2p9kisTvR39/PwcPHiSKIpxzxHFMc3MzTU1NlxVY/f54hc6P4enTpxkeHsYYg9aaTZs28dBDD3HnnXfWpWo/S4E0q2rGcZymlz8r+xEqmSLCBx98wOjoKCKSpopbW1spFosA10ys/DY9qtUqo6OjGJOsszo8PEylUknPibC+7bNGvnN8csiTxdcN3LhXVC0t6JQQKyEmqTePRDBSYSSqsO7E+/xg5685UDmNKziKShPZpDntkll7IDgNykkyAw9qswNJFKDQEb2WylOp8VTIXBzpCtL+Ahn09qKotWVFI8ZgVeI8XyDCiAEKRK5A0RYQMRgRHGVGmsr0NPXxi3Ob+P92/5KP7VkqlEFZdM1UNfHkcoj20yoFHZPkUoPeXcsltZF6FAaVwcFB1q9fz/nz54EkZdfZ2cmXvvQlOjs708Bz6tQpDhw4wOHDh9m3bx/lcnncrEPfti+Wh4QYDQ4OsnfvXvbt28eePXs4depUXWGx/15Y0B5FEVEU1c26C2euhbP9/E9YNBy2PdG4hJ8J9/PIkSO0tLSglKJYLHLXXXfV9UVE0v2bCJ4kAixatIjHH3+cOI7TMalWqzz//POMjIzU9T3cx0shOx7hvmUfZ8fnapHtW9hmSApgbEwnkxRczThdDOH49PX1sXPnzrQWUERoaWlh7dq1FIvF9LWJxv1ykS1az04QCcev0d8cOXIF67rBBP/0Img0WixoTawEZS3nZYR/PLeVH330MgebBhktKDAg1RitdI1W+cqtTw+0Uoj3yNIKS7Juoi5otBW0hZLSuNgRR4YRsRgTMVod5bWebRR3wf99y9eZY6ZS1YkJaWJXoRI3eEnSg0myEJiEMQjTTkBazO4DobWWX/3qV3z00Ud1s9vuvvtuVq9endZGWWt5/vnnefHFF6lUKsydO5f/8B/+A6tWrZpw217FMcawdetW/tf/+l9cuHABpRQPP/ww/+k//ae6foaBK1tUnlWvGgXtRnf5FwtI2festcRxzP79+xkdHaVcLmOMobW1lWXLltUpbr5Pjca4EbTWPPjgg7zzzjvs27cvVbEOHDiQKlkXm615sXaz+5O13wjbC20zrlYNzPYvJAv+vAqJ6GSTAr8Pk6HshDM7rbUcOHCAEydOoLUmiiKq1SrLli1j5cqVEx7ja9m/RsfmatrLla3rD7mCdd2g0T92ciGKlWBRiLNY5Tirhnn+1DZ+tOMFjjcNEBerRBJTqDiKYij40+ZTdrEQQCfr+CQvKG9O6rA4nAZrhAoOqxXOgSEJmKId5ajKq8e38b/3bKRbyljRSbG+VtS8VpMZicHswskoC84WyWYD7vvvv88LL7xQZ8cwd+5cnnzyyVTB8akyH9SammrO9cFMp4tt37ft2/J/07Gtfd9am6ZGfNs+YPv0SdhmSMgakYZLBZyswuXVvN27dxPHMYVCARHhxhtvZNasWel2/U+jWqtG7fvgPWPGDB599FHa2tpScjY8PMx7771Hb28vwLj9mehnos/6McsqR9nvhIrJlf6EY+9/wn32NXnhGGTH7HL3c6JtN2rjauDVI2st5XKZXbt2pTNhvW3CihUr6Ozs/MTTntl9uZL9ysnV9Ydcwbqu4XBKsAqUMuhqRFlVeaVnD88e3cAx3cOwEawTChicUsSAVqBULUhOgvx/NfAeWx5eUbIiY8TPOaKaUSnKIipxajdGEVtBtEKMoWAdxTiis9LEF6bexNz2WVitUAoiCZWlJN3plELppK5MTYKG1ygFYYwhjmNOnDjBz372My5cuFDbJUdrayt//Md/zMKFC+vu7LPkImvIeClkiUnoIu/f90HOBzYfqJ1zVCqVcSqWby9MR5ZKpXS/L0elCcdFKUV3dzdHjx5N+xVFEbfccgstLS1pPVZIXiZS0Rodh0qlwpo1a1i6dCkffvghkJDKnTt3sn37dtauXZvu18X6HSpFoZrjU5jhuIYEK0uswvevBNm2s3V0hUKh7tg0IntXSwga1QBeTW1eI9Wxr6+P7du3U61W03Ovo6ODNWvWpPsZqkyTRWrCdi52/lxMJc0J1vWHnGBd51AkCyE7EZxS7B86zc8PbmZ7fJKiWIoqwohFIVitEWsxpoC4+tqW7F3476XvAckaM29IitqRJHWnSQruY4mparBRlBioakNBF1BW0zyquHfaMv5wwT081HkzC3RnUo8vSTG/iE9RqKSujLGaq/SS2bjm/fL2Iyi2Vkql5Gp4eJjnn3+egwcPpgTFp+7Wrl2bBnCAYrFItVoliqL0s2FB9sWOS0jowiAR1i/541upVNKidhHh3Llz/PVf/zXFYjElDz6I+8AdqloLFizgO9/5DlOmTEm3czlkxX/fWsv+/fvp6elJScvUqVNZtmwZxhh+9rOf8f7779eRmuw+ZNv1fTbGpGPY3d1dp+wNDAzwk5/8hJdffhkgVRIv1ufw+yLC/fffz1e+8hWamprGESDnHKdPn+bNN99kaGgoPW6TUcPk2xkdHeX06dOUSqWUoFy4cIF/+qd/orOz85q2kYXWmkqlQmtrKw8//DDz5s2rM229XHgSaIzBGMOBAwc4efIkWuu0Vm7RokXccMMNdcd7sslMSDgvl7hlldcc1x9ygnXdoqZuCImNARXO6FF+cmQD7144QLlQBqOoKgcqCRAWR6FYwFVilB4frD4NFxFNQoQUCqUkWWNQSS0VCK4KRVWiyzYzN25naddcnl76RW6duZjZupMmCiAKQ6LsxSKopPwsrcdPSFaNEE3gLH+lCAmqV2Defvtt3nzzzToScsstt/D444+ngcQHLE9ifC2WJ1qXG5xFZNx3QnLmg7QnWKHZ6L59+9LvV6vVOruGMGWjlGJgYKBOHbtYHxspXMPDw2zbto1yuZymRWfPns0NN9yAUorDhw+zY8eOurTlpdI44f767WmtKRQKqalloVDg/PnznDlzJk2FXkqtyKpCCxcuTEmB325IMs+fP8+rr76aEohQXboahKlA399Gx2PDhg1149xoUsSVwm9r6tSp3HzzzcydO/eq6sk88fUTDt555x36+/vT+rimpibuuOMOOjs70xT3JwF/jPz/W1bdDR9nj3vYxqfhGpnj94ecYF0nSB0R0ie1O2cUFscwZV7v/oBfnniPoUISvKxAVQSlIVIaYy3axYlfVbKEX80dwd+FJ1MIda19r/ZoSQriw5Re5tJT94oEr2UvRzLuO8liz4nThMK4ZPZg0gXBOIhV0pcWKTDdtrBITeX+Wcu5e94KFnXOZKFMo1kUIhBrCw5iBwPGcqrST4cuMqfQjkGhJClxT9ZE9LVemXzlVSAM1FprduzYwfr16xkeHk6D7LRp03jyySeZNWvWuKnhPqCHhOJy7rrDwBoSOU8ssp+L45jR0dGU3Fhr0zooEaFUKqWvhYTLq2RZx+1LpQiz6cGjR4+yb98+YIwIrFy5ks7OzlR9KhaLKQm6EpIZbtNaW/d9T1p9/4vF4jgFLDyO2RSlUqquX42UnDCNOBnprUaqcqgyenXIL8GU3ZerhT9eYQr5atoN+2iMYe/evWzfvr3unJ4xYwY333xzSq5Ccngp5fZK9iXbXvZ/I+xz9n8vx/WLnGBdT5AaKVEACutqJp8IO0ZO8ezeDZzTQ8n71hEri6aAFoUSi8bhULVCb3BGgROUdWgUymis+LofCXyt6pF91RGk3AImKGE9Veb7WmlEPNFzRFonBE8rVOxQ4tCRRqFprUR00sqK9rk8Om8N93QsZVHrDNpMkYIymFggMoCgnMNqy5FKL2+eO8jLe9/nwfkr+D8Wr6VVEoPOxOA0LABT43fqChDOkhIRTpw4wd/93d+lSoZXUB599FFuu+229O49/F52wWYYH2DDlGFIALJEIBuUwva8/48nYMVicdx0/2KxWFePFSpqITHx35koRZhVAqy1vPHGG/T29lIoFABoaWlhzZo1KeELCWZ2HK4EoVLhg3cjIpVtP0uMwj6EkxCy4+zb9gqh35/JQEgQ/DiHqeTR0dEJVZerhVKKarWaTsK4mvZ9v71z+8aNG+nt7U2tGKrVKqtWraqrRcwe82slWVlVM6xba9RuONb+c6Fam+P6Qk6wrhOoGlnxl2yFT3UJA1LhZ4e28B4nKBdjjDboqqBMkcjV1vPTEGtDkoRTWCVoJ0RaJwqSJN5WGrBeuWJswWcdTO6DrOAzZijq3d+RRJkKQ4yvp1KSKFYSJcviiAgxNplFaA0lU0TFlspolbaonQemLefR6WtYO2clC007RmmGk5WdicoOClC2FlGGYQPvn9/Pc0c28fLZXVgN3YfPcsuMOdzfvhSlCujYoSJTM2iFxLvr6i+e4bT5vr4+/uZv/oadO3emRKparbJy5Uq+8Y1vpMQieyfta2qg/s4/TLNlyUFWgQmfZ8mXV3F6enrq0oD33nsva9asoVwuo5SiqamJcrnM5s2b+eCDDzDG0NnZySOPPML06dOZMmVKGnTTo3+RoOu3q7Xm5MmTbNmypc7g9IEHHmDJkiUpebjjjjuYOXNmXTH5laKRChW+14hkhcgSVd//pUuXpu754X575bFUKrFo0SJaWlomLRiHJCWOY3p6eiiXy+m4NjU10dXVlRq0hv261u2KCJ2dnek6kVebIgQ4cOAAGzZsSOvHoiiiqamJL33pS2nfQ0+3Rm34fl3O9vxnwxRupVKhpaWF0dHR9LNe6fTHPFQn/eNwgkGO6ws5wfqcI72c2IQUuBrp0UphlGLYVXln4CCb+j+maiwSAbFDtKFGeVDK1YiNwmqHRSV+UhVBGRgpJsQtih0ak5YkKRGME2IzplKJGpvxBwktKdTSjU7VKpuUrhGtmkKj/AU76bdSEGtBXBUlUFQqMUotGagYWqtFbnAdrJq+iPsXreaLU5eyQDpprgpFEgWqJBYl4CIFtsoF49g3cpaXT27nlx+/w2HTw2gzNFeEPaODvHZuJ6va5zNNCmgVpWpgchG+xmNUu5APDQ2lflc+vWKtZfHixfzH//gfKRQK41JWYYqtUqmMq7kZGhpKZyAODg6Os1EYHh5GqcSSYXh4OFW5wnoWH2Ccc5w7d444jnHOUSwWue222/jKV74yjnh0d3envl0dHR089NBDLFy4sG6/L0fV8IHJOccbb7xBT09PmoZsamrigQceSFUxpRT3338/DzzwwKcqmGXTuGEq1r+vlGLhwoX81V/9VZ0aeTUkMauu+HPkzJkzPPvss+zcuTPd9owZM/jLv/xL5s2bN+G2rrQP2Vl8bW1tl5wUMBFEJF0iamRkhEKhkKZZV69ezdKlSxERjh49ys9//vO6yR2NcDUKmkhibFsoFNIbmWq1yi9/+Us+/PDDtK4uq8Yqpejv7+cv/uIvmD9//hVvP8dnHznB+pxC0r+1i7vROAQnLnFfdwlxuuBG2Hx2PydH+1DaoVxSWKWcRmtHrC1KWQoWCjGgk9Sg1hGqIDjr0LHCGI1RCpuuKFhTr9BpZ1zNMkEC93ZXywImxKuWVJTa7D1Va8m5lJQ5BSIO7aDgDOIEp6DJFei0LcwrTeX+mct4aNpKVnbMZ1axncgm1gomMohL1lBUWhPjqGI5Fvfw6xPbef30Dn47cJALzRbBIS5R7iptmg3du3hy5m10NbdhnSJSWWJwDdMIgZGRETZs2MArr7ySzuYTEWbPns2/+Tf/hvb29jQ4nzlzhu3bt7Nq1SpmzJiRbD2oq/F3zv39/fziF7+gra0NEaFcLnP27FkgWduwr6+PH/3oR+nyIiF5Cot4Q0XAO8lDkmbq6OhIFRogDXBDQ0N1M70mMie9VMDx+3Xo0CG2bNmSbkNEmDp1KrNnz64jLWGqNUydXgwhMbyUmnY5ffb7O9FnswqX/0yhUKibXXm1wXiitJhPPYbbN8bQ1tZGV1fXNdcrZXE5at/ltHHw4EG2bt2aWkv4G4D77rsvJdcDAwNs3LjxkrMur4Zg+e+EClwcx+zbt4/9+/ePO8/83yiK6Onp4dvf/nZKsHJcX8gJ1ucUQnAHCyCCJaldUpIEgDiCE6O9fHTuY8pRjANMYooFShI1SrmE1CiFQyfrDDpHVcXEWhGhKKCRGGJxSKGmduGSOipl0qVykvqt+l4qEjWK2tI5xtVSgS4x+UQlypVCEJ2kDEUcTa5A0RlsrGiPmrm9fREPTl/O3dOXsKh5BtNMa9IOGq2S/Y4BpzXNaHRc5RyDvHl0F8+feZ8PBo/Say4wVBgFbTAuwokwEiWeVycqvWw6d4Cbb5hPW9SCcr7PnlpdPcESEY4fP8769esZGBhISUhLSwtPP/00t9xyS3qRd87x4Ycf8sMf/pBVq1bx8MMPc+edd6beUlCfIty9e3ddqsqnGLXWjI6O8uGHH6ZBKXQpD2uAwjTkmTNnUoLT3NzMzJkz6+q3vN2Dn83oUyS+5ids72L1V+HYxHHMli1bOHXqVF3qr1gspvuTJQ1hmjNMz1xL8L3c4Bz2JVsr5/vQKGUUvp6tI7taNCJb/vwKlZdPApPR7sjICO+88w59fX3jjumsWbPq9i08ZydjJqRHmGYNFeBSqVRnRxJ+NjzvskpljusHOcH6nMMrP1oJWmmcS2iNM4YLlNl77hiHhk4xokYwxqGdUC0oRiNLqRolFVcqITvOGIpoisSIxBijQRuqkmzDmBKxDKEsGHFYldRnaWcAg64V1ItK6roUvqYqWedPhHTmoSiSWXs2IUlowdUUJweUbERnXGJN+w08ufRebu+8iXmFabRKEa2hQBVNnLTnIiILRiuqOM6ZKh8MH+EXB9/hrVO7OC29DLcqKnEF3dKErca0VIU2ZbhgK0RoBuNR3us5xOPzbmeFacGnT5OCf7kmkqW1ZtasWaxevZpXX32VKIoYHR3l8ccf56GHHkoVJhHh/PnzbNy4kUqlwtatW9m/fz/9/f08/fTTdXfvlUql4bIuoUGjJ0pa69QDKrwbDwO9LzTu6elJv9fS0sKMGTPSAOPJkp9p6OGJV9iWD4CXU5dz/PhxPvjggzRF5FOkvtYlDIChC3pISn0/fh8BLlvDFcKP00SqWVjHc60qVvg4VDg9ucpaQFyrcuYRbitrtnqlOHXqFB9++CEXLlygubk5TQ/61GF2jL3FSdbRfbLqysK1NkOl2W833OdwNYWcXF2fyAnW5w4uSYHVnkmt5sjhUGKINIgDnCA65u2B/fTIMOWiouQMEY5YLJEyxFEV5RxGGawTlNZUBVzsKEYK4hiqmpmFGRQqMadVL+X2AtgqcWL3jrEaUYIWixEN+EIrQWupOckrIgGjYNTFiAajNbFzYFxiHFp1RBXDNNrpKnaycup8Hrnpi9zXuYQbpZ2mWFNRQlGAGKwuILqAESG2o8QFxQVb5qQd4FdHt/LPB9/jkJxnMBolLglUhRZtqI4kJppOQxkQpRk1IIUyH40e4cDoOVY0zwYNNqnGJ/JeWNdw/ezs7ORf/+t/TVNTE6+88gpr167lm9/8Jq2trQBpMe2mTZvYs2dPquQYY9IlYowxTJkyhblz56ZBKLzgh8GhUWAN67tEhPb29jqycvToUQYHB9NalIULF9LS0pK2EypdFy5cqAs0ftueFDW6q8+mZPw+b926lUOHDqXf9X+zxqiN6priOGbr1q0MDg6OS+N8koQriiKWLVs2TuEL9z3c1/Bx1sqikSXHlRaNh+TbH+vQy8y/PhHxa/Q82/+sb5fv3+WYfzYipXEc8/rrr9Pd3U1zc3PaX3/ul0qllOCUSiXmz5+fnr9+u9nHV+Mmr7XmwoUL9Pb21t0kTJ06lY6OjvRmJpyl68/95ubmtHYyJ1jXH3KC9blEvZKiCFODyWw/jOboaA/7L5ykouIkdacVThTikrxXRGpHikGBE5xWiNFUlKXgFMtb5/Kd+Q+Cg5fOfMTWwY8Z1IIUkhSV1SAqSvrkHEUijHMoqc021MnyNVY0sSgKupjoVLqM01BQEWZUMVW6uKlpNndPXcoXZy9lzbSFzKaFEgWsgop2RKJx4tAKohoprCoYjODY6Gk29R5g3eEtfDh8jCFdRWmb1HeJxmIR0SAaI4kWFTtLoWjAVtHG0DM8wJGBs5TboDTJ9SrOOTo7O/nWt77F9OnTufvuu9O6GE9Muru7ee+99+q8gVauXMny5cvTIPPkk0+mRefp8Q/qqLLpjGwqJSRaLS0tdfVMe/bsSVOYTU1NLF68uC4getWlUqlQLpfTNr3/0+UgbE9rzYkTJ3j77bepVCrpa6FH10QqhX+/XC7zD//wDxw4cKDOHiEcn8lWF5RSdHV18Rd/8RfMnDmzjvxdzXayimL2tYmQPQfCv42MXhspTNlxyu7nxZ5fKbIE+eOPP+btt9+mWq2mNgnhzUD4eMmSJfz3//7f03bCvmRvMK4E/lx58cUX+elPf5q2USwW+ZM/+RMeeuihcdvMKqyTPUMzx2cHOcH6nCP9dxaNSFIwrrTCimPvYDeHKmexkSDKURWHSwqeMOjA1kGIRKGcUNUgBhDBqIhFnbN4Ys4appsOvjD9Jv75yBZeP/07jlTOYgu6ppYlZMqK4IxDnE1OPJfYOlQijTiFURESOyJtEOcwVWF6sY2lrfN4cMYXuGfqcpZ3LqBNFWkRTUEEZRLipmtF6xgoSNLvsnack0He7P+YF49s5Xdn93FCD1AuVolskqKs1r6PNohWiQWDE0RrRIOzMSXAKkvVCPvPn2BwXpWCmNS7Kwl0k3O8urq6eOaZZ8aOX6DmvPfee+zfvz99vb29nXvuuYeOjo70tdbWVtra2pKjJuP9sbK1QI3cu8PP+sBULpf5+OOPGR0dpVQqUSqVWL58ebrdkACUy2UqlUr6mk/tNArgjVQa/zlrLa+++mrduoM+tTVRO2H/PbHx74ckI3x8Namry0E4fldD4rIEqRHZudx2Q6LcSDX027ja/l3N97PthOnEkZERnnvuOc6fP5+SqTiO62a3hkawWuv0hiDbn/B8yCqBlwPnHKVSKU09+r4Wi0Wam5vrlKtQJQvT4bkH1vWJnGB9LpEpnqW25Iv29UJCFeHQ4Fl6ZBAb1eqhdAQF0JIYbsZ6zF5BC2AFbQRXSGYiVqsxJ86dYuDGEW6SaTxQvIF5N89iVcd8njvwOh8NHadSUlTFEpnE2UCU4GqPEVDK0FRNCuON0YgymAGYW5jJiukLeXD+Kh6YsoT5ZjpFCjTpAhLHaKNRNqmIVzXjTy0aI1AlplePsmPwOL/ct4k3BvZzXPVjm2KGZRj8AtcoVGTQzgf5WqWYSginE0WkDMZWEKNxYjl47ji9DNEubbXUYG0a5DUgG6h86i9MR3R3d/OrX/2qrm5qxYoVrF69us4dPJtGyioXIckKH4eBKqyh8X+7u7s5dOhQ6uPU3NzM3Llz6/ofWkP49J0xhvb29rqZgxdDuN1du3bx2muvUS6XKRaLlMtlmpqa6nyHLvZ9pVTqJu8tLML+TpQOu1YopeoUvHAcrzTQhkTRk8W+vr4rUmJ8G+EyRaHzeX9/P2fPnh1Hvi5FPj2h98fEz1C8GoTH1DnHxo0b+fDDD+sIUWiOOpEVRUg8s2nx0PTzcvuZPVd8e9mZtuH72XT11R77HJ995ATrc4bs5VCR+FFZkoOtFFQRhnEcv3COEVtGF0toJ7iE8aQLQKeJRnE4ZZJZfJKk98pxhahY4uRwH5vP7uHGBdOZQjOz4lb+bP69LGubzt9+vJHXz2znQoshJlGtlANqy9KIKRADkdW0qSIMVunUrdw/7xYemXcba6fcxLTiFBBBOaGgFAqH07U5ktpga4Xx1VjQBkYZpTse4FfHP+Cfjm1hX7kbW4ixWiiLAwSnQYoRyil01aIc6ESzS0zsEUQURmmUTXKZEgkiMScHezgngyygLR1fP+6p8egVIpvmCu+Ave3Cz372M86ePZum55xzfPnLX6arqyslV93d3Zw5cyb9btj2REpFmN4L67bmzp3LnDlz0oC7f/9+Tp8+nRZIDw8P093dnaYx/exBrTWDg4Np0a83Gp1onTjffqheGWPo7e1l3bp19PX1pealLS0tVKvV9HsTBf9QMTLG8LWvfY2+vr66cZ1sUhXCE7t58+alwfVqyEdIFn2K7MiRI/zt3/4tfX19E6ZHQ4RkWSRZJSA8FqdOneKHP/xhagZ6qbb8+75PX/va11i7dm06mzMkt1eyn76uylrLsWPH+PWvf52uNxluO7ukT3Y72XRsuVyuSy+G/b9chKl0f+OQTfc2ImKQKK7hPuQpwusLOcH6XCKI9DWlxiiFdom3k42gd2SQE/3nUEahBSKnsCpYtkZJ4uKuQERhtSLWJKlBEh8sbRW9TcLrp/ewdvYqWiNNu2lBieGOjiVMXzWNW07cwPrDmzlYOUe5oBiNqxBpxDoKSqNjmOJK3FSYzp0LbuK++V/glo4FzKaVFomInCC2dleqwcWJEqfjCqINCo0RoRpZDlX6ead3D78+9iFbz+3jghlipF0Rx1WiWDBaUVIGV1FUqgqnE+NSUVCUZOetSfZTQVKUL7X0o8REJqKPEbrdILfqmgJGhtReBclqlO4JA8jGjRt59dVXUx+g4eFhHnvsMb7whS/UqVCvvPIKv/71r+sIRrZ2J4vse34W4Le//W2efvpplFKMjIywb98+yuUyzc3NKJUsmbNr1y5WrlxZp4I55+jt7U3XUARob2+/ZA1WqLaNjo7yxhtvsG3btpS4+fdCFeJy2jLG8PjjjzcMbo0C5GQhm5a6GuIBYzVSfp9HR0fZu3cvvb29ExKsRsc7JB3hOo2VSoWDBw/W9Tnb/0bKnydF99xzDzCWrrtalcbvY7lcZsOGDRw7diy1+PDEP7wZCNOdHmEK0fe7r6+P3/3ud0ybNo3bb7993FhdDkJlrVgsUq1W6xSpMA3sPx+qbjmxun6RE6zPG0Twy9nUwrZ/A+XVGxR9lRF6Bs5SaC5gLYm0pUjriqwSii4x/LRKajPmElKhrSKyEU5rhimzY+Q42/oOsXTWVAoSI07RRIGlpVn8+Y1f4qa2GfzjwbfZ0n+I8yXBOqFkNTOrzSztmMe9s5Zzx4wl3Nw0h2mqjRKGCIWfdEgkxM6htCaq7U7VKJRzOO0444Z4t+8ALx//kLd79nBaLjDaUkEjYDVOaaoRRKKxAlobCiRF7GiDVpIUuysh1slfbRXGJtusqsRcNRahEgmnR/qgTdVcvBQqjGXXoGA1CmhHjhxh3bp1dVPrjTHcfvvtaf2Hv7iXy2V6e3vrUhPZNMpEF/pw23EcMzQ0lL52+vRptm3bls7k8oF5165d4+piRITe3t50fTutdZoivFhKL+zb4cOHef3116lUKqm3UWdnJ4sXL+Z3v/vdJZWb7EzCRuTjYmRrsnGpVNvFEKptnqx5N/Os8jfRvvnvZevtwhR0o/5ezFoh7Id/7rfl22i0L4365vsE8NFHH7F58+ZUqYSEpEydOpXu7u661Quy/Q7765xj27ZtvPDCC+zatYv58+cze/bscY71l3vcQ5KVVQXD/99G7ebk6vpFTrA+h0j/nyW0G625NalkRuCItfSXB9BNEVVlcRqceKPPxFSUdC3ARKdJlC1dm2GoqTghKmhOxxd498xeHpq2ijmmQERC0IxSzJAmHp65inltXWw8tZMNp3ZydrifW2bdwIOzVnBH5yJuLMygRZUoUBhzbxeHFo0Si9VgTIQIjGqLk8Qza9hYDlbPsm7Xm2zo3clBehk0ZUQnlfXiaqnIWnrTJr6K6IAsJkTUJrVhSnA1Y9UCyd1+VbkauRy7iI6OjiBtfoyDi+c1XEezNVHWWgYHB3nhhRc4fvx43R1zOCU8VDcu5vd0qSAfBttQNXHOsXPnTs6dO1eXyikWi+zfv58TJ06wYMGClOhVq1X6+vqI45hSqYTWmo6OjosqG17h8QsP/+Y3v+HEiRN1wfTee+9lzpw57NixI00TTTSG2eeh0hE+/qRJlR8/7911tWikQvpj7Alv6AmWJVqhetaIUAFprZrvd/YcCwmGT3mG7TTav4lIbJbYeVWtr6+Pl156KSVS1lriOGblypWsWrWKZ599Nk1JZ0lluA1rLS+99BLr1q3j/PnziAgHDhzg5z//Of/+3//7uqWVruQYZPejEbHKkSNETrA+h5jo4pHQhMSuYVQsF8oVlIqwpvaeUumCzVrA1a6fkmlKJHFFjyS54A5Glo2nd/PVRYf4assXULUAXSCZ0VfQJe5oXcKqm5bw3Zsew5A4wLdSoOQbdw6HTWwgUDVVyRKLAwqIUygrlHRERZU55vp58cTv+OmeDezXZxktVrGRQxOBE4wI2gqCQRdq6pyuLX7saWfCGBMHCTVmcqpF44BYKWKVFOIrkrULcY64Uk3HU9Q18aoUPngppdLFlLdu3cqmTZvSOg7/eraY1weqBQsWsGbNmlTZCFNpvv2JEKobIpLWDw0MDKTrrWV9hUZGRti/fz/z589P+zQwMMCpU6fS9jo6Oujo6KjzwMoirMPavHkzr776al1fFixYwKOPPsq+ffvSKfsXC2rZ/Q7dt8O/nyTC4zJRvdDltOHhCXZTU1Oq6kVRlJLaBx54IF3rsZFyGb4+UT88GaxWqxQKhfSYa605fPgwb7/9NiKSkh9jTOrTdqWzJUNy5lOA69evZ+vWrWit0+Pc0dHBU089RX9/fzqGfrHniWCMoauri56envQ4WGt58cUXWbJkCU888cQ4gpqTpByfBHKC9blD/V2l8nk/AbRCJSsn4xCsuDQlqGprB9bsrpKArLzuJb6BNONoTfJBiS2qSXPC9vPykd/x0MqVFDFopWr2B8nsPkRo1YoWW6yVkzuUBocjVmCMJDMJBVxSWZWsWagSOwQrlpHI0R338VHfIZ4/8lu2nTtId2GQUVOFgkI7RSGWtO6MmveXiaWmal2kgJekjyoMTCoZOC2kxMwTUZ+9DIvc4erIVkiWIAk+R48eZd26dQwODtYFFa9uhaabnlB85Stf4Q/+4A/S/cwSqgn3PUirZE0uDxw4wMGDB1MC1dTURLFYpLe3F2MMBw8e5MEHH0zreiqVCv39/WitGR4e5sYbb6SlpeWyanP279/P3//936dEoFAoEEURjzzyCAsXLmTnzp1pYPXLvDRCuJ/VapVNmzalReGNlIjJrr/ySt+tt96amsCG6aQrVU7CmqM5c+awevVqenp6UkLuSfdjjz3G1KlTL6ocXazPoTIUKlgDAwP8j//xPwBS9cc5x0033cTy5cvrFLrwHG60L432X0TYvHkzzz//fLqvnuDdddddrF69mrfeeisllpeq5xMR7rvvPr7xjW+wfv36lGS1tLSwbt06Fi5cmNYOZvuWI8dkIidYnzOMBRFBecY0VoYFgFGKgiiaTMQQEIlL04lWA1Kr4VJJkbdCEksFr4EJiYWDhiJQcI5qUfHu6T1sX3CUO9sXUaRW9FlThhSgYlvzm6r1RZI+Fj2BUYDSGJcUnItWaHE4HXPGDfBu32FeOfURvz2znyP2PCNNDltwKAyq7Cg4A0qII6h6JcwpLhba06BTc2XXUhszBUoE44RIQTVhVqAUzaWmtO5KCGowruGY+WnqzjnOnTvHT37yE44ePTrOPuFi6aIwjXOlU9Kziod3r37rrbfo6elJ27377rupVCps3rwZay0HDx7k9OnTzJ07F2MMAwMD9Pb2ptvu6uqio6PjsgJYb29vnQ1FtVrlzjvv5KHackEh0bgc+LTjunXrOHDgwO9tNpdSKl1A2c/E9Pt0pdvNpji11vzRH/0Ru3fv5uTJk+lr77//PitWrOCxxx5LrTSuBOHEAH+ueeVvw4YN/Pa3vwXGZvEVCgW++tWvMmvWrDrT0ovVbYXnbdi/PXv28Nxzz6VLIfnjNnfuXJ566ql0ofPw/G6EbNvPPPMMx48f57e//W2qYvX09PD8888zY8YMZs+eXfe9bL9y5LhW5MYcn1uMsapEyUqex1iUgg5TZFpLK7GzKBG0OFAWSArHa6ITSpIibi2JP1aykHMtSGmFq33XGuFkpZ91x7bQK0mBNFrXUnA17ccIqJgRKVNRMSiHUhCjiLWhqiIsKvG2MhYtjljHbB88xA8PvMz/u3M9/3zmfQ7p81xossSFpDjdSDIb0BqhEkFFJ+k9h0oXqr5USPYqna79JC8KBtLnqmbm0NncikoJJ7X3rh6hIlUul/nHf/xHtm7dWheQnHN1U76zqkSjtFCoFmRJWPbHB//w79mzZ9m9e3dK2FpbW/nyl7/MihUr0sWljx8/zpEjR9Jtnz59OlXdnHPMnj07rcG6FDG69dZb+d73vseMGTOI45j58+fzrW99i6lTp9YZkV5KBcoqWFrruiL7TzqIegUrTGNdaxoqPDbz58/nmWeeSR3C/bnxxhtvcPLkyUse60v9wJiaefDgQTZs2DAu5Xnfffdx3333peOaVbAmOtaNCPLhw4fThbz9dqMo4jvf+Q4LFy6sa9OfBxOZzYZp0Pb2dr75zW/W2Y045/joo4/YtGlTWnN2NenbHDkuBznB+hyi0cXCIUnaTiUXqq5SMzM6uoglxilJlRhfn6QkuBjKGIEw1BZqVqBil5Isq4RqSbPx3B4O9XYTS2J/oKzDIFg0IhHKRjRRouCKKImIrcGpmpN7rNAWLDEXGOKI7uNvjm7k/3z/7/jxsTf5uHKKPka4EMUY6yiKRleTfjhXxWlL1STKl0FRtIpSrIhsQgwvZ5wSZCQ/ErKpUURiaC+01sQslZLNa4FPr1lrefnll3nzzTfTWYMiwsyZM7nhhhvS10K1C8bXswwPDzM0NMTw8DDDw8MMDg5e8mdoaIgLFy4wODjI6OgocRyzaNEinnnmGTo7OxkZGeH+++9n5cqVzJs3j+bmZrTW9Pf3s3v3bsrlMs45Dhw4kLq4a61ZsGBBXRrzYmMVRREPPvgg3/ve95g/fz7f/va3Wbp06TiX9yyZzMIHYh+oR0ZGGBkZoVwup6ajn+RPuVymXC6nC177Y3Wly7SEZMGrOn4M7r33XlavXl1H3I4ePZoas06Uiss+z45pSGZGRkZ49913OXDgQFp75Zxj5syZfOMb30i9s8KbgEsRYE8Uw7G45557WLx4cXpeiwhf//rXeeCBB1I1LrS68Me3kYrrH/v+LFmyhEcffZRisZiO48jICL/61a84fPjwuBuVyU4X57i+kacIP2cYm++mAUuSKiRxKxeN0clFqr2pjdkdC7A9B5K0nIATlywRAxhXq4dSCqtUzSkdYiWIURixSToOAWcooKhGMR9XzvPawB6Wds2hg3YqRlFyUJDEYcsqV3OPUlgLkYGqODQGpYSydpyuDvDuwF5+eXwL757ZzwkzjG3WRFYo6gImdhgriI2JEEQcGIXDJelFfA2Wq9lS+IqpzMXTSc2SIiFPSG1hbOUQHNYoWmNFRSmsFpx1dFFiSjQFLQqRuJZNLFzzcYvjmM2bN7N+/XrK5XJafNvV1cX3v/99Xn31VY4fP57W3HgCkw1qZ8+e5ac//SmHDx+uUx0ues4EKTNrLcuXL+e73/0unZ2dPPLII2iteeutt3jmmWcoFAosWbKEmTNnpnVN+/btY2BggCiK2Lt3b6oaTZs2jRtuuCE5HkpN2JcwMGqtufvuu1m0aFGqPGSLxScKgqFKFm7rW9/6Vp0xZzaVNNkpQxGhubmZxYsXj9vPK92W/0527Nra2njyySc5fPgwZ86cSRdCfvXVV7nxxhv58pe/PG68sjVH/m+jMVVKsXXrVl555RWUUqn/U1NTE0888QSLFi2q89a6XHUwTEP659OmTePf/bt/x3/7b/+N3t5ebr/9dp588slx/Z2IUGX3I6wj01rzwAMPsGPHDrZu3Zr+75w9e5Yf/ehH/Jf/8l/SFHZ2zC9F5HPkuBRygnXdoHYxUgorQqsuMK9jOoWzERWlEKMAm6bFgm8AOlk6JvB8sir5nBFVU7hq9gLG8tuzB/iDWau5q7mdyM8SFMAkdV3WOSIEYxTWxShVwGlLnxtka/9xfn38A17v28PR+CxVU6EQKcBRjUCUQ2KHjdzYEj7Uis5FozMigZ/p1wj+9fTtugdJvZVNeBeRU0RWMa99OrNpqvfASr939aXu/f39PP/885w/fz4Zca1pbm7mscce49Zbb+Wll15KZ46FNgXZgFatVjlz5gxHjhypC3oTLdURqg/+c1OmTEkDTBRFPPzww9x2221Mnz4dpZKFjNesWcP+/fsREY4dO8bBgwdTd3ffzpw5c1iwYMFlEYqwRqlQKDB//vxrIj5+v5qamniotiDv76uQOSS8Yf3V1aBRf317y5Yt4ytf+QrPPfdcSsiHhob4+7//e+bOncuKFSvq6vGyadpGpMq/fujQIX75y18yMDBQt83bbruNtWvXjiNW14rFixfzne98h9dee42nn36arq6uuiV9JhqL7Ou+T+F+T58+na9//escPXo0tYDwNwbPPfccf/qnf0pLS8u4FKNvLydZOa4WeYrwc4ywvsAYfxFKKoeKFpZ2zmZaoQPQVASUMkTohLSI1FQvguokldQzqXpyomuaVKIAVdg+fILNfR9TJUY7jaikIN7hklmMKCrOUVEWMYpRVWF75Rh//fFL/D8f/B2/OPkuh8pnGVEWazRihULV0eRAxBJHjlgnackkvemJVDJLUkuyDyn5UY56N9DMOAWPk/0aI09WCaIEI4ZCbLipay4zXAlXM7SQSQgwIkJ7ezt33XUX7e3tKdm5++67eeSRR+qKsxsFxWyA8XfuPgiGKUX/E97p+9quQqGQmkeGqkepVGLWrFl1JOHuu++mWCwCcOHCBTZt2sTbb7/NyMhIqkQtXLiQ1tbWS6bGwm2FfZuoPuhiyAZj3xfvFRX+DV+f7J9szVUjFela0dzczFe/+lW++MUv1imZ3d3d/PjHP+b48ePpZ7P1a1kC4c8TgLNnz/KDH/yAvXv31p0nM2fO5LHHHkvJT6P9uxasXbuWv/zLv+SWW25J++ZxpeMW7q+IcMstt/DUU0+laU6/v6+99hoffPBBuo28HivHZCInWNcJRCRdYNBoTRHFio753Fiajq4IiErUKCc1YjH23ToCwhgJGVOGgsfVKv1qhC1n93Es7kWiZP1CHcdo62cVKpwxDCs4bi/w3Nl3+b+2/IT//fFv2EU3vXoEFJiqASJiZTAqolQVorhKVLNOSEkUSZux1pQjRWySmYtWQ6zgSipffHuqVuBfE8goiKaVEkunzqNVXXtKMIvm5ma+8Y1v8Ed/9EeUSiUWL17Mn/zJnzB9+vR0ZpVXlC6nnie88+7q6qK9vZ0pU6bQ2dmZ/kyZMoWuri6mTZsGkNosZGu8gHEK2E033cTNN9+ckrEtW7bwwgsvMDo6ikhi53DvvfeO68tEfc0+n4yi8FCdC4lllmD61yb755P03/LkYerUqXzve99j9uzZ6XErFovs3r2b9evXMzg4WEdY/Xd9f8K+GWPo7+/n2WefZffu3en6gpCcG48++ii33357eh5m02rXAu/BNX/+/HS74TG8VM3dpV7XWvPUU09x55131qWry+Uy69at4+TJk6n1R3gjc6V1czlyhMhThNcBRKRO4UkK3jVzozZubZnHrsETDBqLczExQmR0MgPPL0wIGHE1ZjVGOpwCdE3OEoVWUCw2M2qr7Og7zNt9HzN7ZhetWuNUbV1DhLItc4Yh3us/yNvHdvD62Q/oNkO4dkcldkSFErESLAqjEy+rsosxWqHEUKgKVplkUmLCDbE6IVKia5Mhx7p1MfGqAVRNwRtTwKxz4DTzSlNZ2j6HAganEs+sq13gOQtrLYVCgSeeeIK2tjbmz5+f1iAB6R23Xz7mUm15TJ8+nT//8z9nwYIFwPgp6Uopjhw5wo9+9COGh4friopDdSNbZB5FEV/72tfYuXMnxWKROI4ZHR1NPZHmzZvH6tWrL1n0HCJbzO77eCUIVQv/N47jcYrLJwmf2vLqmCc+k4WQdPix/u53v8uzzz7LuXPn0rTaG2+8QUdHB3/4h39IqVQat1xROE7egf8Xv/gF77//fmqTAQk5+epXv8ozzzyTEjFPSifLpNOPk0dYo3U56lgjAplNjWqt+Vf/6l9x+vRpjh49ms7ePXr0KC+//DJ/+qd/2nCMcuS4WuQE6zqBUkJFhJLyhEvodEXunLmEl3t3M+L6sSiUMYkJaY20ABiRGodIUnIJ+ZBk8WUvalhAhBGl0QrOVPt55fg2Hpy6lJtMJ2WSGYiDdoTfDR7npbPbeOPkNk4Mn2Ko2TFacBgHKioQK8HZClorlK3VdylFVekkHelvKmsqlgO0E7ROCJwRiFzSfzvB9dGnFQES3/axyrMx9Sq4u0ezqH0GC4tTUBZ0lIxpZpSv8tiMBZFiscgjjzxS9144Iy47AyvdnwwpCdtbtGgRN954Yx3RyRItH5TD9IlHuNRK2PaqVatYtmwZe/fuTcaxFsiiKOK2226jWCyOW9bmYgErTOtcCcJap+xYVCoVXnvtNfr6+uqWk8mO02QH0kKhwF133cW8efOuuv6qEcJ9DMnoHXfcwYkTJ1i/fj0jIyMpsfzNb35DoVDgqaeearhuoG+nr6+Pf/iHf2Djxo2pqa1Xlb74xS/yZ3/2Z3U+ZJNdgwVjizj743K549ZIAQ1vBvyYWWuZPXs2jz76KM899xwDAwOpW/1bb73FsmXLePDBB/MarByThpxgfc6gGjzzF4uoltrTNWeniALL225gVss0Tg31E7syJVNgRDQKU5uRZ0Ela/XV7guBRA1Lpayaj4NL8o84AVcybD6zi5+f/i1PzF1Dp2qiZ3SIjcd38OKJD9njTjNgysRNVbQToriWZtSJZ5epqW2kNIfUTytV4mpeXbUQiXEk7u8kxEog9e3y6cRQfRNFMkNSIrT1azAmtV1KA85SchaFoitq5/9v78yCo7ruP/855/aiXWhFK0YCgQGBwYD8/zteIHGMbULFS9V/7Dgpx2V7EiepPKRqXlM1eZnHJJWaSlUyk6r8k7hspxLHjsdMORMHGxxiHAx4AcwirBgBZhdCS3ffe8483Huubl+6JZAECOt8qkCtXs4993Trnm//1jX1i6hNVIHrKzuNMY8phJj8Jmou6NHYp/hFfqKioXF3jxFi8bYxhW6bOkrRVPjo49ENOTqfiooK1q5dy6FDh8IsNsdxqKqqYvXq1eEmGU2vL3YOU3GjFRNMWmtyuRx//etfOXLkSCgwzDyNdcMEiE+GqOs0euyqqira29tpa2ub9HkVIrpOUctiSUkJ9913H+fOnWPz5s3h8y9evMgf//hHMpkMX/3qV6murr5EjB85coQXX3yR7du3562NEIKlS5fy2GOPhT0AoyJ7uoRjIatafOyJ1i8uzKPWOfO7+XfnnXeyd+/e8HwNmUym4N/flczDYoliBdbnmvyLQcRGgxB+S5qWsjrW1i7kwLk+cpUp9GiORNIB7ZcmGCuCNeYLk2FNdyKVDwKRpXIgNCPuKF4qxf868AZ/799LVbqc/vMn6R38jIulHrmU/41S4KBFEPsg/TpcIrSYCRBj5TwjIbVggttjsWLR+6J9AhVj1jY/4zAIZRcarU2Qvh/QrqVvxXIcQdJ1SODQ7FSzpnYhZTINQW9DtA7XcioYcWVuR3/GXR9xK018IzGPReOMgHHbi5hCnLlcLowdMpuRUoq+vj5SqRQtLS24rhtauxzHYdWqVWzZsoX+/n7S6TS5XI7u7u6wPIPZwK6Viy4usqSUuK5LLpfLc9W5rpsnFoo1kC5GVGyY+lRmjT3PC9fyalBMKFdUVPC1r32N06dP8/bbb4exTJlMhpdffpkLFy7w9a9/nZqamlD4vvfee/zqV7/i6NGj4RqYc2lvb+fxxx/npptuCl3YV8viV+z8LodiFqZCot18AXj44Yd5//33uXjxIp2dnTz++ONhH08juKN/P4WOaS1blomwAmsWYi43jhDUiFLum7OUf5Z+xNuZw0hHIJUClcN1fAuNETtjQeXjXFiEQopAoEj4bOQMp3MD/gdNKHS5JCMUOaVRjgApcVTCH1OZ+U3vxVto32LlBgIrof0aX9I3PqG1B1KitMYV2rdGaY3yXDzhUD7isK5jKYtKG0l4oBKYADTQCoJaYzONqIAYz/VmLAZGgBhLWi6XY9euXfz617+msrKSZ599ltbW1rzxzaZsrGDm9cYCMdFGdS2IHttkTJq1mKzwM+cVtfiZwrBGgF5tQRkX34lEgqqqKr797W/jeR67d+8OhbbrumzZsoWRkREeffRRqqurefPNN3nppZc4e/ZsKLLNmM3NzTz77LMsXrwYrXWeuLrREUKEZSEOHjzII488QlNTU547fjKuaosljhVYs4RCsdgiiFVaWX0T/153Mx99dpLT4iLCUaRygoT2rTt+0+Wx4PbxkFri4W86OTeLTgkyjiYrNUIppOfhKIEUAgW4KDw55sIT2j/WdGPa/QjMcSLnIv0WQojAyqUVDhKJgydSdKVb2dh6K5Ui5TtItfaD9hEIffUTceNujvj9UUxFePPYlQQhRwOyhRDs2rUrtG5IKfnxj3/Mk08+ybJly0LL0Pbt2zl+/Hje/D744AMOHz7M8uXL8+ZwrTatqBUr+tNY5xYvXpxXBX06hMPRo0d57733QjfTtRCV0TU15wdQV1fHM888w29+8xt27NhBNpslmUySzWbZtm0bZ8+epbKykvfff5/h4eFQDLuuSzKZZMWKFXzzm9+ko6Mjz5oTd63eyEgpWb9+PeuCPpdGXMWzIyFfoH9eRKbl2mAF1iyh2LYmhaBClHBfRw/vfHaQbe4n5BwXpCLlKZSQeEiUlr7RJhoTVWg8JdBOAk8oZNIh57ooJ3BTSQdHgPL8WCqFQmmFUE44x6luwMVe7QTWKiCs664Ct6ZG++4+Ebg/tV+vK+0mKdelfHXJF1hW2oYjEggpkFkXUolQtV4Ld0mxAPU4nuflpZtHCzWOd4xoWYFsNsvrr7/Oa6+9FjZ6Bujv7+fUqVOh662vry8MihbCLxCay+U4deoUmzdvZtmyZXnWgOtlEYjG3yilWLRoEY8++mheNuZU3FJCCLZu3cpHH31EJpOZ9JhXilnXeBFRpRRz587lscceI5lMsm3btrzCm6a/ZDTo3Yiru+++mwcffDB08UaJdxC4UUWWWTMjrKKZslHG+zu7np9ny42DFVizHC19a053aStPL72PI+//juOpQbTOIILCoH7bGYnURlEUjy3xhEJoiQOorEsaAVrh4gfGu55CSifo6wcOCVyti1Zbv1LMMEGB+bFq73osBs1/XtAbTwjw/GY3EvBcP3A+oQUV2RRfrF/GA62rKfP8oprac30Bhl+24lpaZgpZReLHNr32ou6OibLz4sHxBw4cYN++faE4k1KSTqf51re+xR133OFbJ3M5XnnlFc6cORNuTCatX2vNP/7xD15//XUeeOCBgm64q71mccuUcaGZeCnjEpsKUatRtBRA9PGrTTSb0JQdEEIwOjoalm9wXZe33norLBthPkcmSzCXy1FVVcXGjRvZuHFjWOzWPA75fQanM8D9ehA9D/MemczJeIxZ1KI7kfXYYolz4/6VWKZMKGqEptJLsH5uN1+ct4rKbBJHCzyhw1YxfmB5LKuvEFIj8Bs8g4dICDydQyqXhHZJJiXCJCAi0Z4Ki4ZCUMuK6ducTDkG5esoPOmfT9CyMHAdahJKID2N9BQJ5ZBWDh0VTfzHkrtp1ZUIKUni1/oSSccXnmaMa3SxvZw1GR0dZXh4ONxEUqkUyWRy3A3RxA5BvtvJ9BRsbW3l+9//PuvWrQvH2b17N1u3bg036rKyMpYuXUpJSUlYQ+n3v/89hw8fvqRFy9WmkBCNCq5oqYupBqJHLYSFSmhM9byj7sZCSQ7mthHCxoKZSqU4e/Yse/bs4cyZM8CY5UZrHVbhN5YrkxGaTqdDy2e0qG3082PGuREpllmYSqXySk+YdRovOSQ6psVSCCuwZjEysEyBAw7UaIcn2u/g9rIuyt1SlEyhHActHRSmmKfyTTzF0H5LHRQkkWjXQwoH7Ug8EbgWtPILRQiFksIfV5g5jeMq1EF7mgIf2zCuKv4SIOdIXEfiSsg6iqzjt9rRCBwlSDgCqR0yiQRuMkHaSdHmVvEf825naXkrJUiE5/diREi0BIREiOkpsng5xL9FR7+BR/8NDAwwOjoabgwVFRXhZpq3LpENWimVZ32KWmW6urp44okn6OnpCTenkydP8sorr+S5w26++Wa+973vsXjx4tBydvr0aV5++WXOnTt31eNYLte6EA3mn6olppCVbLx5XQ5x4RQfI255Me+XEQS5XI6jR4/y2muv8bOf/Yxf/vKXfPjhh3nuPcdxwrIcJjj/1KlT/OQnP+G3v/0tH3/8MUNDQ3nnEy21USi+LTp/M5fpZLrGKySuCsXhxd3x5m8iLnCj740VWpY41kU4i9Hat0Y5gNKapEyyMjmXr3fewcmPL/Cu7kcq7deGcoJinjhBraki6cvmpxhrUaOECF12EGtdEymlMCECRLHjFhgkNNCpIOZKCDzA87sqktSChBaMuBqSglxCUJJNkMiWcG/LajY238JcUYL2NDoRWK9UsMlReAO82kTFVCE3x7Fjx0I3mFKKqqoqysrKLhknuqlks1my2WwYwAy+a6S7u5snnniChQsXhpuxCZTev39/aJmqqqrinnvuoaWlhQ0bNnDkyBEuXrwIwK5du1i6dCnr168nnU6HbqxrWVm9EDPVxVNos4++3/F6aOb+TCbD3r172b17N3v37qW3tzeMqUsmk2F5jWiwerTkhuu69Pf3c+zYMd577z1WrlzJ6tWrWbJkSdgIOWq1KlQzLZpFOhMoJIAKuaqLvS76t1WoKn+xz5DNQLQYrMCa5WitEVqQEP43+3KnlPX1yxjMZvnXhy8yLLLkyiBLDkdrXO2hhfCtX8XGxC/gaUo8xC1LOq+PYRCAfnmzHfcRzaUmWd/1qHwTmdQkEHgCHCQIgecppFNCliyOC+kRh3uaVvKNJffQSiVJT6AdSVaYDEeJHmce0038Ym1uR61HRuiMjIxw8ODBMJMwkUgwd+5c0un0JWNFhVpzczMrVqzgnXfeoaSkBIC1a9fy7LPPUl9fn+cy+de//sWWLVsYHR0Nj71y5UqWL1+O4zh0d3ezcuVKtm7dilKKCxcu8Je//IXFixfT2dk56WrtU6GQy3CmEXddRSlU/NUIgIGBAXbt2sWbb75Jb28vAwMDOI4TJh44jhPG5OVyORobG3nooYeoqanhueeeo7+/Py/eKJlMcvToUT799FO2b9/OwoULWbduHbfffnte+5p4X0fT5LqQZWemUexvKo5Z81wuRyaTyasTFhXChSyZM/n8LdcOK7BmO8a6pP0sPw2UixI2Na9kyMnwn3v+H/tHziDSoIRCCP95xWIwJGNix3cXBofRkQD08L9pPA3GyZTUvoVLCkALHKWRSuPi4Wog7ZBUKepGHNZVL+G/rdjIAjkHR0l0oAQd7TeYFkIwqjxScrqrdRU5rwKbrokZMRd1c+E/cuQIfX195HI50uk0FRUVLFiwIAzmLrRBAzQ2NvKDH/yAn//85+zZs4eenh6efvpp5syZk2cxGRkZYfPmzfT19YWuttraWjZs2EB5eTlKKebMmcOGDRs4cOAAJ0+eRGvNgQMH+NOf/sR3v/vdsAZV1EJwtQOmC63hdLqcohvtZDfW+DgGYzExFiPXdRkaGuL48eNs3bqVnTt3cvr0aUZGRkIrS1Rc5XI5UqkUdXV1rFmzhk2bNtHc3IyUkgULFvDqq6+ydetWhoeHyWazeaUKTp06xZkzZ9i5cye//e1vufPOO+np6aGpqYmysrK8WmeZTCZs5QQzQ2TEj1/sbwko+B4aAWni2oy1z6xT9MtC9Hxv5AQAy/RiBZYFDw3SD/ZWyhdQVZTwSNNqlKv5z0NbOZz9jExK4EkPpbyioe6OMkHkwq8VFda3ijwp5hbUgetPmPgGEVRUD2pMha4+YoNEfwsEnMa4C02n6sCdJ7TvmlRBBiASKSROUqCyLnW5Uu6rWcL3l9zHEjEH4clQfEqtSEhhou+R0gmKoV77wO2oNcZYEkya/VtvvcXp06fD++vq6ujo6AhfX0xgKKWora3lqaee4qOPPqK7u5vq6upL4m7eeOMNtm3bFr7ecRzuuusuOjo6kFKGImDJkiWsW7eO559/PnQtbtu2jY6ODr7yla+EG/jV2oyLxUIVE1XTEYhufppzmUzsVXSO0ay9bDbLuXPn6Ovr49ChQ+zbt49Dhw7lJTMYC1K0HIOpxr5y5UrWrl3LkiVLQoGrlKK5uZknn3ySnp4e3njjDfbu3cvZs2dDURZ1Hx49epQXXniB119/nUWLFoUWyba2NqqqqigpKUFrHdbNmsg1N1UmO95473Wxz8jg4CC9vb15LlDHccLiq4VElsUCVmBZACcoJqoIsoW0RiOpUZVsbFkNwuH3B7dyYPQ4gymNmwAo7Hbxmy8bYTQmsHSQjXhpIPrEm1veM4QOGzGHVjEddQ369jOT+aijF/ogk1AKXx4lPUggKc8mub/tVv7r/HUsTjcBAsy3c+27BrUOsii1Xwn+mpivIkzUXHfnzp288847YfByLpejp6eHurq6gs+PjmO+iTc2NtLQ0JB3vxFZe/fu5eWXXw5dg67r0tnZyb333kt5eXneuMlkkg0bNvD++++zb9++0M3yhz/8gfb2dlatWnVJxt10bkyFrErR+6KZf3FhM9njRI81GeI9DYeGhvjss884duwY+/fv58CBA5w6dYrBwUFc181LRDAWLiMAysrKaG9vZ82aNaxatYq2tjZKS0vzxJuZayqVYuXKlXR1dbFv3z7eeecddu/ezcmTJ8PxzZwAzp49y7vvvsvOnTupra2loaGBrq4uFi1aRFNTE3V1dVRWVoYiOio+p7I+UyEet6aUIpvNhutV7DUmI3f79u3s27cvr79nOp0OrXhWWFmKYQXWbEYIBBopjKVHoIKYJYEgKRTNupyHmv+N+am5/M8P/w/vZA7gOlm0VAilkTJFVkMagRYeWSlxglw/D3y/XBDhHhdXQgeWkMDapU0OYSjKVH7wurFSCSN4zJgykoko8YSLFALHcxCuAKkQEpKexnEkrtJ4SpLWSeblynl4wZf4yvzVLE7UI3QCR2hQIKQxtUXcgSIi5q7TZhHd9KSUHDp0iF/84hecP3+edDqN67rMmzePu+++O0y1LxR4HHeVFIrPAjhx4gTPPfccJ06cCMerqKjg8ccfp6WlJc/KZW7X1dXx1FNP8aMf/SiMC7pw4QK/+93vqK+vp729PS+mZzyKZW7Fb5ux4q62aCNq8Bsg9/b2hkH35pyulOixjCAxZQ+M6DHv0XgJEcYVNTg4SH9/P4cPH+aDDz7g0KFDDAwMhDF1cbETzQLM5XLU19ezdOlS1q1bR1dXVyh04uK8kCUznU6zZs0auru7OXbsGFu2bOHdd98NkyaMS9p13XA9T58+zcmTJ0MRXVlZybx581i0aBELFiygvb2dhoYG0un0pIVI9L2PrmMh8Ra/Hf/dCMsLFy7w2muv0d/ff4mrz7hVM5kMQ0NDnDp1ivPnz4ctlsznpKKigoaGhhkf22e5vliBZQkLcmoESoJG4igNSlEiEsxBcFv9Aub8+yP87wP/lz+f3cWgGCWZTKNyGkf7r/YcjXJ0mLUHfrV07Rc48F0T5MdL+UahUDmhhAhb2pgCoXmFTYMALi102P7G1LXyhD93HZSD0AiSSQeFxtUZElJS6iVJegnKvRK6UnP5xi138eW5t1CvSklkNTqhEEEpBt+ROHOIFpE0m0Uul2Pz5s2cO3cudFlUVFTw2GOP0dTUNKmK29FNY2hoiD//+c8cPHgwzKKSUrJhwwZ6enqAwkHYAAsXLmTTpk288MILZDIZpJR88sknvPrqq3zjG9+gvLz8slqvmM0v6nqKxiXFn2ueb2LTjLAybp0dO3awf//+ghv0lWAEluM4DA0NMTAwQDKZDAXI5Yxr5js6OspLL73E3/72Nz799FNKSkooKysjl8vluf/M8cyxk8kknZ2d3Hrrrdxyyy10dXWFNZ2iGW8mezN+bHMeqVQqFFIdHR0sWLCA++67j3/+85/s2LGDffv2AYQJEyYOCcaE3vnz5zl37hy7du2ipKSExsZG2tra2LhxY5gEcaVEP4vGOhu3SE0kYA3Rz86BAwfYsWNHnpU2KmKllHkuQCCsC+c4Dh0dHVRWVl7x+VhmF1ZgWQA/yN1YizQCV0JCJiHrUuo4lCrJbel2vEVf5txHI7x9bi+jpZKc9hBS4Kkxa5NxBYpAWCnMRqMRMt/aEQa+i3ipBY3UQch8RLAZhFR+L0NH+LW58F2dAoFWY7FXOZUjiUepEChPAQ4Neg731Czlq523sbZ6HmW6BNB4CVDCI6lBiPHyJK8PZiOIVmeXUnL//fdz8uRJ9u/fj1KKL33pS9x2223A1NxWruvy9ttv89Zbb4V1soQQLFu2jA0bNhS1ihi01txxxx188MEHfPjhh2Gw8NatW+nu7ubOO++cUIREY7Wi9ZWKZatFLRlGZJj7TbXu4eFhhoaGJu0aNOND/uYerTUVndfllKRwHIdUKsXg4CC1tbWhCytapd2cR1lZGbW1tSxatIjly5ezaNEiGhoaQpEUfU/Mv/EaGJt1iDbmzuVytLS0sHHjRr7whS/Q29vL7t272b9/PydPngzdlGZdo8dLJBK4rsvx48c5c+YM69evv6KemPG5RccuNO8rjX+qqKigs7OT3bt3h/cZ4Rr9rJlyJ3Hrbk1NDXfccQdVVVV5c7RY4liBNcsRBG42rZFaBAHn/iNKgHKE32LG1eikpCvdwr/VdLHv7BH63QxI6b9GGKuTClx8Eqn9MZzAdYcG7THmWtOBgUroWKCV2USDjUnkP6zx47x0IKIkIJQviDzhkVR+T0QlPHAEWmkc16HeK2dpxTw2dX6BL9beTEuymhIlkELiCr8vYsKvxODPTVwq7K4XcfcQjG06XV1dfOc73+H5559Ha80DDzyQF0g+WQuN53kcPnyYixcvhtllc+bMYdOmTcydOzd0bcWD1aPHa2ho4J577uGTTz4Jx2lpaaGhoeGy5xQ956hQiFugigkuI06iQfvx51yp0IpXpzfHiQuVidbePJZOp+nu7uaNN97gxIkTvrU32OQTiQSlpaXMnTuXBQsWsGLFCjo6OmhoaAjjgExsUHR9zO3oOsbdwHHMc5LJZDheTU1N6D48c+YMfX19HDx4kL1793Ls2DEGBgbyGmebf8lkktbWVtra2sLzmUyGnRHW0deajMr4OsbPs1g8XnNzM0CeiDK/x8eMfrFpamrioYceymsWbrEUwwosCxhRhEaGFa40Ugm8QMHopENKCFJaklGK0aDlTFr5FyBHCpQbFKkUvujK87MJgY4EpQshIjFZJnsQAnuXf7dUYy11zDO1H8CupCDhSVIegbASuAKkziGUCOPK5KimOpemq3oe98xbw5fql7C0tIW0KxDaQeGCp0g4AkTCd0sqv6einEEOQrNJGOtAfANvaGjg6aefDuOjTE2jqTTlTafTPPjggwwPD/P3v/+dbDbL/fffz6233hpmDcbnaFx30Wyynp4eent7efHFF2lvb+fJJ59k8eLFl1iYChHdmKObpTn+RJucEIK6ujpGRkby7isUu3UlROcRLdxp1sRU0L8c64qZT2trK/PmzaOvry8s7mlqlK1atYr58+dTXV1NaWlpnniKi4+o2yvKRJ8D40Y0nytz27j2UqlUKJjWrl3LhQsX+Oyzz9i/fz979uzh8OHDDA4Ohq7kXC5Ha2srNTU1U4q/igqjeE/EQkJ7vHU2n8uOjg4aGxvJZrPh4/G+kkIISkpKKC0tpb29neXLl7Ns2TLq6uqm3MfSMjuwn5JZjsYPZBKBW01oFVijRJBMl8DTGuEItOsxwCiHRk9xXmbISUXaVQih0VrhaIWQEg+NJyTSkeD5UVd+DFbwjVJphOcH10sh8ALlJTUoITG13gu2xRGA1iQ8v9+hsWL5jk2B1gmEdkggSHqCznQ99960mg3z17AwXccc0nj47XFAk3ASePhzdpR/AC0DTXgdsgULERUYJqA5+q3abIzR0gpRt8+VulCiz2tqauKZZ55BCL9a+Je//OUwBmhkZCSsEh/f5M2m7HkepaWlbNiwgd7eXh599FGWLVt2yfPiFApUN5ujCbY2riyzRmasqBWpoqKCH/7wh3mPmXEnK64KzTU+RqHg7PHeA6019fX1LFmyhKNHj7J48WJ6enpYtmwZtbW1l7yH8fc5bpkqZPGMW3bi527WKP5acwxT4sHzPEpKSkin0zQ2NrJ8+XIefvhhjh07xp49e9i7dy99fX1cvHiR+fPnU1paWnSdLmdtlVK0tbWxadOmsPm0lJK2trY8q2T8nOLuveg5dnR08NOf/jQvASL6HpnzNb01zZpH18dimQihJxuEYLnhCQoaBDJFBLFOgaoQ4OG30EkIQQ6FIxzeHurlv+95np2ZXi4mXL/fIIDnktLaDzCXDjkkCe34okl7OCIoQir9MXUkUFULPxTeTzYUaBHMQvm+R004Jd8NqTQlnkfOkWQdgdaChCdI6wTlXimtopIl5Y3c0nQTa1puZqFspl6Wk8B3O2alJi2kHycmBCizBg5ag5IEDkiuS6agIeqC27JlC8ePHw8369tuu42Ojo684OViG+vlCqxCFgFz39DQEK7rMmfOnIKvMceJ3g/58UeDg4OUl5eHv0+URRi3THz88cdh3IzWmsrKSu66667QYhctqBo9bnzDnU6KWVOilrdiSQDRMcx7PTQ0xPDwMPX19XlWkmLrPN55Xcn5TnZt4q8z53H+/Hn6+/upqamhpaXlsjNGo+MYzLpGrbHx7L8o473f8ddF3Y+FRHchET5dwtzy+ccKrFmM1n7TFyWC7D6tSAg/UFzhl2HQwgHtIgW4IsFzp3fwPz54nmNygFEyeI6DEEmEAke5KJWkJpeiOVlNS0UNZYkEpzMDDIwOcTEzzHl3mEwCvJQMsg5NHJVGKOWLLyHQwvGD5H1DE1r71dQTWiC1RrgeKIeULKEqVU69rGBedROrKjvoKmtkeUULLek5lIgUUvm1sxAShEJIDSIImBYCoYONzETZm9ir63z9jMfJFLrIRxlvE5/scaOb0ESlHuJjjHf/eFaGQs8vtqlFj3MjWxaKxURB4TWeSZt7MStZ/PEr/XzGx41TKL7qSrmcz9VMWmvLjYV1Ec5Sxi4gwQVGB/WwNJgegph2MMJvoTNCjqNDJznjDQOadFAT3RWKtE6QyjrUyjncWb+Ae1tWsLi6jZRMcNobpm/0DP+6cJojgyfoHz3PidwAJzMDXMiOBALK9YPZBUgp/DqfCrRSaAWOdkiJJCUiRSqRoqG6jrZkDQtL6lhU3khnWQPtFY2Up0pIkyKtE0jh+C0Ig/MSBIJKgNbS/11H+iLGys3PtMvqtW6QXMxiEuVKLR+FLGQTHQPG4oomcnl9HihkgTHrdjWscJNlvO/m0blORfjExygkqCZjI4i/Ju5mtVimAyuwZjsaHMireE4QE+UR1IHSAqHgoh6i99QnjMgsWemSEhKRTMGIJj0k6a6Zx3/pvJO7mpYxT1RSopNoDzodTU/pfDI1LhdEljPeMKdGBzg1OsBQboTjg6e4MDrEoDfCqHJxg8wex0njCIcKp4SaVBmNpXOoK6miPFVCQ2UNc5NzKPcEFSJJWqb8CWsX0wYHY5kzqevSXECNs9GXUfHmzTNFWl2u5WK6N4S49arQcePHvFKRZX5ONPdCloRCLsCZIjqmk2Kux5l8rtG5Tcc8C7m34/FmhiuNMywksuLHsFimghVYsxwRuATHMJHdgRVLa5QWaEfTlz3Lh+c+JZPW4DiQlZTlksxPN3J/52rWN6+gO9VEhZI4SuI5gkRS4GgNSpMgSZlI0uJUIsvnost8aTPapBjVLqPKJasUXiSWSApBWjikpEMpDkmk7yLUgCv8+Untuxalf1y/V6Af5+VI0AlwlYeDw5iWEmEgfzSbUcwE32CMQkG8V3MzKLZJFopRmeyGFj2n8cYoVA7hSo57IxFf3/Hii2YCxcR+MTfwVMaOflam8jmc6BiTHctiKYQVWLOUPHP4WOhRBImj8Yt4ChjRLh9cOMqJ0fOkEykSrqQtVc+6usV8pXklqyrnUS3KkVr6vfqkL2Gk9iu5I0AKGbSzGbMiaaAESJOiUqYQcqxMRN58AtelRgX1qRx/wo5ACh30DATPcfC0xgnEktb+SGMNmsMVCH9cKjBnDsU2kKu5CYxnhbgSQTXRfZdjjSkmJD9vm2Ch9/lGPMdC85/qeRT6nFyNtbkR19sys7ECa5ZzyUUl+rsAFQiXpNCcv3iWtKtoHS3n1rmLeaTjdm6vmk+t8F15EulnA0ox5l708/4wKYAiEE5CmApX+C7I8HZwQBGotNCVp9FaICJlG0RwM2y1I/w2O4SvCESeIMgSHDs/f99W/k9RODh6plxur8U364msDNcz9ice3G83wpnNVCxXFsvnCSuwLEABMaE1nhAkhASt0Tg80HYnZ/qGaJvXzl3zltDpVFLhSTxXoRMOo0JTGgSqJyJ2oaiFKB7fZDxyoaVCmGfFRY+g2LU6T3QVcPGJQscVcGmnwbHYrJnEtdikJjrGTBBX13MelivHvleW2Y4t02ApiNaasI1u0LLG036tqpz2y6c7aCQCR0jQEldBUgSFRYVtI2GxWCyW2YsVWJbieCp092nt11UXWiJMrSoZtK0gcM0JB609NBopJOIGrktksVgsFstUsALLUhQXP/POiCgBeMqPsdIE/mUdVEE3sfJCoEzGj7QWLIvFYrHMTmwMlqUoCS8oYwAoATm/nDogSODHoSs0blCQNOFptAShZ3atHovFYrFYrjbWgmUpikZFmin7IkorDyFAaI1AooXAQ4f1tDx84SXFTA0Zt1gsFovl6mMFlqUoClM6IfzPz/hD+WJLBxl8QW1Sj6AifOAuNCLLYrFYLJbZhhVYlstmrB4TQLRNRbRMgpVUFovFYrHYGCzLZZHf84ugOGfkPhF9MB8ruiwWi8Uy27B59JYrp1BbDy4t5mmwRlKLxWKxzDasi9AyKUxL6OjvYGOuLBaLxWIBa8GyTJK4kCqUMWi1u8VisVhmK1ZgWa4aNvbKYrFYLLMVK7AsFovFYrFYphkrsCwWi8VisVimGSuwLBaLxWKxWKYZK7AsFovFYrFYphkrsCwWi8VisVimGSuwLBaLxWKxWKYZK7AsFovFYrFYphkrsCwWi8VisVimGSuwLBaLxWKxWKYZK7AsFovFYrFYphkrsCwWi8VisVimGSuwLBaLxWKxWKYZK7AsFovFYrFYphkrsCwWi8VisVimGSuwLBaLxWKxWKaZ/w8rcA+vYnHKxgAAAABJRU5ErkJggg==";

// src/assets/alipay-qrcode.ts
var AlipayQRCode = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAMgCAYAAAD/YBzEAAAACXBIWXMAAAdiAAAHYgE4epnbAAAExWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDI1LTA0LTA2PC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPjVhNDI2MGUyLTRiOWMtNGFlMC05YTYwLTIwNWZjMmRmMDcxMTwvQXR0cmliOkV4dElkPgogICAgIDxBdHRyaWI6RmJJZD41MjUyNjU5MTQxNzk1ODA8L0F0dHJpYjpGYklkPgogICAgIDxBdHRyaWI6VG91Y2hUeXBlPjI8L0F0dHJpYjpUb3VjaFR5cGU+CiAgICA8L3JkZjpsaT4KICAgPC9yZGY6U2VxPgogIDwvQXR0cmliOkFkcz4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6ZGM9J2h0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvJz4KICA8ZGM6dGl0bGU+CiAgIDxyZGY6QWx0PgogICAgPHJkZjpsaSB4bWw6bGFuZz0neC1kZWZhdWx0Jz7mnKrlkb3lkI3nmoTorr7orqEgLSAyPC9yZGY6bGk+CiAgIDwvcmRmOkFsdD4KICA8L2RjOnRpdGxlPgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpwZGY9J2h0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy8nPgogIDxwZGY6QXV0aG9yPuWImOWuhzwvcGRmOkF1dGhvcj4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6eG1wPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvJz4KICA8eG1wOkNyZWF0b3JUb29sPkNhbnZhIChSZW5kZXJlcikgZG9jPURBR2p2cmd1dHI0IHVzZXI9VUFHVWlnekRfT1EgYnJhbmQ9QnJpYW4xMDMwNTIzJiMzOTtzIENsYXNzIHRlbXBsYXRlPTwveG1wOkNyZWF0b3JUb29sPgogPC9yZGY6RGVzY3JpcHRpb24+CjwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cjw/eHBhY2tldCBlbmQ9J3InPz5EirLmAAH8g0lEQVR4nOy9eZDu2Vnf93mec36/9+3uu8y+aBZpRjNICGnESEKKJITCIiCYQuz8YWwqrmwOSSV/mLJj4lTZVTipsgu7SEhSrsQQJ3EqlMDxEspCLGGRhAVYAgkJbWhlpNEI3Vnu3O73/Z3zPPnjOb+3u+99e+ZeTYN0VedTM7fv7e73t//O+Z5nlTv+enU6nU6n0+l0OqeGfqkPoNPpdDqdTucrjS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6nU6n0+l0TpkusDqdTqfT6XROmS6wOp1Op9PpdE6ZLrA6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kRbPJXGmn8x7xt8rj4wfbMR6d2emnUccx13T3OHQtNh52/UfpDWy/zftMayGMo84F32TRWm549nVnhV9v+7CsESJUaL0wSoxErhCcH5+nvn5+e59e+Vbq9UYHx/vEZ5mgmu32+zdu7cvXpGJndRoNJa0JV0pxa5du6jVaj3aASGyXWzLly/vW9WaiX1iYqJQKNv1t2G0JSasQZ4v0vT0NO12e0Hh7BIm3/dZuXJld9eUjbGxMaanp9mxY0eP0DbEyPM8jjzyyJ50TdmSJGHfvn25wkZrzfT0NHv37u1pC9NHZhOB0baMAkIIJicnu87SC2lCipCntWq32+zcubNP06J1FtJjYmKi+6y5Zxy+V69e3defpk+Wcoak1tkGi71793a/GXustVotli1bdlhIgPkWx8bGmJ2dZceOHQRB0OODqJSiWq2yatWqnrKa36tWrWLPnj19/nqD6m/G38TEBKtWreqmZ2vv5ufnmZub65bT/i7cb82ME1PmZrPJjh07emKvmfdNfx8O8lri/y6UBKvESOBqGL7whS/w+c9/vmc3lRH073nPe/iHf/iHvhVumqb867/+K1dccUV395tLeGZmZpYkZLdv386rXvWqnthNZnddpVLh5z//OVNTUz3CwAiVarW66MlXSskJJ5zAN7/5TY499liEEN08TSyhP/zDP+T/Y+/bg6u6qv8/577yJiEhBHmEJLR0AtpiBxmZsXWcEXAcOwg0oyi2MNbaOpapbenPDpXqIK0UbXVEbO0gMhXtSGuq1T6ctsOIStVaxMcUWh4BE5AAhjRAcnPvPef3B7MO66yzz+veEwj97s9MJsk5+7332euz19p77VdeecX3LjRO9Igk1NXVYffu3Q4CSr8HBwfR0dGB7u5ul3YumUxizZo1WLduneO+PRJu+/btw7Jly3D8+HGX2XZwcBDLly93CE1KO5FIoK+vD0C8J9oymQy+853v4IYbbnDto4kCGZfcDKxatcp+Ru2cz+dxyy234MEHH7TjcmJx/fXXY8+ePa4TbvR/bW1tZDOmYRj45z//idmzZyt9l1VUVOCll17C2LFjI6VbDKieuVwOt912G/bs2WN/h1SvXC6H1atX4x//+IcrLgCcOnUKc+fOxfDwsGMx4/fdJpNJJJNJfO9738MPf/hD19g1DAMbN27EunXrlP7fGhoa8Itf/ALTpk2z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";

// src/assets/kofi3.ts
var kofiImage = "data:image/webp;base64,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";

// src/modals/DonateModal.ts
var DonateModal = class extends BaseModal {
  constructor(container) {
    super(container, i18n.t("DONATE_MODAL_TITLE"));
  }
  createContent() {
    this.createCommunityStats();
    this.createPaymentChannels();
  }
  createCommunityStats() {
    const communityStats = this.element.createDiv({ cls: "book-smith-community-stats" });
    const statsCard = communityStats.createDiv({ cls: "stats-card" });
    const header = statsCard.createDiv({ cls: "stats-header" });
    header.createSpan({ text: "\u{1F4CA}", cls: "stats-icon" });
    header.createSpan({ text: i18n.t("COMMUNITY_STATS_TITLE"), cls: "stats-title" });
    const statsList = statsCard.createDiv({ cls: "stats-list" });
    statsList.createEl("p", {
      text: i18n.t("COMMUNITY_STATS_USERS"),
      cls: "stats-item"
    });
    statsList.createEl("p", {
      text: i18n.t("COMMUNITY_STATS_WORDS"),
      cls: "stats-item"
    });
  }
  createPaymentChannels() {
    const channels = this.element.createDiv({ cls: "payment-channels" });
    const tabs = channels.createDiv({ cls: "payment-tabs" });
    const wechatTab = tabs.createDiv({
      cls: "payment-tab active",
      text: i18n.t("PAYMENT_WECHAT")
    });
    const alipayTab = tabs.createDiv({
      cls: "payment-tab",
      text: i18n.t("PAYMENT_ALIPAY")
    });
    const kofiTab = tabs.createDiv({
      cls: "payment-tab",
      text: i18n.t("PAYMENT_KOFI")
    });
    const qrcodeContainer = channels.createDiv({ cls: "qrcode-container" });
    const wechatQR = qrcodeContainer.createDiv({ cls: "qrcode-item active" });
    wechatQR.createEl("img", {
      attr: {
        src: WechatQRCode,
        alt: i18n.t("PAYMENT_WECHAT")
      }
    });
    const alipayQR = qrcodeContainer.createDiv({ cls: "qrcode-item" });
    alipayQR.createEl("img", {
      attr: {
        src: AlipayQRCode,
        alt: i18n.t("PAYMENT_ALIPAY")
      }
    });
    const kofiQR = qrcodeContainer.createDiv({ cls: "qrcode-item" });
    const kofiLink = kofiQR.createEl("a", {
      cls: "kofi-link",
      href: "https://ko-fi.com/bruceyeban",
      attr: { target: "_blank" }
    });
    kofiLink.createEl("img", {
      attr: {
        src: kofiImage,
        alt: i18n.t("PAYMENT_KOFI"),
        style: "height: 50px;"
      }
    });
    wechatTab.addEventListener("click", () => {
      this.activateTab(wechatTab, wechatQR, [alipayTab, kofiTab], [alipayQR, kofiQR]);
    });
    alipayTab.addEventListener("click", () => {
      this.activateTab(alipayTab, alipayQR, [wechatTab, kofiTab], [wechatQR, kofiQR]);
    });
    kofiTab.addEventListener("click", () => {
      this.activateTab(kofiTab, kofiQR, [wechatTab, alipayTab], [wechatQR, alipayQR]);
    });
  }
  activateTab(activeTab, activeContent, inactiveTabs, inactiveContents) {
    activeTab.addClass("active");
    activeContent.addClass("active");
    inactiveTabs.forEach((tab) => tab.removeClass("active"));
    inactiveContents.forEach((content) => content.removeClass("active"));
  }
};

// src/modals/InspirationModal.ts
var InspirationModal = class extends BaseModal {
  constructor(container) {
    super(container, "\u521B\u4F5C\u7075\u611F");
    this.subjects = [
      "\u4E3B\u89D2",
      "\u914D\u89D2",
      "\u53CD\u6D3E",
      "\u8DEF\u4EBA",
      "\u52A8\u7269",
      "\u795E\u79D8\u4EBA\u7269"
    ];
    this.actions = [
      "\u9762\u4E34\u6289\u62E9",
      "\u906D\u9047\u5371\u673A",
      "\u83B7\u5F97\u673A\u9047",
      "\u5931\u53BB\u91CD\u8981\u7684\u4E1C\u897F",
      "\u53D1\u73B0\u79D8\u5BC6",
      "\u6539\u53D8\u547D\u8FD0"
    ];
    this.settings = [
      "\u5728\u9ED1\u6697\u7684\u68EE\u6797",
      "\u5728\u7E41\u534E\u7684\u90FD\u5E02",
      "\u5728\u9065\u8FDC\u7684\u672A\u6765",
      "\u5728\u53E4\u8001\u7684\u738B\u56FD",
      "\u5728\u68A6\u5883\u4E2D",
      "\u5728\u5F02\u4E16\u754C"
    ];
    this.emotions = [
      "\u6050\u60E7",
      "\u559C\u60A6",
      "\u60B2\u4F24",
      "\u6124\u6012",
      "\u5E0C\u671B",
      "\u7EDD\u671B"
    ];
    this.techniques = [
      "\u4F7F\u7528\u7B2C\u4E00\u4EBA\u79F0\u89C6\u89D2",
      "\u4F7F\u7528\u5168\u77E5\u89C6\u89D2",
      "\u4F7F\u7528\u5012\u53D9\u624B\u6CD5",
      "\u4F7F\u7528\u8C61\u5F81\u624B\u6CD5",
      "\u4F7F\u7528\u5BF9\u6BD4\u624B\u6CD5",
      "\u4F7F\u7528\u60AC\u7591\u5143\u7D20"
    ];
    this.basicInspirations = [
      "\u5C1D\u8BD5\u4ECE\u4E00\u4E2A\u4E0D\u540C\u7684\u89D2\u5EA6\u63CF\u8FF0\u4F60\u7684\u4E3B\u89D2",
      "\u4E3A\u4F60\u7684\u6545\u4E8B\u6DFB\u52A0\u4E00\u4E2A\u610F\u60F3\u4E0D\u5230\u7684\u8F6C\u6298",
      "\u63CF\u8FF0\u4E00\u4E2A\u573A\u666F\uFF0C\u4F7F\u7528\u6240\u6709\u4E94\u79CD\u611F\u5B98",
      "\u5199\u4E00\u6BB5\u5BF9\u8BDD\uFF0C\u5C55\u793A\u89D2\u8272\u4E4B\u95F4\u7684\u51B2\u7A81",
      "\u521B\u9020\u4E00\u4E2A\u6709\u8DA3\u7684\u53CD\u6D3E\u89D2\u8272",
      "\u63CF\u8FF0\u4E00\u4E2A\u4EE4\u4EBA\u96BE\u5FD8\u7684\u573A\u666F\u8BBE\u5B9A",
      "\u4E3A\u4F60\u7684\u6545\u4E8B\u521B\u5EFA\u4E00\u4E2A\u5F3A\u6709\u529B\u7684\u5F00\u5934",
      "\u5C1D\u8BD5\u4F7F\u7528\u4E0D\u540C\u7684\u53D9\u8FF0\u89C6\u89D2",
      "\u4E3A\u4F60\u7684\u6545\u4E8B\u8BBE\u8BA1\u4E00\u4E2A\u4EE4\u4EBA\u6EE1\u610F\u7684\u7ED3\u5C40"
    ];
  }
  createContent() {
    const content = this.element.createDiv({ cls: "inspiration-content" });
    const cardsContainer = content.createDiv({ cls: "inspiration-cards" });
    const selectedInspirations = this.getRandomInspirations(3);
    selectedInspirations.forEach((inspiration) => {
      const card = cardsContainer.createDiv({ cls: "inspiration-card" });
      card.createDiv({ cls: "card-icon", text: "\u{1F4A1}" });
      card.createDiv({ cls: "card-text", text: inspiration });
      card.addEventListener("click", () => {
        this.showNotice("\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F");
        navigator.clipboard.writeText(inspiration).catch(() => {
          this.showNotice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u590D\u5236");
        });
      });
    });
    const refreshBtn = content.createDiv({ cls: "refresh-btn", text: "\u6362\u4E00\u6279\u7075\u611F" });
    refreshBtn.addEventListener("click", () => {
      cardsContainer.empty();
      const newInspirations = this.getRandomInspirations(3);
      newInspirations.forEach((inspiration) => {
        const card = cardsContainer.createDiv({ cls: "inspiration-card" });
        card.createDiv({ cls: "card-icon", text: "\u{1F4A1}" });
        card.createDiv({ cls: "card-text", text: inspiration });
        card.addEventListener("click", () => {
          this.showNotice("\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F");
          navigator.clipboard.writeText(inspiration).catch(() => {
            this.showNotice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u590D\u5236");
          });
        });
      });
    });
  }
  getRandomInspirations(count) {
    const result = [];
    const shuffledBasic = [...this.basicInspirations].sort(() => 0.5 - Math.random());
    result.push(shuffledBasic[0]);
    for (let i = 0; i < count - 1; i++) {
      const combinationType = Math.floor(Math.random() * 4);
      switch (combinationType) {
        case 0:
          result.push(this.getRandomElement(this.subjects) + this.getRandomElement(this.actions));
          break;
        case 1:
          result.push(this.getRandomElement(this.settings) + "\uFF0C\u63CF\u8FF0" + this.getRandomElement(this.emotions) + "\u6C1B\u56F4");
          break;
        case 2:
          result.push(
            "\u63CF\u8FF0" + this.getRandomElement(this.subjects) + this.getRandomElement(this.settings) + this.getRandomElement(this.actions) + "\u7684\u573A\u666F"
          );
          break;
        case 3:
          result.push("\u5C1D\u8BD5" + this.getRandomElement(this.techniques) + "\u6765\u8BB2\u8FF0\u4F60\u7684\u6545\u4E8B");
          break;
      }
    }
    return result;
  }
  getRandomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
  }
};

// src/modals/CommunityModal.ts
var CommunityModal = class extends BaseModal {
  constructor(container) {
    super(container, i18n.t("COMMUNITY_TITLE"));
  }
  createContent() {
    const content = this.element.createDiv({ cls: "community-content" });
    const intro = content.createDiv({ cls: "community-intro" });
    intro.createEl("p", { text: i18n.t("COMMUNITY_INTRO") });
    const features = content.createDiv({ cls: "community-features" });
    this.createFeatureCard(features, "\u{1F4DD}", i18n.t("FEATURE_SHARE_TITLE"), i18n.t("FEATURE_SHARE_DESC"));
    this.createFeatureCard(features, "\u{1F465}", i18n.t("FEATURE_DISCUSS_TITLE"), i18n.t("FEATURE_DISCUSS_DESC"));
    this.createFeatureCard(features, "\u{1F3C6}", i18n.t("FEATURE_CHALLENGE_TITLE"), i18n.t("FEATURE_CHALLENGE_DESC"));
    const joinSection = content.createDiv({ cls: "join-section" });
    joinSection.createEl("h3", { text: i18n.t("JOIN_SECTION_TITLE") });
    const joinInfo = joinSection.createDiv({ cls: "join-info" });
    joinInfo.createEl("p", { text: i18n.t("JOIN_SECTION_DESC") });
    joinInfo.createEl("p", { text: i18n.t("OFFICIAL_ACCOUNT"), cls: "account-name" });
    const joinBtn = content.createDiv({ cls: "join-btn", text: i18n.t("COPY_ACCOUNT") });
    joinBtn.addEventListener("click", () => {
      navigator.clipboard.writeText("BilionWrites").then(() => {
        this.showNotice(i18n.t("COPY_SUCCESS", { type: i18n.t("OFFICIAL_ACCOUNT") }));
      }).catch(() => {
        this.showNotice(i18n.t("COPY_FAILED", { value: "BilionWrites" }));
      });
    });
  }
  createFeatureCard(container, icon, title, desc) {
    const card = container.createDiv({ cls: "feature-card" });
    const iconEl = card.createDiv({ cls: "feature-icon", text: icon });
    const contentEl = card.createDiv({ cls: "feature-content" });
    contentEl.createDiv({ cls: "feature-title", text: title });
    contentEl.createDiv({ cls: "feature-desc", text: desc });
  }
};

// src/modals/ContactModal.ts
var import_obsidian17 = require("obsidian");
var ContactModal = class extends BaseModal {
  constructor(container) {
    super(container, i18n.t("ABOUT_AUTHOR"));
  }
  createContent() {
    const content = this.element.createDiv({ cls: "contact-content" });
    const intro = content.createDiv({ cls: "author-intro" });
    intro.createEl("p", { text: i18n.t("AUTHOR_INTRO_1") });
    const p1 = intro.createEl("p");
    p1.createSpan({ text: i18n.t("AUTHOR_INTRO_2_1") });
    p1.createSpan({ text: i18n.t("AUTHOR_INTRO_2_2"), cls: "text-accent" });
    p1.createSpan({ text: i18n.t("AUTHOR_INTRO_2_3") });
    p1.createSpan({ text: i18n.t("AUTHOR_INTRO_2_4"), cls: "text-accent" });
    p1.createSpan({ text: i18n.t("AUTHOR_INTRO_2_5") });
    const p2 = intro.createEl("p");
    p2.createSpan({ text: i18n.t("AUTHOR_INTRO_3"), cls: "text-accent" });
    const p3 = intro.createEl("p");
    p3.createSpan({ text: i18n.t("AUTHOR_INTRO_4_1"), cls: "text-accent" });
    p3.createSpan({ text: i18n.t("AUTHOR_INTRO_4_2") });
    const donateSection = content.createDiv({ cls: "info-card donate-section" });
    donateSection.createSpan({ cls: "donate-text", text: i18n.t("DONATE_TEXT") });
    const donateBtn = donateSection.createDiv({ cls: "donate-button", text: i18n.t("DONATE_BUTTON") });
    donateBtn.addEventListener("click", () => {
      this.close();
      const event = new CustomEvent("open-donate-modal");
      document.dispatchEvent(event);
    });
    const moreInfo = content.createDiv({ cls: "info-card more-info-section" });
    moreInfo.createEl("p", { text: i18n.t("MORE_INFO_TEXT") });
    content.createEl("h3", { text: i18n.t("CONTACT_TITLE"), cls: "contact-title" });
    const contactMethods = content.createDiv({ cls: "contact-methods" });
    this.createContactCard(contactMethods, "file-text", i18n.t("CONTACT_WECHAT_OFFICIAL"), "\u591C\u534A");
    this.createContactCard(contactMethods, "book-open", i18n.t("CONTACT_XIAOHONGSHU"), "\u591C\u534AYeban");
    this.createContactCard(contactMethods, "message-circle", i18n.t("CONTACT_WECHAT"), "Bruce169229\uFF08\u6DFB\u52A0\u6CE8\u660E\u6765\u610F\uFF09");
    this.createContactCard(contactMethods, "globe", i18n.t("CONTACT_GITHUB"), "https://github.com/Yeban8090");
  }
  createContactCard(container, icon, title, value) {
    const card = container.createDiv({ cls: "contact-card" });
    const iconContainer = card.createDiv({ cls: "contact-icon-container" });
    (0, import_obsidian17.setIcon)(iconContainer, icon);
    const contentContainer = card.createDiv({ cls: "contact-info" });
    contentContainer.createDiv({ cls: "contact-label", text: title });
    contentContainer.createDiv({ cls: "contact-value", text: value });
    card.addEventListener("click", () => {
      navigator.clipboard.writeText(value).then(() => {
        this.showNotice(i18n.t("COPY_SUCCESS", { type: title }));
      }).catch(() => {
        this.showNotice(i18n.t("COPY_FAILED", { value }));
      });
    });
  }
};

// src/modals/BookSelectionModal.ts
var import_obsidian22 = require("obsidian");

// src/modals/ExportModal.ts
var import_obsidian20 = require("obsidian");

// src/modals/HeaderFooterTocModal.ts
var import_obsidian18 = require("obsidian");
var HeaderFooterTocModal = class extends import_obsidian18.Modal {
  constructor(plugin, initialSettings, onSubmit) {
    super(plugin.app);
    this.previewElement = null;
    this.onSubmit = onSubmit;
    this.settings = {
      headerEnabled: true,
      headerLeft: "{{title}}",
      headerCenter: "",
      headerRight: "{{author}}",
      headerFontSize: 15,
      headerColor: "#000000",
      headerHeight: 15,
      footerEnabled: true,
      footerLeft: "",
      footerCenter: "",
      footerRight: "{{pageNumber}}/{{totalPages}}",
      footerFontSize: 15,
      footerColor: "#000000",
      footerHeight: 20,
      tocEnabled: true,
      tocTitle: "\u76EE\u5F55",
      tocMaxLevel: 3,
      tocFontSize: 15,
      tocFontFamily: "serif",
      // 新增默认值
      tocColor: "#000000",
      // 新增默认值
      tocLineHeight: 1.5,
      tocIndentSize: 20,
      tocIndent: 20,
      // 新增默认值
      tocPageBreak: true,
      ...initialSettings
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u9875\u7709\u9875\u811A\u548C\u76EE\u5F55\u8BBE\u7F6E" });
    const mainContainer = contentEl.createEl("div", { cls: "header-footer-toc-container" });
    const controlsContainer = mainContainer.createEl("div", { cls: "controls-container" });
    const previewContainer = mainContainer.createEl("div", { cls: "preview-container" });
    this.previewElement = previewContainer.createEl("div", { cls: "page-preview" });
    this.createControls(controlsContainer);
    this.updatePreview();
    this.createButtons(contentEl);
  }
  createControls(container) {
    this.createHeaderSettings(container);
    this.createFooterSettings(container);
    this.createTocSettings(container);
  }
  createHeaderSettings(container) {
    const headerSection = container.createEl("div", { cls: "settings-section" });
    headerSection.createEl("h3", { text: "\u9875\u7709\u8BBE\u7F6E" });
    new import_obsidian18.Setting(headerSection).setName("\u542F\u7528\u9875\u7709").addToggle((toggle) => toggle.setValue(this.settings.headerEnabled).onChange((value) => {
      this.settings.headerEnabled = value;
      this.updatePreview();
      this.refreshControls(container);
    }));
    if (this.settings.headerEnabled) {
      new import_obsidian18.Setting(headerSection).setName("\u9875\u7709\u5DE6\u4FA7").setDesc("\u652F\u6301\u53D8\u91CF\uFF1A{{title}}, {{author}}, {{date}}").addText((text) => text.setPlaceholder("\u9875\u7709\u5DE6\u4FA7\u5185\u5BB9").setValue(this.settings.headerLeft).onChange((value) => {
        this.settings.headerLeft = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(headerSection).setName("\u9875\u7709\u4E2D\u95F4").addText((text) => text.setPlaceholder("\u9875\u7709\u4E2D\u95F4\u5185\u5BB9").setValue(this.settings.headerCenter).onChange((value) => {
        this.settings.headerCenter = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(headerSection).setName("\u9875\u7709\u53F3\u4FA7").addText((text) => text.setPlaceholder("\u9875\u7709\u53F3\u4FA7\u5185\u5BB9").setValue(this.settings.headerRight).onChange((value) => {
        this.settings.headerRight = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(headerSection).setName("\u5B57\u4F53\u5927\u5C0F").addSlider((slider) => slider.setLimits(8, 24, 1).setValue(this.settings.headerFontSize).setDynamicTooltip().onChange((value) => {
        this.settings.headerFontSize = value;
        this.updatePreview();
      })).addColorPicker((color) => color.setValue(this.settings.headerColor).onChange((value) => {
        this.settings.headerColor = value;
        this.updatePreview();
      }));
    }
  }
  createFooterSettings(container) {
    const footerSection = container.createEl("div", { cls: "settings-section" });
    footerSection.createEl("h3", { text: "\u9875\u811A\u8BBE\u7F6E" });
    new import_obsidian18.Setting(footerSection).setName("\u542F\u7528\u9875\u811A").addToggle((toggle) => toggle.setValue(this.settings.footerEnabled).onChange((value) => {
      this.settings.footerEnabled = value;
      this.updatePreview();
      this.refreshControls(container);
    }));
    if (this.settings.footerEnabled) {
      new import_obsidian18.Setting(footerSection).setName("\u9875\u811A\u5DE6\u4FA7").setDesc("\u652F\u6301\u53D8\u91CF\uFF1A{{pageNumber}}, {{totalPages}}, {{title}}").addText((text) => text.setPlaceholder("\u9875\u811A\u5DE6\u4FA7\u5185\u5BB9").setValue(this.settings.footerLeft).onChange((value) => {
        this.settings.footerLeft = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(footerSection).setName("\u9875\u811A\u4E2D\u95F4").addText((text) => text.setPlaceholder("\u9875\u811A\u4E2D\u95F4\u5185\u5BB9").setValue(this.settings.footerCenter).onChange((value) => {
        this.settings.footerCenter = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(footerSection).setName("\u9875\u811A\u53F3\u4FA7").addText((text) => text.setPlaceholder("\u9875\u811A\u53F3\u4FA7\u5185\u5BB9").setValue(this.settings.footerRight).onChange((value) => {
        this.settings.footerRight = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(footerSection).setName("\u5B57\u4F53\u5927\u5C0F").addSlider((slider) => slider.setLimits(8, 24, 1).setValue(this.settings.footerFontSize).setDynamicTooltip().onChange((value) => {
        this.settings.footerFontSize = value;
        this.updatePreview();
      })).addColorPicker((color) => color.setValue(this.settings.footerColor).onChange((value) => {
        this.settings.footerColor = value;
        this.updatePreview();
      }));
    }
  }
  createTocSettings(container) {
    const tocSection = container.createEl("div", { cls: "settings-section" });
    tocSection.createEl("h3", { text: "\u76EE\u5F55\u8BBE\u7F6E" });
    new import_obsidian18.Setting(tocSection).setName("\u751F\u6210\u76EE\u5F55").addToggle((toggle) => toggle.setValue(this.settings.tocEnabled).onChange((value) => {
      this.settings.tocEnabled = value;
      this.updatePreview();
      this.refreshControls(container);
    }));
    if (this.settings.tocEnabled) {
      new import_obsidian18.Setting(tocSection).setName("\u76EE\u5F55\u6807\u9898").addText((text) => text.setPlaceholder("\u76EE\u5F55").setValue(this.settings.tocTitle).onChange((value) => {
        this.settings.tocTitle = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(tocSection).setName("\u6700\u5927\u5C42\u7EA7").setDesc("\u663E\u793A\u5230\u7B2C\u51E0\u7EA7\u6807\u9898").addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.tocMaxLevel).setDynamicTooltip().onChange((value) => {
        this.settings.tocMaxLevel = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(tocSection).setName("\u5B57\u4F53\u6837\u5F0F").addDropdown((dropdown) => dropdown.addOption("serif", "Serif").addOption("sans-serif", "Sans-serif").addOption("monospace", "Monospace").setValue(this.settings.tocFontFamily).onChange((value) => {
        this.settings.tocFontFamily = value;
        this.updatePreview();
      })).addColorPicker((color) => color.setValue(this.settings.tocColor).onChange((value) => {
        this.settings.tocColor = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(tocSection).setName("\u5B57\u4F53\u5927\u5C0F").addSlider((slider) => slider.setLimits(10, 20, 1).setValue(this.settings.tocFontSize).setDynamicTooltip().onChange((value) => {
        this.settings.tocFontSize = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(tocSection).setName("\u884C\u9AD8").addSlider((slider) => slider.setLimits(1, 3, 0.1).setValue(this.settings.tocLineHeight).setDynamicTooltip().onChange((value) => {
        this.settings.tocLineHeight = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(tocSection).setName("\u7F29\u8FDB\u5927\u5C0F").addSlider((slider) => slider.setLimits(10, 50, 5).setValue(this.settings.tocIndentSize).setDynamicTooltip().onChange((value) => {
        this.settings.tocIndentSize = value;
        this.updatePreview();
      }));
      new import_obsidian18.Setting(tocSection).setName("\u76EE\u5F55\u540E\u5206\u9875").setDesc("\u5728\u76EE\u5F55\u540E\u63D2\u5165\u5206\u9875\u7B26").addToggle((toggle) => toggle.setValue(this.settings.tocPageBreak).onChange((value) => {
        this.settings.tocPageBreak = value;
        this.updatePreview();
      }));
    }
  }
  refreshControls(container) {
    container.empty();
    this.createControls(container);
  }
  updatePreview() {
    if (!this.previewElement)
      return;
    this.previewElement.empty();
    const pageContainer = this.previewElement.createEl("div", { cls: "page-container" });
    if (this.settings.headerEnabled) {
      const header = pageContainer.createEl("div", { cls: "header-preview" });
      header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 20px;
                border-bottom: 1px solid #ddd;
                font-size: ${this.settings.headerFontSize}px;
                color: ${this.settings.headerColor};
                height: ${this.settings.headerHeight}px;
            `;
      header.createEl("span", { text: this.replaceVariables(this.settings.headerLeft) });
      header.createEl("span", { text: this.replaceVariables(this.settings.headerCenter) });
      header.createEl("span", { text: this.replaceVariables(this.settings.headerRight) });
    }
    const content = pageContainer.createEl("div", { cls: "content-preview" });
    content.style.cssText = "flex: 1; padding: 20px; overflow-y: auto;";
    if (this.settings.tocEnabled) {
      const toc = content.createEl("div", { cls: "toc-preview" });
      toc.style.cssText = `
                margin-bottom: 30px;
                font-size: ${this.settings.tocFontSize}px;
                font-family: ${this.settings.tocFontFamily};
                color: ${this.settings.tocColor};
                line-height: ${this.settings.tocLineHeight};
            `;
      toc.createEl("h2", { text: this.settings.tocTitle, cls: "toc-title" });
      const tocItems = [
        { level: 1, title: "\u7B2C\u4E00\u7AE0 \u6982\u8FF0", page: "1" },
        { level: 2, title: "1.1 \u80CC\u666F\u4ECB\u7ECD", page: "2" },
        { level: 2, title: "1.2 \u7814\u7A76\u76EE\u6807", page: "5" },
        { level: 1, title: "\u7B2C\u4E8C\u7AE0 \u65B9\u6CD5\u8BBA", page: "8" },
        { level: 2, title: "2.1 \u7406\u8BBA\u57FA\u7840", page: "9" },
        { level: 3, title: "2.1.1 \u6838\u5FC3\u6982\u5FF5", page: "10" }
      ];
      tocItems.forEach((item) => {
        if (item.level <= this.settings.tocMaxLevel) {
          const tocItem = toc.createEl("div", { cls: "toc-item" });
          tocItem.style.cssText = `
                        margin-left: ${(item.level - 1) * this.settings.tocIndentSize}px;
                        display: flex;
                        justify-content: space-between;
                        margin-bottom: 5px;
                    `;
          tocItem.createEl("span", { text: item.title });
          tocItem.createEl("span", { text: item.page });
        }
      });
      if (this.settings.tocPageBreak) {
        toc.createEl("div", {
          text: "--- \u5206\u9875\u7B26 ---",
          cls: "page-break-indicator",
          attr: { style: "text-align: center; color: #999; margin: 20px 0; font-style: italic;" }
        });
      }
    }
    content.createEl("p", { text: "\u8FD9\u91CC\u662F\u6587\u6863\u5185\u5BB9\u7684\u9884\u89C8..." });
    if (this.settings.footerEnabled) {
      const footer = pageContainer.createEl("div", { cls: "footer-preview" });
      footer.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 20px;
                border-top: 1px solid #ddd;
                font-size: ${this.settings.footerFontSize}px;
                color: ${this.settings.footerColor};
                height: ${this.settings.footerHeight}px;
            `;
      footer.createEl("span", { text: this.replaceVariables(this.settings.footerLeft) });
      footer.createEl("span", { text: this.replaceVariables(this.settings.footerCenter) });
      footer.createEl("span", { text: this.replaceVariables(this.settings.footerRight) });
    }
  }
  replaceVariables(text) {
    return text.replace(/\{\{title\}\}/g, "\u793A\u4F8B\u4E66\u7C4D\u6807\u9898").replace(/\{\{author\}\}/g, "\u4F5C\u8005\u59D3\u540D").replace(/\{\{date\}\}/g, new Date().toLocaleDateString()).replace(/\{\{pageNumber\}\}/g, "1").replace(/\{\{totalPages\}\}/g, "100");
  }
  createButtons(container) {
    const buttonContainer = container.createEl("div", { cls: "modal-button-container" });
    buttonContainer.style.cssText = "display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;";
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88", cls: "mod-cta" });
    cancelButton.addEventListener("click", () => this.close());
    const confirmButton = buttonContainer.createEl("button", { text: "\u786E\u5B9A", cls: "mod-cta mod-primary" });
    confirmButton.addEventListener("click", () => {
      this.onSubmit(this.settings);
      this.close();
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/modals/CoverSettingModal.ts
var import_obsidian19 = require("obsidian");
var CoverSettingModal = class extends import_obsidian19.Modal {
  constructor(app, onSubmit, targetPreviewEl, coverManager, initialSettings, bookTitle, bookAuthor, bookSubtitle) {
    super(app);
    this.onSubmit = onSubmit;
    this.targetPreviewEl = targetPreviewEl;
    this.bookTitle = bookTitle;
    this.bookAuthor = bookAuthor;
    this.bookSubtitle = bookSubtitle;
    this.imageUrl = "";
    this.scale = 1;
    this.position = { x: 0, y: 0 };
    this.titleStyle = "";
    this.authorStyle = "";
    this.customTitle = "";
    this.customAuthor = "";
    this.customSubtitle = "";
    // 副标题
    this.titlePosition = { x: 50, y: 30 };
    this.authorPosition = { x: 50, y: 70 };
    this.subtitlePosition = { x: 50, y: 50 };
    // 副标题位置
    // 新增：样式配置
    this.titleStyleConfig = {
      fontSize: 24,
      color: "#ffffff",
      fontWeight: "bold",
      fontStyle: "normal",
      textShadow: "0 1px 2px rgba(0,0,0,0.5)"
    };
    this.authorStyleConfig = {
      fontSize: 16,
      color: "#ffffff",
      fontWeight: "normal",
      fontStyle: "normal",
      textShadow: "0 1px 2px rgba(0,0,0,0.5)"
    };
    this.subtitleStyleConfig = {
      fontSize: 18,
      color: "#ffffff",
      fontWeight: "normal",
      fontStyle: "normal",
      textShadow: "0 1px 2px rgba(0,0,0,0.5)"
    };
    this.previewElement = null;
    this.dragEventCleanup = null;
    this.isDragging = false;
    this.dragTarget = null;
    this.coverManager = coverManager;
    this.initialSettings = initialSettings;
    this.customTitle = (initialSettings == null ? void 0 : initialSettings.customTitle) || bookTitle || "";
    this.customAuthor = (initialSettings == null ? void 0 : initialSettings.customAuthor) || (bookAuthor == null ? void 0 : bookAuthor.join(", ")) || "";
    this.customSubtitle = (initialSettings == null ? void 0 : initialSettings.customSubtitle) || bookSubtitle || "";
    this.titlePosition = (initialSettings == null ? void 0 : initialSettings.titlePosition) || { x: 50, y: 30 };
    this.authorPosition = (initialSettings == null ? void 0 : initialSettings.authorPosition) || { x: 50, y: 70 };
    this.subtitlePosition = (initialSettings == null ? void 0 : initialSettings.subtitlePosition) || { x: 50, y: 50 };
    if (initialSettings == null ? void 0 : initialSettings.titleStyleConfig) {
      this.titleStyleConfig = { ...this.titleStyleConfig, ...initialSettings.titleStyleConfig };
    }
    if (initialSettings == null ? void 0 : initialSettings.authorStyleConfig) {
      this.authorStyleConfig = { ...this.authorStyleConfig, ...initialSettings.authorStyleConfig };
    }
    if (initialSettings == null ? void 0 : initialSettings.subtitleStyleConfig) {
      this.subtitleStyleConfig = { ...this.subtitleStyleConfig, ...initialSettings.subtitleStyleConfig };
    }
    if (initialSettings) {
      this.imageUrl = initialSettings.imageUrl;
      this.scale = initialSettings.scale;
      this.position = { ...initialSettings.position };
      this.titleStyle = initialSettings.titleStyle;
      this.authorStyle = initialSettings.authorStyle;
    } else {
      const defaultSettings = coverManager.getDefaultCoverSettings();
      this.titleStyle = defaultSettings.titleStyle;
      this.authorStyle = defaultSettings.authorStyle;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("book-smith-cover-modal");
    const container = contentEl.createEl("div", { cls: "cover-settings-container" });
    container.createEl("h3", { text: i18n.t("COVER_DESIGN") || "\u5C01\u9762\u8BBE\u8BA1" });
    const previewArea = container.createEl("div", { cls: "cover-preview-area" });
    this.previewElement = previewArea.createEl("div", { cls: "cover-preview" });
    const controlsArea = container.createEl("div", { cls: "cover-controls" });
    this.createControls(controlsArea);
    this.updatePreview();
    const buttonContainer = contentEl.createEl("div", { cls: "cover-button-container" });
    const cancelButton = buttonContainer.createEl("button", {
      text: i18n.t("CANCEL") || "\u53D6\u6D88",
      cls: "cover-cancel-button"
    });
    cancelButton.addEventListener("click", () => this.close());
    const applyButton = buttonContainer.createEl("button", {
      text: i18n.t("APPLY") || "\u5E94\u7528",
      cls: "cover-apply-button"
    });
    applyButton.addEventListener("click", () => {
      var _a;
      this.onSubmit({
        imageUrl: this.imageUrl,
        scale: this.scale,
        position: this.position,
        titleStyle: this.titleStyle,
        authorStyle: this.authorStyle,
        bookSize: ((_a = this.initialSettings) == null ? void 0 : _a.bookSize) || "A4",
        customTitle: this.customTitle,
        customAuthor: this.customAuthor,
        customSubtitle: this.customSubtitle,
        titlePosition: this.titlePosition,
        authorPosition: this.authorPosition,
        subtitlePosition: this.subtitlePosition,
        // 新增：保存样式配置
        titleStyleConfig: this.titleStyleConfig,
        authorStyleConfig: this.authorStyleConfig,
        subtitleStyleConfig: this.subtitleStyleConfig
      });
      new import_obsidian19.Notice('\u5C01\u9762\u8BBE\u7F6E\u5DF2\u66F4\u65B0\uFF0C\u8BF7\u70B9\u51FB"\u91CD\u65B0\u6E32\u67D3"\u6309\u94AE\u67E5\u770B\u6548\u679C');
      this.close();
    });
  }
  createControls(container) {
    new import_obsidian19.Setting(container).setName(i18n.t("COVER_IMAGE") || "\u5C01\u9762\u56FE\u7247").addButton((button) => button.setButtonText(i18n.t("SELECT_IMAGE") || "\u9009\u62E9\u56FE\u7247").onClick(() => this.handleImageUpload())).addButton((button) => button.setButtonText(i18n.t("CLEAR_IMAGE") || "\u6E05\u9664\u56FE\u7247").onClick(() => this.handleClearImage()));
    if (this.imageUrl) {
      new import_obsidian19.Setting(container).setName(i18n.t("SCALE") || "\u7F29\u653E").addButton((button) => button.setIcon("rotate-ccw").setTooltip("\u91CD\u7F6E\u4F4D\u7F6E").onClick(() => {
        this.position = { x: 0, y: 0 };
        this.updatePreview();
      })).addSlider((slider) => slider.setLimits(0.1, 2, 0.1).setValue(this.scale).onChange((value) => {
        this.scale = value;
        this.updatePreview();
      }));
      const positionDesc = container.createEl("div", {
        cls: "setting-item-description",
        text: "\u62D6\u62FD\u56FE\u7247\u8C03\u6574\u4F4D\u7F6E\uFF0C\u6216\u70B9\u51FB\u91CD\u7F6E\u5230\u4E2D\u5FC3"
      });
      positionDesc.style.marginTop = "-10px";
      positionDesc.style.marginBottom = "15px";
      positionDesc.style.fontSize = "0.9em";
      positionDesc.style.color = "var(--text-muted)";
    }
    new import_obsidian19.Setting(container).setName("\u4E66\u540D").addText((text) => text.setPlaceholder("\u8F93\u5165\u4E66\u540D").setValue(this.customTitle).onChange((value) => {
      this.customTitle = value;
      this.updatePreview();
    })).addSlider((slider) => slider.setLimits(8, 72, 1).setValue(this.titleStyleConfig.fontSize).setDynamicTooltip().onChange((value) => {
      this.titleStyleConfig.fontSize = value;
      this.updatePreview();
    })).addColorPicker((color) => color.setValue(this.titleStyleConfig.color).onChange((value) => {
      this.titleStyleConfig.color = value;
      this.updatePreview();
    })).addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("bold", "\u52A0\u7C97").setValue(this.titleStyleConfig.fontWeight).onChange((value) => {
      this.titleStyleConfig.fontWeight = value;
      this.updatePreview();
    })).addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("italic", "\u503E\u659C").setValue(this.titleStyleConfig.fontStyle).onChange((value) => {
      this.titleStyleConfig.fontStyle = value;
      this.updatePreview();
    }));
    new import_obsidian19.Setting(container).setName("\u526F\u6807\u9898").addText((text) => text.setPlaceholder("\u8F93\u5165\u526F\u6807\u9898").setValue(this.customSubtitle).onChange((value) => {
      this.customSubtitle = value;
      this.updatePreview();
    })).addSlider((slider) => slider.setLimits(8, 72, 1).setValue(this.subtitleStyleConfig.fontSize).setDynamicTooltip().onChange((value) => {
      this.subtitleStyleConfig.fontSize = value;
      this.updatePreview();
    })).addColorPicker((color) => color.setValue(this.subtitleStyleConfig.color).onChange((value) => {
      this.subtitleStyleConfig.color = value;
      this.updatePreview();
    })).addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("bold", "\u52A0\u7C97").setValue(this.subtitleStyleConfig.fontWeight).onChange((value) => {
      this.subtitleStyleConfig.fontWeight = value;
      this.updatePreview();
    })).addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("italic", "\u503E\u659C").setValue(this.subtitleStyleConfig.fontStyle).onChange((value) => {
      this.subtitleStyleConfig.fontStyle = value;
      this.updatePreview();
    }));
    new import_obsidian19.Setting(container).setName("\u4F5C\u8005").addText((text) => text.setPlaceholder("\u8F93\u5165\u4F5C\u8005").setValue(this.customAuthor).onChange((value) => {
      this.customAuthor = value;
      this.updatePreview();
    })).addSlider((slider) => slider.setLimits(8, 72, 1).setValue(this.authorStyleConfig.fontSize).setDynamicTooltip().onChange((value) => {
      this.authorStyleConfig.fontSize = value;
      this.updatePreview();
    })).addColorPicker((color) => color.setValue(this.authorStyleConfig.color).onChange((value) => {
      this.authorStyleConfig.color = value;
      this.updatePreview();
    })).addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("bold", "\u52A0\u7C97").setValue(this.authorStyleConfig.fontWeight).onChange((value) => {
      this.authorStyleConfig.fontWeight = value;
      this.updatePreview();
    })).addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("italic", "\u503E\u659C").setValue(this.authorStyleConfig.fontStyle).onChange((value) => {
      this.authorStyleConfig.fontStyle = value;
      this.updatePreview();
    }));
  }
  handleImageUpload() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";
    input.addEventListener("change", (e) => {
      const target = e.target;
      if (target.files && target.files[0]) {
        const reader = new FileReader();
        reader.onload = (e2) => {
          var _a;
          this.imageUrl = (_a = e2.target) == null ? void 0 : _a.result;
          this.updatePreview();
          const controlsArea = this.contentEl.querySelector(".cover-controls");
          if (controlsArea) {
            controlsArea.empty();
            this.createControls(controlsArea);
          }
        };
        reader.readAsDataURL(target.files[0]);
      }
    });
    input.click();
  }
  handleClearImage() {
    this.imageUrl = "";
    this.scale = 1;
    this.position = { x: 0, y: 0 };
    this.updatePreview();
    const controlsArea = this.contentEl.querySelector(".cover-controls");
    if (controlsArea) {
      controlsArea.empty();
      this.createControls(controlsArea);
    }
  }
  createTextStyleControls(container, title, styleConfig, onUpdate) {
    const styleGroup = container.createEl("div", { cls: "text-style-group" });
    styleGroup.createEl("h4", { text: title, cls: "style-group-title" });
    new import_obsidian19.Setting(styleGroup).setName("\u5B57\u4F53\u5927\u5C0F").addSlider((slider) => slider.setLimits(8, 72, 1).setValue(styleConfig.fontSize).setDynamicTooltip().onChange((value) => {
      styleConfig.fontSize = value;
      onUpdate();
    }));
    new import_obsidian19.Setting(styleGroup).setName("\u5B57\u4F53\u989C\u8272").addColorPicker((color) => color.setValue(styleConfig.color).onChange((value) => {
      styleConfig.color = value;
      onUpdate();
    }));
    new import_obsidian19.Setting(styleGroup).setName("\u5B57\u4F53\u7C97\u7EC6").addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("bold", "\u52A0\u7C97").setValue(styleConfig.fontWeight).onChange((value) => {
      styleConfig.fontWeight = value;
      onUpdate();
    }));
    new import_obsidian19.Setting(styleGroup).setName("\u5B57\u4F53\u6837\u5F0F").addDropdown((dropdown) => dropdown.addOption("normal", "\u6B63\u5E38").addOption("italic", "\u503E\u659C").setValue(styleConfig.fontStyle).onChange((value) => {
      styleConfig.fontStyle = value;
      onUpdate();
    }));
  }
  updatePreview() {
    var _a;
    if (!this.previewElement)
      return;
    this.coverManager.clearCoverStyles(this.previewElement);
    const currentSettings = {
      imageUrl: this.imageUrl,
      scale: this.scale,
      position: this.position,
      titleStyle: this.titleStyle,
      authorStyle: this.authorStyle,
      bookSize: ((_a = this.initialSettings) == null ? void 0 : _a.bookSize) || "A4"
    };
    this.applyBookSizeStyles(this.previewElement, currentSettings.bookSize);
    const contentContainer = this.coverManager.applyCoverStyles(this.previewElement, currentSettings);
    if (this.imageUrl && this.previewElement) {
      this.setupImageDragEvents(this.previewElement);
    }
    if (contentContainer) {
      if (this.customTitle) {
        const titleEl = contentContainer.createEl("div", {
          cls: "cover-title draggable-text",
          text: this.customTitle
        });
        const titleStyle = this.buildStyleString(this.titleStyleConfig);
        titleEl.setAttribute("style", titleStyle + `position: absolute; left: ${this.titlePosition.x}%; top: ${this.titlePosition.y}%; transform: translate(-50%, -50%); cursor: move; user-select: none; z-index: 10;`);
        this.setupDragEvents(titleEl, "title");
      }
      if (this.customSubtitle) {
        const subtitleEl = contentContainer.createEl("div", {
          cls: "cover-subtitle draggable-text",
          text: this.customSubtitle
        });
        const subtitleStyle = this.buildStyleString(this.subtitleStyleConfig);
        subtitleEl.setAttribute("style", subtitleStyle + `position: absolute; left: ${this.subtitlePosition.x}%; top: ${this.subtitlePosition.y}%; transform: translate(-50%, -50%); cursor: move; user-select: none; z-index: 10;`);
        this.setupDragEvents(subtitleEl, "subtitle");
      }
      if (this.customAuthor) {
        const authorEl = contentContainer.createEl("div", {
          cls: "cover-author draggable-text",
          text: this.customAuthor
        });
        const authorStyle = this.buildStyleString(this.authorStyleConfig);
        authorEl.setAttribute("style", authorStyle + `position: absolute; left: ${this.authorPosition.x}%; top: ${this.authorPosition.y}%; transform: translate(-50%, -50%); cursor: move; user-select: none; z-index: 10;`);
        this.setupDragEvents(authorEl, "author");
      }
    }
  }
  buildStyleString(styleConfig) {
    return `font-size: ${styleConfig.fontSize}px; color: ${styleConfig.color}; font-weight: ${styleConfig.fontWeight}; font-style: ${styleConfig.fontStyle}; text-shadow: ${styleConfig.textShadow || "none"}; `;
  }
  // 新增：图片拖拽事件处理
  setupImageDragEvents(element) {
    let startX = 0;
    let startY = 0;
    let startPosX = 0;
    let startPosY = 0;
    let isImageDragging = false;
    const onMouseDown = (e) => {
      const target = e.target;
      if (target.classList.contains("draggable-text") || target.closest(".draggable-text")) {
        return;
      }
      e.preventDefault();
      isImageDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startPosX = this.position.x;
      startPosY = this.position.y;
      element.style.cursor = "grabbing";
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    const onMouseMove = (e) => {
      if (!isImageDragging)
        return;
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      this.position.x = startPosX + deltaX;
      this.position.y = startPosY + deltaY;
      element.style.backgroundPosition = `${this.position.x}px ${this.position.y}px`;
    };
    const onMouseUp = () => {
      isImageDragging = false;
      element.style.cursor = "grab";
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    element.style.cursor = "grab";
    element.addEventListener("mousedown", onMouseDown);
    const cleanup = () => {
      element.removeEventListener("mousedown", onMouseDown);
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      element.style.cursor = "";
    };
    if (this.dragEventCleanup) {
      this.dragEventCleanup();
    }
    this.dragEventCleanup = cleanup;
  }
  // 修改现有的 setupDragEvents 方法，更新 dragTarget 类型
  setupDragEvents(element, type) {
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;
    const onMouseDown = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.isDragging = true;
      this.dragTarget = type;
      const rect = this.previewElement.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      let currentPos;
      if (type === "title") {
        currentPos = this.titlePosition;
      } else if (type === "subtitle") {
        currentPos = this.subtitlePosition;
      } else {
        currentPos = this.authorPosition;
      }
      startLeft = currentPos.x;
      startTop = currentPos.y;
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    const onMouseMove = (e) => {
      if (!this.isDragging || this.dragTarget !== type)
        return;
      const rect = this.previewElement.getBoundingClientRect();
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      const newX = startLeft + deltaX / rect.width * 100;
      const newY = startTop + deltaY / rect.height * 100;
      const clampedX = Math.max(0, Math.min(100, newX));
      const clampedY = Math.max(0, Math.min(100, newY));
      if (type === "title") {
        this.titlePosition = { x: clampedX, y: clampedY };
      } else if (type === "subtitle") {
        this.subtitlePosition = { x: clampedX, y: clampedY };
      } else {
        this.authorPosition = { x: clampedX, y: clampedY };
      }
      element.style.left = `${clampedX}%`;
      element.style.top = `${clampedY}%`;
    };
    const onMouseUp = () => {
      this.isDragging = false;
      this.dragTarget = null;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    element.addEventListener("mousedown", onMouseDown);
  }
  // 应用开本大小样式
  applyBookSizeStyles(element, bookSize) {
    const sizeMap = {
      "A4": { aspectRatio: "210/297" },
      "A5": { aspectRatio: "148/210" },
      "A3": { aspectRatio: "297/420" },
      "Legal": { aspectRatio: "8.5/14" },
      "Letter": { aspectRatio: "8.5/11" },
      "Tabloid": { aspectRatio: "11/17" }
    };
    const size = sizeMap[bookSize] || sizeMap["A4"];
    element.style.aspectRatio = size.aspectRatio;
    element.style.maxWidth = "300px";
    element.style.width = "100%";
    element.style.height = "auto";
    element.style.position = "relative";
    element.style.overflow = "hidden";
  }
  onClose() {
    if (this.dragEventCleanup) {
      this.dragEventCleanup();
      this.dragEventCleanup = null;
    }
    this.contentEl.empty();
  }
};

// src/modals/ExportModal.ts
var fs = __toESM(require("fs/promises"));
var electron = __toESM(require("electron"));

// src/services/CoverManager.ts
var CoverManager = class {
  constructor(app) {
    this.app = app;
  }
  applyCoverStyles(element, settings) {
    if (settings.imageUrl) {
      const stylesArray = [
        `background-image: url(${settings.imageUrl})`,
        `background-size: ${settings.scale * 100}%`,
        `background-position: ${settings.position.x}px ${settings.position.y}px`,
        `background-repeat: no-repeat`
      ];
      stylesArray.forEach((style) => {
        const match = style.match(/([^:]+):(.+)/);
        if (match) {
          const [, key, value] = match.map((item) => item.trim());
          if (key && value) {
            element.style[key] = value;
          }
        }
      });
    }
    const contentContainer = element.createDiv({ cls: "cover-content" });
    contentContainer.style.position = "relative";
    contentContainer.style.height = "100%";
    contentContainer.style.display = "flex";
    contentContainer.style.flexDirection = "column";
    contentContainer.style.justifyContent = "center";
    contentContainer.style.alignItems = "center";
    contentContainer.style.padding = "40px";
    contentContainer.style.textAlign = "center";
    return contentContainer;
  }
  clearCoverStyles(element) {
    const style = element.getAttribute("style") || "";
    const clearedStyle = style.replace(/background-image:[^;]+;|background-size:[^;]+;|background-position:[^;]+;|background-repeat:[^;]+;/g, "");
    element.setAttribute("style", clearedStyle);
    const contentContainer = element.querySelector(".cover-content");
    if (contentContainer)
      contentContainer.remove();
  }
  getDefaultCoverSettings(book) {
    if (book == null ? void 0 : book.basic.coverSettings) {
      return book.basic.coverSettings;
    }
    if (book == null ? void 0 : book.basic.cover) {
      const imageUrl = this.app.vault.getResourcePath(this.app.vault.getAbstractFileByPath(book.basic.cover));
      return {
        imageUrl,
        scale: 1,
        position: { x: 0, y: 0 },
        titleStyle: "color: #333333; font-weight: bold;",
        authorStyle: "color: #666666; font-style: italic;",
        bookSize: "A4"
      };
    }
    return {
      imageUrl: "",
      scale: 1,
      position: { x: 0, y: 0 },
      titleStyle: "font-size: 24px; color: #333333; font-weight: bold;",
      authorStyle: "font-size: 16px; color: #666666; font-style: italic;",
      bookSize: "A4"
    };
  }
  getBookCoverSettings(book) {
    return this.getDefaultCoverSettings(book);
  }
};

// src/modals/ExportModal.ts
var import_pdf_lib = __toESM(require_cjs());
var ExportModal = class extends import_obsidian20.Modal {
  // 构造函数，接收必要的依赖项
  constructor(app, plugin, bookRenderService, selectedBook) {
    super(app);
    this.plugin = plugin;
    this.bookRenderService = bookRenderService;
    this.selectedBook = selectedBook;
    // UI 元素引用
    this.formatButtons = [];
    this.selectedFormat = null;
    // 状态标志
    this.isRendering = false;
    this.abortController = null;
    this.webview = null;
    this.webviewReady = false;
    // 导出设置，包含默认值
    this.exportSettings = {
      format: "",
      bookSize: "A4",
      showCover: true,
      // 修改为默认打开封面
      headerFooterToc: {
        // 默认页眉页脚设置
        headerEnabled: true,
        headerLeft: "{{title}}",
        headerCenter: "",
        headerRight: "{{author}}",
        headerFontSize: 12,
        headerColor: "#000000",
        headerHeight: 15,
        // 默认页脚设置
        footerEnabled: true,
        footerLeft: "",
        footerCenter: "",
        footerRight: "{{pageNumber}}/{{totalPages}}",
        footerFontSize: 12,
        footerColor: "#000000",
        footerHeight: 20,
        // 默认目录设置
        tocEnabled: true,
        tocTitle: "\u76EE\u5F55",
        tocMaxLevel: 3,
        tocFontSize: 14,
        tocFontFamily: "serif",
        tocColor: "#000000",
        tocLineHeight: 1.5,
        tocIndentSize: 20,
        tocIndent: 20,
        tocPageBreak: true
      }
    };
    // 渲染设置，控制渲染过程中的一些参数
    this.renderSettings = {
      showTitle: true,
      scale: 100,
      displayHeader: true,
      displayFooter: true,
      cssSnippet: ""
    };
    const coverManager = new CoverManager(this.app);
    this.exportSettings.cover = coverManager.getDefaultCoverSettings(this.selectedBook);
  }
  // 模态框打开时初始化 UI
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("export-modal");
    this.containerEl.style.setProperty("--dialog-width", "50vw");
    this.containerEl.style.setProperty("--dialog-height", "70vh");
    this.createHeader();
    this.createMainContent();
    this.createFooter();
  }
  // 创建模态框的标题头部
  createHeader() {
    const { contentEl } = this;
    const header = contentEl.createDiv({ cls: "export-modal-header" });
    header.createEl("h2", {
      text: "\u5BFC\u51FA\u4E66\u7C4D",
      cls: "export-modal-title"
    });
  }
  // 创建主内容区域，包括左侧预览区域和右侧设置区域
  createMainContent() {
    const { contentEl } = this;
    const mainContent = contentEl.createDiv({ cls: "export-modal-main centered" });
    this.mainContent = mainContent;
    this.previewContainer = mainContent.createDiv({ cls: "export-preview-panel" });
    this.updatePreviewVisibility();
    const settingsPanel = mainContent.createDiv({ cls: "export-settings-panel" });
    this.createSettingsContent(settingsPanel);
  }
  // 根据选择的导出格式更新布局模式
  updateLayoutMode() {
    if (!this.mainContent)
      return;
    if (this.selectedFormat && this.selectedFormat == "pdf") {
      this.mainContent.removeClass("centered");
      this.mainContent.addClass("split-layout");
    } else {
      this.mainContent.removeClass("split-layout");
      this.mainContent.addClass("centered");
    }
  }
  // 根据选择的导出格式更新预览区域的可见性
  updatePreviewVisibility() {
    if (!this.previewContainer)
      return;
    if (this.selectedFormat === "pdf") {
      this.previewContainer.style.display = "flex";
      this.createPreviewArea();
    } else {
      this.previewContainer.style.display = "none";
      this.previewContainer.empty();
      this.cleanupWebview();
    }
  }
  // 创建用于 PDF 预览的 Electron Webview
  createWebview(scale = 1) {
    const webview = document.createElement("webview");
    webview.src = "app://obsidian.md/help.html";
    webview.setAttribute("style", `
            height: 100%;
            width: 100%;
            border: 1px solid #f2f2f2;
            background: white;
        `);
    webview.nodeintegration = true;
    return webview;
  }
  // 创建预览区域的 UI 结构
  createPreviewArea() {
    if (this.selectedFormat !== "pdf") {
      return;
    }
    this.previewContainer.empty();
    this.cleanupWebview();
    const previewHeader = this.previewContainer.createDiv({ cls: "preview-header" });
    const headerContent = previewHeader.createDiv({ cls: "preview-header-content" });
    headerContent.createEl("h3", { text: "PDF\u5BFC\u51FA\u9884\u89C8", cls: "preview-title" });
    const scrollContainer = this.previewContainer.createDiv({ cls: "preview-scroll-container" });
    if (this.exportSettings.showCover && this.exportSettings.cover) {
      const coverPreviewContainer = scrollContainer.createDiv({ cls: "cover-preview-container" });
      coverPreviewContainer.style.display = "none";
      const coverPreviewHeader = coverPreviewContainer.createDiv({ cls: "cover-preview-header" });
      coverPreviewHeader.createEl("span", { text: "\u5C01\u9762\u9884\u89C8", cls: "cover-preview-title" });
      this.coverPreviewElement = coverPreviewContainer.createDiv({ cls: "cover-preview-content" });
      this.updateCoverPreview();
    }
    const previewContent = scrollContainer.createDiv({ cls: "preview-content" });
    this.showPreviewState("waiting", previewContent);
  }
  /**
   * 更新封面预览
   */
  updateCoverPreview() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (!this.coverPreviewElement || !this.exportSettings.cover)
      return;
    this.coverPreviewElement.empty();
    const coverContainer = this.coverPreviewElement.createDiv({ cls: "cover-container" });
    this.applyBookSizeStyles(coverContainer, this.exportSettings.bookSize || "A4");
    if (this.exportSettings.cover.imageUrl) {
      coverContainer.style.backgroundImage = `url(${this.exportSettings.cover.imageUrl})`;
      coverContainer.style.backgroundSize = `${this.exportSettings.cover.scale * 100}%`;
      coverContainer.style.backgroundPosition = `${this.exportSettings.cover.position.x}px ${this.exportSettings.cover.position.y}px`;
    }
    const contentContainer = coverContainer.createDiv({ cls: "cover-content" });
    const settings = this.exportSettings.cover;
    const book = this.selectedBook;
    const titleText = settings.customTitle || book.basic.title;
    const subtitleText = settings.customSubtitle || book.basic.subtitle;
    const authorText = settings.customAuthor || (book.basic.author ? book.basic.author.join(", ") : "");
    if (titleText) {
      const titleEl = contentContainer.createDiv({ cls: "cover-title", text: titleText });
      let titleStyle = "";
      if (settings.titleStyleConfig) {
        titleStyle = this.buildStyleString(settings.titleStyleConfig);
      } else {
        titleStyle = settings.titleStyle || "";
      }
      titleEl.style.left = `${((_a = settings.titlePosition) == null ? void 0 : _a.x) || 50}%`;
      titleEl.style.top = `${((_b = settings.titlePosition) == null ? void 0 : _b.y) || 30}%`;
      if (titleStyle) {
        titleEl.setAttribute("style", titleStyle + `left: ${((_c = settings.titlePosition) == null ? void 0 : _c.x) || 50}%; top: ${((_d = settings.titlePosition) == null ? void 0 : _d.y) || 30}%; position: absolute; transform: translate(-50%, -50%); z-index: 10;`);
      }
    }
    if (subtitleText) {
      const subtitleEl = contentContainer.createDiv({ cls: "cover-subtitle", text: subtitleText });
      let subtitleStyle = "";
      if (settings.subtitleStyleConfig) {
        subtitleStyle = this.buildStyleString(settings.subtitleStyleConfig);
      } else {
        subtitleStyle = "";
      }
      subtitleEl.style.left = `${((_e = settings.subtitlePosition) == null ? void 0 : _e.x) || 50}%`;
      subtitleEl.style.top = `${((_f = settings.subtitlePosition) == null ? void 0 : _f.y) || 50}%`;
      if (subtitleStyle) {
        subtitleEl.setAttribute("style", subtitleStyle + `left: ${((_g = settings.subtitlePosition) == null ? void 0 : _g.x) || 50}%; top: ${((_h = settings.subtitlePosition) == null ? void 0 : _h.y) || 50}%; position: absolute; transform: translate(-50%, -50%); z-index: 10;`);
      }
    }
    if (authorText) {
      const authorEl = contentContainer.createDiv({ cls: "cover-author", text: authorText });
      let authorStyle = "";
      if (settings.authorStyleConfig) {
        authorStyle = this.buildStyleString(settings.authorStyleConfig);
      } else {
        authorStyle = settings.authorStyle || "";
      }
      authorEl.style.left = `${((_i = settings.authorPosition) == null ? void 0 : _i.x) || 50}%`;
      authorEl.style.top = `${((_j = settings.authorPosition) == null ? void 0 : _j.y) || 70}%`;
      if (authorStyle) {
        authorEl.setAttribute("style", authorStyle + `left: ${((_k = settings.authorPosition) == null ? void 0 : _k.x) || 50}%; top: ${((_l = settings.authorPosition) == null ? void 0 : _l.y) || 70}%; position: absolute; transform: translate(-50%, -50%); z-index: 10;`);
      }
    }
  }
  // 统一的预览状态管理方法，处理不同状态（等待、加载中、就绪、错误）
  showPreviewState(state, container, errorMessage) {
    const previewContent = container || this.previewContainer.querySelector(".preview-content");
    if (!previewContent)
      return;
    previewContent.empty();
    switch (state) {
      case "waiting":
        const waiting = previewContent.createDiv({ cls: "preview-waiting" });
        waiting.innerHTML = `
                    <div class="preview-waiting-icon">\u{1F4C4}</div>
                    <div class="preview-waiting-text">\u70B9\u51FB\u5F00\u59CB\u6E32\u67D3\u9884\u89C8</div>
                `;
        break;
      case "loading":
        const loading = previewContent.createDiv({ cls: "preview-loading" });
        loading.innerHTML = `
                    <div class="preview-loading-spinner"></div>
                    <div class="preview-loading-text">\u6B63\u5728\u6E32\u67D3\u9884\u89C8...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-text">\u51C6\u5907\u4E2D...</div>
                    <div class="progress-file"></div>
                `;
        break;
      case "ready":
        if (this.webview) {
          previewContent.appendChild(this.webview);
        }
        break;
      case "error":
        const error = previewContent.createDiv({ cls: "preview-error" });
        error.innerHTML = `
                    <div class="preview-error-icon">\u274C</div>
                    <div class="preview-error-text">${errorMessage || "\u6E32\u67D3\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5"}</div>
                    <button class="preview-retry-btn">\u91CD\u65B0\u6E32\u67D3</button>
                `;
        const retryBtn = error.querySelector(".preview-retry-btn");
        retryBtn == null ? void 0 : retryBtn.addEventListener("click", () => {
          this.startRenderPreview();
        });
        break;
    }
  }
  // 清理 Webview 资源
  cleanupWebview() {
    if (this.webview) {
      this.webview.remove();
      this.webview = null;
      this.webviewReady = false;
    }
  }
  // 更新渲染进度条和进度文本
  updateRenderProgress(current, total, fileName) {
    const progressFill = this.previewContainer.querySelector(".progress-fill");
    const progressText = this.previewContainer.querySelector(".progress-text");
    const progressFile = this.previewContainer.querySelector(".progress-file");
    if (progressFill && progressText && progressFile) {
      const percentage = total > 0 ? Math.round(current / total * 100) : 0;
      progressFill.style.width = `${percentage}%`;
      progressText.textContent = `${current}/${total} (${percentage}%)`;
      progressFile.textContent = fileName;
    }
  }
  // 开始渲染预览，这是渲染预览的核心方法
  async startRenderPreview() {
    var _a, _b, _c, _d, _e;
    if (this.isRendering) {
      new import_obsidian20.Notice("\u6E32\u67D3\u8FDB\u884C\u4E2D\uFF0C\u8BF7\u7A0D\u5019...");
      return;
    }
    this.isRendering = true;
    this.webviewReady = false;
    this.cleanupWebview();
    const previewContent = this.previewContainer.querySelector(".preview-content");
    if (!previewContent) {
      this.createPreviewArea();
    }
    previewContent.empty();
    const loading = previewContent.createDiv({ cls: "preview-loading" });
    loading.innerHTML = `
            <div class="preview-loading-spinner"></div>
            <div class="preview-loading-text">\u6B63\u5728\u6E32\u67D3\u9884\u89C8...</div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-text">\u51C6\u5907\u4E2D...</div>
            <div class="progress-file"></div>
        `;
    this.updateExportButtonState();
    this.updateFormatButtonsState();
    this.abortController = new AbortController();
    try {
      this.webview = this.createWebview();
      this.webview.style.opacity = "0";
      previewContent.appendChild(this.webview);
      const renderConfig = {
        showTitle: this.renderSettings.showTitle,
        scale: this.renderSettings.scale / 100,
        displayHeader: !!(this.renderSettings.displayHeader && ((_a = this.exportSettings.headerFooterToc) == null ? void 0 : _a.headerEnabled)),
        displayFooter: !!(this.renderSettings.displayFooter && ((_b = this.exportSettings.headerFooterToc) == null ? void 0 : _b.footerEnabled)),
        cssSnippet: this.renderSettings.cssSnippet,
        headerFooterToc: this.exportSettings.headerFooterToc,
        showCover: this.exportSettings.showCover,
        coverSettings: this.exportSettings.cover,
        abortSignal: (_c = this.abortController) == null ? void 0 : _c.signal,
        onProgress: (current, total, fileName) => {
          this.updateRenderProgress(current, total, fileName);
        }
      };
      await this.bookRenderService.renderToWebview(
        this.webview,
        this.selectedBook,
        this.plugin.settings.defaultBookPath,
        renderConfig
      );
      if (!this.abortController.signal.aborted) {
        this.webviewReady = true;
        loading.remove();
        this.webview.style.opacity = "1";
        this.webview.style.transition = "opacity 0.3s ease-in-out";
        console.log("Rendering completed successfully");
        if (this.exportSettings.showCover && this.exportSettings.cover) {
          this.updateCoverPreview();
          const coverPreviewContainer = this.previewContainer.querySelector(".cover-preview-container");
          if (coverPreviewContainer) {
            coverPreviewContainer.style.display = "block";
          }
        }
      }
    } catch (error) {
      if (((_d = this.abortController) == null ? void 0 : _d.signal.aborted) || error.message === "Render aborted") {
        console.log("Rendering was aborted");
        return;
      }
      console.error("Render failed:", error);
      this.webviewReady = false;
      if (this.isRendering) {
        previewContent.empty();
        const errorEl = previewContent.createDiv({ cls: "preview-error" });
        errorEl.innerHTML = `
                    <div class="preview-error-icon">\u274C</div>
                    <div class="preview-error-text">${error.message || "\u6E32\u67D3\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5"}</div>
                    <button class="preview-retry-btn">\u91CD\u65B0\u6E32\u67D3</button>
                `;
        const retryBtn = errorEl.querySelector(".preview-retry-btn");
        retryBtn == null ? void 0 : retryBtn.addEventListener("click", () => {
          this.startRenderPreview();
        });
        new import_obsidian20.Notice("\u6E32\u67D3\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u63A7\u5236\u53F0\u9519\u8BEF\u4FE1\u606F");
      }
    } finally {
      if (!((_e = this.abortController) == null ? void 0 : _e.signal.aborted)) {
        this.isRendering = false;
        this.updateFormatButtonsState();
        setTimeout(() => {
          this.updateExportButtonState();
        }, 100);
      }
    }
  }
  // 创建设置区域的内容，包括书籍信息、格式选择和设置区域
  createSettingsContent(container) {
    this.createBookInfo(container);
    this.createFormatSelection(container);
    this.createSettingsArea(container);
  }
  // 创建模态框底部的按钮区域
  createFooter() {
    const { contentEl } = this;
    const footer = contentEl.createDiv({ cls: "export-modal-footer" });
    const buttonGroup = footer.createDiv({ cls: "export-button-group" });
    const cancelBtn = buttonGroup.createEl("button", {
      text: "\u53D6\u6D88",
      cls: "export-btn export-btn-secondary"
    });
    cancelBtn.addEventListener("click", () => this.handleCancel());
    this.exportBtn = buttonGroup.createEl("button", {
      text: "\u5BFC\u51FA",
      cls: "export-btn export-btn-primary"
    });
    this.exportBtn.addEventListener("click", () => this.handleExport());
    this.updateExportButtonState();
  }
  // 根据渲染状态更新导出按钮的可用性和文本
  updateExportButtonState() {
    if (this.exportBtn) {
      let canExport;
      if (this.selectedFormat === "pdf") {
        canExport = !!(this.selectedFormat && !this.isRendering && this.webviewReady);
      } else {
        canExport = !!this.selectedFormat && !this.isRendering;
      }
      this.exportBtn.disabled = !canExport;
      this.exportBtn.textContent = this.isRendering ? "\u6E32\u67D3\u4E2D..." : "\u5BFC\u51FA";
    }
  }
  // 根据渲染状态更新格式按钮的可用性和样式
  updateFormatButtonsState() {
    this.formatButtons.forEach((btn) => {
      if (this.isRendering) {
        btn.classList.add("disabled");
        btn.style.pointerEvents = "none";
        btn.style.opacity = "0.6";
      } else {
        btn.classList.remove("disabled");
        btn.style.pointerEvents = "auto";
        btn.style.opacity = "1";
      }
    });
  }
  // 处理取消按钮点击
  async handleCancel() {
    this.stopRendering();
    this.cleanupWebview();
    this.close();
  }
  // 中止正在进行的渲染
  stopRendering() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    this.isRendering = false;
    this.updateExportButtonState();
    this.updateFormatButtonsState();
  }
  // 显示书籍基本信息（标题、作者、描述）
  createBookInfo(container) {
    const bookCard = container.createDiv({ cls: "export-book-card" });
    const bookIcon = bookCard.createDiv({ cls: "export-book-icon" });
    bookIcon.innerHTML = "\u{1F4D6}";
    const bookDetails = bookCard.createDiv({ cls: "export-book-details" });
    bookDetails.createEl("h3", {
      text: this.selectedBook.basic.title,
      cls: "export-book-title"
    });
    if (this.selectedBook.basic.author && this.selectedBook.basic.author.length > 0) {
      bookDetails.createEl("p", {
        text: `\u4F5C\u8005: ${this.selectedBook.basic.author.join(", ")}`,
        cls: "export-book-author"
      });
    }
    if (this.selectedBook.basic.desc) {
      bookDetails.createEl("p", {
        text: this.selectedBook.basic.desc,
        cls: "export-book-desc"
      });
    }
  }
  // 创建导出格式选择区域（PDF、TXT、DOCX）
  createFormatSelection(container) {
    const formatSection = container.createDiv({ cls: "export-format-section" });
    formatSection.createEl("h4", {
      text: "\u9009\u62E9\u5BFC\u51FA\u683C\u5F0F",
      cls: "export-section-title"
    });
    const formatGrid = formatSection.createDiv({ cls: "export-format-grid" });
    const formats = [
      { key: "pdf", label: "PDF", icon: "\u{1F4C4}", desc: "\u4FBF\u643A\u6587\u6863\u683C\u5F0F" },
      // { key: 'txt', label: 'TXT', icon: '📝', desc: '纯文本格式' },
      { key: "docx", label: "DOCX", icon: "\u{1F4CB}", desc: "Word\u6587\u6863\u683C\u5F0F" }
    ];
    formats.forEach((format) => {
      const formatCard = formatGrid.createDiv({ cls: "export-format-card" });
      const formatIcon = formatCard.createDiv({ cls: "export-format-icon" });
      formatIcon.innerHTML = format.icon;
      const formatInfo = formatCard.createDiv({ cls: "export-format-info" });
      formatInfo.createEl("div", {
        text: format.label,
        cls: "export-format-label"
      });
      formatInfo.createEl("div", {
        text: format.desc,
        cls: "export-format-desc"
      });
      this.formatButtons.push(formatCard);
      formatCard.addEventListener("click", () => {
        if (this.isRendering) {
          new import_obsidian20.Notice("\u6E32\u67D3\u8FDB\u884C\u4E2D\uFF0C\u8BF7\u7A0D\u5019...");
          return;
        }
        this.formatButtons.forEach((btn) => btn.classList.remove("selected"));
        formatCard.classList.add("selected");
        this.selectedFormat = format.key;
        this.exportSettings.format = format.key;
        this.updateLayoutMode();
        this.updateSettingsArea();
        this.updatePreviewVisibility();
        if (format.key === "pdf") {
          setTimeout(() => {
            this.startRenderPreview();
          }, 50);
        } else {
          this.cleanupWebview();
        }
        this.updateExportButtonState();
      });
    });
  }
  // 创建设置区域的容器
  createSettingsArea(container) {
    const settingsSection = container.createDiv({ cls: "export-settings-section" });
    settingsSection.createEl("h4", {
      text: "\u5BFC\u51FA\u8BBE\u7F6E",
      cls: "export-section-title"
    });
    this.settingsContainer = settingsSection.createDiv({ cls: "export-settings-content" });
    const placeholder = this.settingsContainer.createDiv({ cls: "export-settings-placeholder" });
    placeholder.innerHTML = `
            <div class="export-placeholder-icon">\u2699\uFE0F</div>
            <div class="export-placeholder-text">\u8BF7\u5148\u9009\u62E9\u5BFC\u51FA\u683C\u5F0F</div>
        `;
  }
  // 根据选择的格式更新设置区域
  updateSettingsArea() {
    this.settingsContainer.empty();
    if (!this.selectedFormat) {
      const placeholder = this.settingsContainer.createDiv({ cls: "export-settings-placeholder" });
      placeholder.innerHTML = `
                <div class="export-placeholder-icon">\u2699\uFE0F</div>
                <div class="export-placeholder-text">\u8BF7\u5148\u9009\u62E9\u5BFC\u51FA\u683C\u5F0F</div>
            `;
      return;
    }
    const settingsGrid = this.settingsContainer.createDiv({ cls: "export-settings-grid" });
    this.createCommonSettings(settingsGrid);
    if (this.selectedFormat === "pdf") {
      this.createPdfSettings(settingsGrid);
    } else if (this.selectedFormat === "html") {
      this.createHtmlSettings(settingsGrid);
    } else if (this.selectedFormat === "docx") {
      this.createDocxSettings(settingsGrid);
    }
  }
  // 创建通用设置（如开本大小）
  createCommonSettings(container) {
    if (["pdf", "docx"].includes(this.selectedFormat)) {
      const sizeCard = container.createDiv({ cls: "export-setting-card" });
      const sizeHeader = sizeCard.createDiv({ cls: "export-setting-header" });
      sizeHeader.style.marginBottom = "16px";
      sizeHeader.innerHTML = `
                <span class="export-setting-icon" style="font-size: 18px;">\u{1F4CF}</span>
                <span class="export-setting-title" style="font-size: 15px;">\u5F00\u672C\u5927\u5C0F</span>
            `;
      const sizeSelectContainer = sizeCard.createDiv();
      const sizeSelect = sizeSelectContainer.createEl("select", { cls: "export-setting-select" });
      const sizes = ["A4", "A5", "A3", "Letter", "Legal", "Tabloid"];
      sizes.forEach((size) => {
        const option = sizeSelect.createEl("option", { value: size, text: size });
        if (size === (this.exportSettings.bookSize || "A4"))
          option.selected = true;
      });
      sizeSelect.addEventListener("change", () => {
        this.exportSettings.bookSize = sizeSelect.value;
        if (this.exportSettings.showCover && this.webviewReady) {
          this.updateCoverPreview();
        }
      });
    }
  }
  // 创建 PDF 特定设置（封面设置、页眉页脚目录设置）
  createPdfSettings(container) {
    const coverCard = container.createDiv({ cls: "export-setting-card" });
    const coverHeader = coverCard.createDiv({ cls: "export-setting-header" });
    coverHeader.innerHTML = `
            <span class="export-setting-icon" style="font-size: 18px;">\u{1F3A8}</span>
            <span class="export-setting-title" style="font-size: 15px;">\u5C01\u9762\u8BBE\u7F6E</span>
        `;
    const coverControlsContainer = coverCard.createDiv({ cls: "cover-controls-container" });
    const coverToggle = coverControlsContainer.createDiv({ cls: "export-setting-toggle" });
    const coverCheckbox = coverToggle.createEl("input", { type: "checkbox", attr: { id: "cover-toggle" } });
    coverToggle.createEl("label", { text: "\u5305\u542B\u5C01\u9762", attr: { for: "cover-toggle" } });
    coverCheckbox.checked = this.exportSettings.showCover !== false;
    const coverSettingButton = coverControlsContainer.createEl("button", {
      cls: "export-setting-button",
      text: "\u81EA\u5B9A\u4E49\u5C01\u9762"
    });
    coverCheckbox.addEventListener("change", () => {
      this.exportSettings.showCover = coverCheckbox.checked;
      const coverPreviewContainer = this.previewContainer.querySelector(".cover-preview-container");
      if (coverPreviewContainer) {
        coverPreviewContainer.style.display = this.exportSettings.showCover && this.webviewReady ? "block" : "none";
      }
    });
    coverSettingButton.addEventListener("click", () => {
      const coverModal = new CoverSettingModal(
        this.app,
        (settings) => {
          this.exportSettings.cover = settings;
          this.updateCoverPreview();
        },
        document.createElement("div"),
        // 临时元素作为预览容器
        new CoverManager(this.app),
        this.exportSettings.cover,
        this.selectedBook.basic.title,
        this.selectedBook.basic.author,
        this.selectedBook.basic.subtitle
      );
      coverModal.open();
    });
    const headerFooterTocCard = container.createDiv({ cls: "export-setting-card" });
    const headerFooterTocHeader = headerFooterTocCard.createDiv({ cls: "export-setting-header" });
    headerFooterTocHeader.innerHTML = `
            <span class="export-setting-icon" style="font-size: 18px;">\u{1F4D1}</span>
            <span class="export-setting-title" style="font-size: 15px;">\u9875\u7709\u9875\u811A\u76EE\u5F55\u8BBE\u7F6E</span>
        `;
    const headerFooterTocButtonContainer = headerFooterTocCard.createDiv();
    const headerFooterTocButton = headerFooterTocButtonContainer.createEl("button", {
      cls: "export-setting-button",
      text: "\u81EA\u5B9A\u4E49\u9875\u7709\u9875\u811A\u548C\u76EE\u5F55"
    });
    headerFooterTocButton.addEventListener("click", () => {
      const headerFooterTocModal = new HeaderFooterTocModal(
        this.plugin,
        this.exportSettings.headerFooterToc || {},
        (settings) => {
          this.exportSettings.headerFooterToc = settings;
          this.renderSettings.displayHeader = settings.headerEnabled;
          this.renderSettings.displayFooter = settings.footerEnabled;
        }
      );
      headerFooterTocModal.open();
    });
  }
  // 创建 HTML 特定设置（占位符）
  createHtmlSettings(container) {
  }
  // 创建 DOCX 特定设置（占位符）
  createDocxSettings(container) {
  }
  // 显示保存文件对话框
  async getOutputFile(filename) {
    try {
      const result = await electron.remote.dialog.showSaveDialog({
        title: "\u5BFC\u51FA PDF",
        defaultPath: `${filename}.pdf`,
        filters: [
          { name: "PDF Files", extensions: ["pdf"] },
          { name: "All Files", extensions: ["*"] }
        ],
        properties: ["showOverwriteConfirmation", "createDirectory"]
      });
      if (result.canceled) {
        return void 0;
      }
      return result.filePath;
    } catch (error) {
      console.error("Error showing save dialog:", error);
      new import_obsidian20.Notice("\u65E0\u6CD5\u6253\u5F00\u4FDD\u5B58\u5BF9\u8BDD\u6846");
      return void 0;
    }
  }
  // 导出为 PDF
  async exportToPdf() {
    var _a, _b, _c, _d;
    if (!this.webview || !this.webviewReady) {
      new import_obsidian20.Notice("PDF \u9884\u89C8\u672A\u51C6\u5907\u5C31\u7EEA\uFF0C\u8BF7\u7A0D\u5019");
      return;
    }
    try {
      const filename = this.selectedBook.basic.title || "exported-book";
      const outputFile = await this.getOutputFile(filename);
      if (!outputFile) {
        return;
      }
      let headerTemplate = "";
      if (this.renderSettings.displayHeader && ((_a = this.exportSettings.headerFooterToc) == null ? void 0 : _a.headerEnabled)) {
        headerTemplate = `
                <div style="font-size: ${((_b = this.exportSettings.headerFooterToc) == null ? void 0 : _b.headerFontSize) || 15}px; color: ${this.exportSettings.headerFooterToc.headerColor || "#000000"}; width: 100%; display: flex; justify-content: space-between; padding: 10px 50px; box-sizing: border-box; border-bottom: 1px solid #ddd;">
                    <div style="text-align: left;">${this.processVariables(this.exportSettings.headerFooterToc.headerLeft || "")}</div>
                    <div style="text-align: center;">${this.processVariables(this.exportSettings.headerFooterToc.headerCenter || "")}</div>
                    <div style="text-align: right;">${this.processVariables(this.exportSettings.headerFooterToc.headerRight || "")}</div>
                </div>
            `;
      }
      let footerTemplate = "";
      if (this.renderSettings.displayFooter && ((_c = this.exportSettings.headerFooterToc) == null ? void 0 : _c.footerEnabled)) {
        footerTemplate = `
                <div style="font-size: ${this.exportSettings.headerFooterToc.footerFontSize || 15}px; color: ${this.exportSettings.headerFooterToc.footerColor || "#000000"}; width: 100%; display: flex; justify-content: space-between; padding: 10px 50px;  box-sizing: border-box; border-top: 1px solid #ddd;">
                <span style="flex: 1; text-align: left;">${this.processVariables(this.exportSettings.headerFooterToc.footerLeft || "")}</span>
                <span style="flex: 1; text-align: center;">${this.processVariables(this.exportSettings.headerFooterToc.footerCenter || "")}</span>
                <span style="flex: 1; text-align: right;">${this.processVariables(this.exportSettings.headerFooterToc.footerRight || "").replace("{{pageNumber}}", '<span class="pageNumber"></span>').replace("{{totalPages}}", '<span class="totalPages"></span>')}</span>
                </div>
            `;
      }
      if ((_d = this.exportSettings.headerFooterToc) == null ? void 0 : _d.tocEnabled) {
        await this.updateTocPageNumbers();
      }
      const printOptions = {
        pageSize: this.exportSettings.bookSize || "A4",
        printBackground: false,
        landscape: false,
        scale: this.renderSettings.scale / 100,
        margins: {
          top: 1,
          // 加大页眉区域空间
          bottom: 1,
          left: 0.6,
          right: 0
        },
        displayHeaderFooter: this.renderSettings.displayHeader || this.renderSettings.displayFooter,
        headerTemplate,
        footerTemplate,
        generateDocumentOutline: true
      };
      const pdfBuffer = await this.webview.printToPDF(printOptions);
      let finalPdfBuffer = pdfBuffer;
      if (this.exportSettings.showCover && this.exportSettings.cover && this.coverPreviewElement) {
        const coverContainer = this.coverPreviewElement.querySelector(".cover-container");
        if (!coverContainer) {
          console.warn("\u672A\u627E\u5230\u5C01\u9762\u5BB9\u5668\u5143\u7D20");
          return null;
        }
        const coverImageData = await this.convertCoverToImage(coverContainer);
        if (coverImageData) {
          this.exportSettings.coverImageData = coverImageData;
          finalPdfBuffer = Buffer.from(await this.generateAndMergeCover(Buffer.from(pdfBuffer)));
        } else {
          finalPdfBuffer = await this.generateAndMergeCover(Buffer.from(pdfBuffer));
        }
      } else if (this.exportSettings.showCover && this.exportSettings.cover) {
        finalPdfBuffer = await this.generateAndMergeCover(Buffer.from(pdfBuffer));
      }
      await fs.writeFile(outputFile, finalPdfBuffer);
      new import_obsidian20.Notice("PDF \u5BFC\u51FA\u6210\u529F\uFF01");
      const shouldOpen = confirm("PDF \u5BFC\u51FA\u6210\u529F\uFF01\u662F\u5426\u6253\u5F00\u6587\u4EF6\uFF1F");
      if (shouldOpen) {
        electron.remote.shell.openPath(outputFile);
      }
      this.close();
    } catch (error) {
      console.error("PDF export failed:", error);
      new import_obsidian20.Notice("PDF \u5BFC\u51FA\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 更新目录页码
   */
  async updateTocPageNumbers() {
    try {
      const script = `
                (function() {
                     // \u521B\u5EFA\u4E00\u4E2A\u6620\u5C04\uFF0C\u5B58\u50A8\u6BCF\u4E2A\u6807\u9898ID\u5BF9\u5E94\u7684\u9875\u7801
                    const headingPageMap = {};
                    
                    // \u83B7\u53D6\u6240\u6709\u6807\u9898\u5143\u7D20
                    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                    
                    // \u8BA1\u7B97\u6BCF\u4E2A\u6807\u9898\u6240\u5728\u7684\u9875\u7801
                    headings.forEach(heading => {
                        if (!heading.id) return;
                        
                        // \u83B7\u53D6\u5143\u7D20\u7684\u4F4D\u7F6E\u4FE1\u606F
                        const rect = heading.getBoundingClientRect();
                        
                        // \u8BA1\u7B97\u9875\u7801\uFF08\u57FA\u4E8EA4\u7EB8\u5F20\u548C\u9ED8\u8BA4\u8FB9\u8DDD\uFF09
                        // \u8FD9\u91CC\u7684\u8BA1\u7B97\u662F\u8FD1\u4F3C\u7684\uFF0C\u5B9E\u9645\u9875\u7801\u53EF\u80FD\u4F1A\u6709\u5DEE\u5F02
                        const pageHeight = 1122; // A4\u7EB8\u5F20\u9AD8\u5EA6\uFF08\u70B9\uFF09
                        const pageNumber = Math.floor(rect.top / pageHeight) + 1;
                        
                        headingPageMap[heading.id] = pageNumber;
                    });
                    
                    // \u66F4\u65B0\u76EE\u5F55\u4E2D\u7684\u9875\u7801
                    const tocPageElements = document.querySelectorAll('.toc-page');
                    tocPageElements.forEach(pageEl => {
                        const headingId = pageEl.getAttribute('data-heading-id');
                        if (headingId && headingPageMap[headingId]) {
                            pageEl.textContent = headingPageMap[headingId];
                        }
                    });
                    
                    return true;
                })();
            `;
      if (this.webview) {
        await this.webview.executeJavaScript(script);
      }
    } catch (error) {
      console.error("Failed to update TOC page numbers:", error);
    }
  }
  /**
   * 生成封面并与内容PDF合并
   */
  async generateAndMergeCover(contentPdfBuffer) {
    try {
      if (this.exportSettings.coverImageData) {
        const coverPdfDoc = await import_pdf_lib.PDFDocument.create();
        const pageSizes = {
          "A4": [595.28, 841.89],
          "A5": [419.53, 595.28],
          "A3": [841.89, 1190.55],
          "Letter": [612, 792],
          "Legal": [612, 1008],
          "Tabloid": [792, 1224]
        };
        const pageSize = pageSizes[this.exportSettings.bookSize] || pageSizes["A4"];
        const coverPage = coverPdfDoc.addPage([pageSize[0], pageSize[1]]);
        const coverImage = await coverPdfDoc.embedPng(this.exportSettings.coverImageData);
        const { width, height } = coverImage.size();
        const scale = Math.min(
          coverPage.getWidth() / width,
          coverPage.getHeight() / height
        );
        coverPage.drawImage(coverImage, {
          x: (coverPage.getWidth() - width * scale) / 2,
          y: (coverPage.getHeight() - height * scale) / 2,
          width: width * scale,
          height: height * scale
        });
        const contentPdfDoc = await import_pdf_lib.PDFDocument.load(contentPdfBuffer);
        const finalPdfDoc = await import_pdf_lib.PDFDocument.create();
        const [coverPageCopy] = await finalPdfDoc.copyPages(coverPdfDoc, [0]);
        finalPdfDoc.addPage(coverPageCopy);
        const contentPages = await finalPdfDoc.copyPages(
          contentPdfDoc,
          contentPdfDoc.getPageIndices()
        );
        contentPages.forEach((page) => finalPdfDoc.addPage(page));
        return Buffer.from(await finalPdfDoc.save());
      } else {
        const coverContainer = document.createElement("div");
        coverContainer.style.position = "fixed";
        coverContainer.style.top = "-9999px";
        coverContainer.style.left = "-9999px";
        document.body.appendChild(coverContainer);
        if (this.exportSettings.cover) {
          const coverHTML = this.generateCoverHTML(this.exportSettings.cover, this.selectedBook);
          coverContainer.innerHTML = coverHTML;
        }
        await new Promise((resolve) => setTimeout(resolve, 300));
        let coverImageData = await this.convertCoverToImage(coverContainer);
        document.body.removeChild(coverContainer);
        if (!coverImageData) {
          return this.createSimpleCoverAndMerge(contentPdfBuffer);
        }
        this.exportSettings.coverImageData = coverImageData;
        return this.generateAndMergeCover(contentPdfBuffer);
      }
    } catch (error) {
      console.error("Failed to generate and merge cover:", error);
      return contentPdfBuffer;
    }
  }
  /**
   * 生成封面HTML
   */
  generateCoverHTML(settings, book) {
    var _a, _b, _c, _d, _e, _f;
    if (!settings)
      return "";
    const tempContainer = document.createElement("div");
    tempContainer.className = "book-cover";
    tempContainer.style.pageBreakAfter = "always";
    tempContainer.style.breakAfter = "page";
    this.applyBookSizeStyles(tempContainer, settings.bookSize || this.exportSettings.bookSize || "A4");
    if (settings.imageUrl) {
      tempContainer.style.backgroundImage = `url(${settings.imageUrl})`;
      tempContainer.style.backgroundSize = `${settings.scale * 100}%`;
      tempContainer.style.backgroundPosition = `${settings.position.x}px ${settings.position.y}px`;
      tempContainer.style.backgroundRepeat = "no-repeat";
    }
    const contentContainer = document.createElement("div");
    contentContainer.className = "cover-content";
    contentContainer.style.position = "relative";
    contentContainer.style.height = "100%";
    contentContainer.style.display = "flex";
    contentContainer.style.flexDirection = "column";
    contentContainer.style.justifyContent = "center";
    contentContainer.style.alignItems = "center";
    contentContainer.style.padding = "40px";
    contentContainer.style.textAlign = "center";
    tempContainer.appendChild(contentContainer);
    const titleText = settings.customTitle || book.basic.title;
    const subtitleText = settings.customSubtitle || book.basic.subtitle;
    const authorText = settings.customAuthor || (book.basic.author ? book.basic.author.join(", ") : "");
    if (titleText) {
      const titleEl = document.createElement("div");
      titleEl.className = "cover-title";
      titleEl.textContent = titleText;
      let titleStyle = "";
      if (settings.titleStyleConfig) {
        titleStyle = this.buildStyleString(settings.titleStyleConfig);
      } else {
        titleStyle = settings.titleStyle || "";
      }
      titleEl.setAttribute("style", titleStyle + `position: absolute; left: ${((_a = settings.titlePosition) == null ? void 0 : _a.x) || 50}%; top: ${((_b = settings.titlePosition) == null ? void 0 : _b.y) || 30}%; transform: translate(-50%, -50%); z-index: 10;`);
      contentContainer.appendChild(titleEl);
    }
    if (subtitleText) {
      const subtitleEl = document.createElement("div");
      subtitleEl.className = "cover-subtitle";
      subtitleEl.textContent = subtitleText;
      let subtitleStyle = "";
      if (settings.subtitleStyleConfig) {
        subtitleStyle = this.buildStyleString(settings.subtitleStyleConfig);
      } else {
        subtitleStyle = "font-size: 18px; color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.5);";
      }
      subtitleEl.setAttribute("style", subtitleStyle + `position: absolute; left: ${((_c = settings.subtitlePosition) == null ? void 0 : _c.x) || 50}%; top: ${((_d = settings.subtitlePosition) == null ? void 0 : _d.y) || 50}%; transform: translate(-50%, -50%); z-index: 10;`);
      contentContainer.appendChild(subtitleEl);
    }
    if (authorText) {
      const authorEl = document.createElement("div");
      authorEl.className = "cover-author";
      authorEl.textContent = authorText;
      let authorStyle = "";
      if (settings.authorStyleConfig) {
        authorStyle = this.buildStyleString(settings.authorStyleConfig);
      } else {
        authorStyle = settings.authorStyle || "";
      }
      authorEl.setAttribute("style", authorStyle + `position: absolute; left: ${((_e = settings.authorPosition) == null ? void 0 : _e.x) || 50}%; top: ${((_f = settings.authorPosition) == null ? void 0 : _f.y) || 70}%; transform: translate(-50%, -50%); z-index: 10;`);
      contentContainer.appendChild(authorEl);
    }
    return tempContainer.outerHTML;
  }
  /**
   * 构建样式字符串
   */
  buildStyleString(styleConfig) {
    return `font-size: ${styleConfig.fontSize}px; color: ${styleConfig.color}; font-weight: ${styleConfig.fontWeight}; font-style: ${styleConfig.fontStyle}; text-shadow: ${styleConfig.textShadow || "none"}; `;
  }
  /**
   * 应用开本大小样式
   */
  applyBookSizeStyles(element, bookSize) {
    const sizeMap = {
      "A4": { aspectRatio: "210/297" },
      "A5": { aspectRatio: "148/210" },
      "A3": { aspectRatio: "297/420" },
      "Legal": { aspectRatio: "8.5/14" },
      "Letter": { aspectRatio: "8.5/11" },
      "Tabloid": { aspectRatio: "11/17" }
    };
    const size = sizeMap[bookSize] || sizeMap["A4"];
    element.style.aspectRatio = size.aspectRatio;
    element.style.width = "100%";
    element.style.height = "auto";
  }
  /**
   * 将封面HTML转换为图片
   */
  async convertCoverToImage(coverElement) {
    try {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const htmlToImage = require_lib2();
      const exportConfig = {
        quality: 1,
        pixelRatio: 2,
        // 提高分辨率
        backgroundColor: "#333333",
        // 默认背景色
        style: {
          transform: "scale(1)",
          transformOrigin: "top left"
        }
      };
      try {
        const dataUrl = await htmlToImage.toPng(coverElement, exportConfig);
        return dataUrl;
      } catch (err) {
        console.warn("toPng \u5931\u8D25\uFF0C\u5C1D\u8BD5\u5907\u7528\u65B9\u6CD5", err);
        const canvas = await htmlToImage.toCanvas(coverElement, exportConfig);
        return canvas.toDataURL("image/png", 0.9);
      }
    } catch (error) {
      console.error("\u5C01\u9762\u8F6C\u56FE\u7247\u5931\u8D25:", error);
      return null;
    }
  }
  /**
   * 创建简单的文本封面并合并
   */
  async createSimpleCoverAndMerge(contentPdfBuffer) {
    const coverPdfDoc = await import_pdf_lib.PDFDocument.create();
    const pageSizes = {
      "A4": [595.28, 841.89],
      "A5": [419.53, 595.28],
      "A3": [841.89, 1190.55],
      "Letter": [612, 792],
      "Legal": [612, 1008],
      "Tabloid": [792, 1224]
    };
    const pageSize = pageSizes[this.exportSettings.bookSize] || pageSizes["A4"];
    const coverPage = coverPdfDoc.addPage([pageSize[0], pageSize[1]]);
    const { rgb } = require_cjs();
    coverPage.drawText(this.selectedBook.basic.title || "Book Title", {
      x: 50,
      y: coverPage.getHeight() - 150,
      size: 24,
      color: rgb(0, 0, 0)
    });
    if (this.selectedBook.basic.subtitle) {
      coverPage.drawText(this.selectedBook.basic.subtitle, {
        x: 50,
        y: coverPage.getHeight() - 200,
        size: 18,
        color: rgb(0.3, 0.3, 0.3)
      });
    }
    if (this.selectedBook.basic.author && this.selectedBook.basic.author.length > 0) {
      coverPage.drawText(this.selectedBook.basic.author.join(", "), {
        x: 50,
        y: coverPage.getHeight() - 250,
        size: 16,
        color: rgb(0.5, 0.5, 0.5)
      });
    }
    const coverPdfBytes = await coverPdfDoc.save();
    const contentPdfDoc = await import_pdf_lib.PDFDocument.load(contentPdfBuffer);
    const finalPdfDoc = await import_pdf_lib.PDFDocument.create();
    const [coverPageCopy] = await finalPdfDoc.copyPages(coverPdfDoc, [0]);
    finalPdfDoc.addPage(coverPageCopy);
    const contentPages = await finalPdfDoc.copyPages(
      contentPdfDoc,
      contentPdfDoc.getPageIndices()
    );
    contentPages.forEach((page) => finalPdfDoc.addPage(page));
    return Buffer.from(await finalPdfDoc.save());
  }
  // 处理页眉页脚模板中的变量（如 {{title}}、{{author}}、{{date}}）
  processVariables(text) {
    if (!text)
      return "";
    return text.replace("{{title}}", this.selectedBook.basic.title || "").replace("{{author}}", Array.isArray(this.selectedBook.basic.author) ? this.selectedBook.basic.author.join(", ") : this.selectedBook.basic.author || "").replace("{{date}}", new Date().toLocaleDateString());
  }
  // 导出为 TXT（开发中）
  async exportToTxt() {
    new import_obsidian20.Notice("TXT \u5BFC\u51FA\u529F\u80FD\u5F00\u53D1\u4E2D...");
  }
  // 导出为 DOCX（开发中）
  async exportToDocx() {
    new import_obsidian20.Notice("DOCX \u5BFC\u51FA\u529F\u80FD\u5F00\u53D1\u4E2D...");
  }
  // 根据选择的格式调用相应的导出方法
  async handleExport() {
    if (!this.selectedFormat) {
      new import_obsidian20.Notice("\u8BF7\u5148\u9009\u62E9\u5BFC\u51FA\u683C\u5F0F");
      return;
    }
    switch (this.selectedFormat) {
      case "pdf":
        await this.exportToPdf();
        break;
      case "txt":
        await this.exportToTxt();
        break;
      case "docx":
        await this.exportToDocx();
        break;
      default:
        new import_obsidian20.Notice("\u4E0D\u652F\u6301\u7684\u5BFC\u51FA\u683C\u5F0F");
    }
  }
  // 在模态框关闭时执行清理操作
  onClose() {
    this.stopRendering();
    this.cleanupWebview();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/services/BookRenderService.ts
var import_obsidian21 = require("obsidian");
var BookRenderService = class {
  constructor(app) {
    this.app = app;
    this.docs = [];
    this.scale = 1;
  }
  /**
   * 主要渲染方法 - 基于 obsidian-better-export-pdf 架构
   */
  async renderToWebview(webview, book, rootPath, config) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error("Webview setup timeout"));
      }, 1e4);
      webview.addEventListener("dom-ready", async () => {
        var _a;
        try {
          clearTimeout(timeout);
          const { data, docs } = await this.getAllFiles(book, rootPath, config);
          await this.renderFiles(data, docs, config);
          let tocHtml = "";
          if ((_a = config.headerFooterToc) == null ? void 0 : _a.tocEnabled) {
            tocHtml = this.generateTOC(config.headerFooterToc, book);
          }
          const styles = this.getAllStyles();
          for (const css of styles) {
            await webview.insertCSS(css);
          }
          if ((config == null ? void 0 : config.cssSnippet) && config.cssSnippet !== "0") {
            try {
              await webview.insertCSS(config.cssSnippet);
            } catch (error) {
              console.warn("Failed to load CSS snippet:", error);
            }
          }
          if (tocHtml) {
            const doc = this.docs[0].doc;
            const contentEl = doc.querySelector(".markdown-preview-view");
            if (contentEl) {
              const tocContainer = doc.createElement("div");
              tocContainer.innerHTML = tocHtml;
              contentEl.insertBefore(tocContainer, contentEl.firstChild);
            }
          }
          await this.appendWebview(webview, this.docs[0]);
          const patchStyles = this.getPatchStyles();
          for (const css of patchStyles) {
            await webview.insertCSS(css);
          }
          resolve();
        } catch (error) {
          clearTimeout(timeout);
          reject(error);
        }
      });
    });
  }
  /**
   * 收集所有文件 - 对应 modal.ts 的 getAllFiles
   */
  async getAllFiles(book, rootPath, config) {
    const fileNodes = this.collectFileNodes(book.structure.tree);
    const data = fileNodes.map((node) => ({
      app: this.app,
      file: this.getFileFromNode(node, book, rootPath),
      config,
      book,
      rootPath,
      extra: {
        title: node.title,
        id: node.id
      }
    })).filter((param) => param.file !== null);
    return { data, docs: [] };
  }
  /**
   * 渲染所有文件 - 对应 modal.ts 的 renderFiles
   */
  async renderFiles(data, docs = [], config) {
    const totalFiles = data.length;
    const inputs = data.map(
      (param, i) => this.renderMarkdown(param).then((res) => {
        var _a;
        (_a = config.onProgress) == null ? void 0 : _a.call(config, i + 1, totalFiles, param.file.basename);
        return res;
      })
    );
    let _docs = [...docs, ...await Promise.all(inputs)];
    _docs = this.mergeDoc(_docs);
    this.docs = _docs.map(({ doc, ...rest }) => {
      return { ...rest, doc: this.fixDoc(doc, doc.title) };
    });
  }
  /**
   * 渲染单个Markdown文件 - 基于 render.ts 的 renderMarkdown
   */
  async renderMarkdown({ app, file, config, book, extra }) {
    var _a;
    const startTime = new Date().getTime();
    if ((_a = config.abortSignal) == null ? void 0 : _a.aborted) {
      throw new Error("Render aborted");
    }
    const leaf = app.workspace.getLeaf(true);
    await leaf.openFile(file);
    const view = leaf.view;
    const data = (view == null ? void 0 : view.data) || await app.vault.cachedRead(file);
    const frontMatter = this.getFrontMatter(file);
    const cssclasses = this.extractCssClasses(frontMatter);
    const comp = new import_obsidian21.Component();
    comp.load();
    try {
      const printEl = document.body.createDiv("print");
      const viewEl = printEl.createDiv({
        cls: "markdown-preview-view markdown-rendered " + cssclasses.join(" ")
      });
      viewEl.toggleClass("rtl", app.vault.getConfig("rightToLeft"));
      viewEl.toggleClass("show-properties", "hidden" !== app.vault.getConfig("propertiesInDocument"));
      const title = (extra == null ? void 0 : extra.title) || (frontMatter == null ? void 0 : frontMatter.title) || file.basename;
      viewEl.createEl("h1", { text: title }, (e) => {
        e.addClass("__title__");
        e.style.display = config.showTitle ? "block" : "none";
        e.id = (extra == null ? void 0 : extra.id) || "";
      });
      const processedData = this.processBlockReferences(data || "", file);
      const fragment = this.createRenderFragment();
      const promises = [];
      try {
        await import_obsidian21.MarkdownRenderer.render(app, processedData, fragment, file.path, comp);
      } catch (error) {
      }
      const el = createFragment();
      Array.from(fragment.children).forEach((item) => {
        el.createDiv({}, (t) => {
          return t.appendChild(item);
        });
      });
      viewEl.appendChild(el);
      await import_obsidian21.MarkdownRenderer.postProcess(app, {
        docId: this.generateDocId(16),
        sourcePath: file.path,
        frontmatter: {},
        promises,
        addChild: function(e) {
          return comp.addChild(e);
        },
        getSectionInfo: function() {
          return null;
        },
        containerEl: viewEl,
        el: viewEl,
        displayMode: true
      });
      await Promise.all(promises);
      this.fixInternalLinks(printEl, file);
      await this.fixWaitRender(data || "", viewEl);
      this.fixCanvasToImage(viewEl);
      const doc = document.implementation.createHTMLDocument("document");
      doc.body.appendChild(printEl.cloneNode(true));
      doc.title = title;
      printEl.detach();
      printEl.remove();
      leaf.detach();
      return { doc, frontMatter, file, title };
    } finally {
      comp.unload();
    }
  }
  /**
   * 合并所有文档 - 对应 modal.ts 的 mergeDoc
   */
  mergeDoc(docs) {
    if (docs.length <= 1)
      return docs;
    const { doc: doc0, frontMatter, file, title } = docs[0];
    const sections = [];
    for (const { doc } of docs) {
      const element = doc.querySelector(".markdown-preview-view");
      if (element) {
        const section = doc0.createElement("section");
        section.className = "book-chapter";
        Array.from(element.children).forEach((child) => {
          section.appendChild(doc0.importNode(child, true));
        });
        sections.push(section);
      }
    }
    const root = doc0.querySelector(".markdown-preview-view");
    if (root) {
      root.innerHTML = "";
      sections.forEach((section, index) => {
        root.appendChild(section);
      });
    }
    return [{ doc: doc0, frontMatter, file, title }];
  }
  /**
   * 将文档注入到webview - 对应 modal.ts 的 appendWebview
   */
  async appendWebview(webview, docData) {
    const { doc } = docData;
    const webviewJs = this.makeWebviewJs(doc);
    try {
      await webview.executeJavaScript(webviewJs);
    } catch (error) {
      console.error("Failed to inject content to webview:", error);
      throw new Error(`Failed to render book: ${error.message}`);
    }
  }
  /**
   * 生成webview注入脚本 - 对应 modal.ts 的 makeWebviewJs
   */
  makeWebviewJs(doc) {
    const bodyContent = doc.body.innerHTML;
    const headContent = doc.head.innerHTML;
    const docTitle = doc.title;
    return `
            try {
                // \u5B89\u5168\u5730\u8BBE\u7F6E\u5185\u5BB9
                document.body.innerHTML = decodeURIComponent(\`${encodeURIComponent(bodyContent)}\`);
                document.head.innerHTML = decodeURIComponent(\`${encodeURIComponent(headContent)}\`);
                
                // \u9012\u5F52\u89E3\u7801\u5D4C\u5165\u5185\u5BB9
                function decodeAndReplaceEmbed(element) {
                    if (!element || !element.innerHTML) return;
                    try {
                        element.innerHTML = decodeURIComponent(element.innerHTML);
                        const newEmbeds = element.querySelectorAll("span.markdown-embed");
                        newEmbeds.forEach(decodeAndReplaceEmbed);
                    } catch (e) {
                        console.warn('Failed to decode embed:', e);
                    }
                }
                
                document.querySelectorAll("span.markdown-embed").forEach(decodeAndReplaceEmbed);
                
                // \u5E94\u7528\u4E3B\u9898\u7C7B\u540D
                const currentBodyClasses = "${Array.from(document.body.classList).join(" ")}";
                const currentHtmlClasses = "${Array.from(document.documentElement.classList).join(" ")}";
                
                if (currentBodyClasses) {
                    document.body.className = currentBodyClasses;
                }
                if (currentHtmlClasses) {
                    document.documentElement.className = currentHtmlClasses;
                }
                
                // \u8BBE\u7F6E\u4E3B\u9898\u76F8\u5173\u5C5E\u6027
                const themeAttr = "${document.documentElement.getAttribute("data-theme") || ""}";
                const modeAttr = "${document.documentElement.getAttribute("data-mode") || ""}";
                
                if (themeAttr) document.documentElement.setAttribute('data-theme', themeAttr);
                if (modeAttr) document.documentElement.setAttribute('data-mode', modeAttr);
                
                document.body.addClass("theme-light");
                document.body.removeClass("theme-dark");
                document.title = \`${docTitle.replace(/[`\\]/g, "\\$&")}\`;
                
            } catch (error) {
                console.error('Error in webview script:', error);
                throw error;
            }
        `;
  }
  /**
   * 修复文档 - 对应 render.ts 的 fixDoc
   */
  fixDoc(doc, title) {
    this.encodeEmbeds(doc);
    return doc;
  }
  /**
   * 编码嵌入内容 - 对应 render.ts 的 encodeEmbeds
   */
  encodeEmbeds(doc) {
    const spans = Array.from(doc.querySelectorAll("span.markdown-embed")).reverse();
    spans.forEach((span) => {
      span.innerHTML = encodeURIComponent(span.innerHTML);
    });
  }
  /**
   * 根据章节节点获取文件对象
   */
  getFileFromNode(node, book, rootPath) {
    const filePath = `${rootPath}/${book.basic.title}/${node.path}`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian21.TFile ? file : null;
  }
  /**
   * 递归收集所有文件类型的章节节点
   */
  collectFileNodes(nodes) {
    const fileNodes = [];
    for (const node of nodes) {
      if (node.exclude)
        continue;
      if (node.type === "file") {
        fileNodes.push(node);
      } else if (node.type === "group" && node.children) {
        fileNodes.push(...this.collectFileNodes(node.children));
      }
    }
    return fileNodes.sort((a, b) => a.order - b.order);
  }
  /**
   * 获取前置元数据
   */
  getFrontMatter(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    return (cache == null ? void 0 : cache.frontmatter) || {};
  }
  /**
   * 提取CSS类
   */
  extractCssClasses(frontMatter) {
    const cssclasses = [];
    for (const [key, val] of Object.entries(frontMatter)) {
      if (key.toLowerCase() === "cssclass" || key.toLowerCase() === "cssclasses") {
        if (Array.isArray(val)) {
          cssclasses.push(...val);
        } else {
          cssclasses.push(val);
        }
      }
    }
    return cssclasses;
  }
  /**
   * 处理块引用
   */
  processBlockReferences(data, file) {
    const cache = this.app.metadataCache.getFileCache(file);
    const blocks = new Map(Object.entries((cache == null ? void 0 : cache.blocks) || {}));
    const lines = data.split("\n").map((line, i) => {
      for (const { id, position: { start: start2, end: end2 } } of blocks.values()) {
        const blockid = `^${id}`;
        if (line.includes(blockid) && i >= start2.line && i <= end2.line) {
          blocks.delete(id);
          return line.replace(blockid, `<span id="${blockid}" class="blockid"></span> ${blockid}`);
        }
      }
      return line;
    });
    [...blocks.values()].forEach(({ id, position: { start: start2 } }) => {
      const idx = start2.line;
      lines[idx] = `<span id="^${id}" class="blockid"></span>

` + lines[idx];
    });
    return lines.join("\n");
  }
  /**
   * 创建渲染片段
   */
  createRenderFragment() {
    return {
      children: void 0,
      appendChild(e) {
        this.children = e == null ? void 0 : e.children;
        throw new Error("exit");
      }
    };
  }
  /**
   * 修复内部链接
   */
  fixInternalLinks(printEl, file) {
    printEl.findAll("a.internal-link").forEach((el) => {
      var _a;
      const [title, anchor] = ((_a = el.dataset.href) == null ? void 0 : _a.split("#")) || [];
      if ((!title || (title == null ? void 0 : title.length) === 0 || title === file.basename) && (anchor == null ? void 0 : anchor.startsWith("^"))) {
        return;
      }
      el.removeAttribute("href");
    });
  }
  /**
   * 等待动态内容渲染
   */
  async fixWaitRender(data, viewEl) {
    if (data.includes("```dataview") || data.includes("```gEvent") || data.includes("![[")) {
      await this.sleep(2e3);
    }
    try {
      await this.waitForDomChange(viewEl);
    } catch (error) {
      await this.sleep(1e3);
    }
  }
  /**
   * 修复Canvas为图片
   */
  fixCanvasToImage(el) {
    for (const canvas of Array.from(el.querySelectorAll("canvas"))) {
      const data = canvas.toDataURL();
      const img = document.createElement("img");
      img.src = data;
      img.className = "__canvas__";
      Array.from(canvas.attributes).forEach((attr) => {
        img.setAttribute(attr.name, attr.value);
      });
      canvas.replaceWith(img);
    }
  }
  /**
   * 获取所有样式
   */
  getAllStyles() {
    const cssTexts = [];
    Array.from(document.styleSheets).forEach((sheet) => {
      var _a, _b;
      const id = (_a = sheet.ownerNode) == null ? void 0 : _a.id;
      if (id == null ? void 0 : id.startsWith("svelte-"))
        return;
      const href = (_b = sheet.ownerNode) == null ? void 0 : _b.href;
      const division = `/* ----------${id ? `id:${id}` : href ? `href:${href}` : "inline"}---------- */`;
      cssTexts.push(division);
      try {
        Array.from((sheet == null ? void 0 : sheet.cssRules) || []).forEach((rule) => {
          cssTexts.push(rule.cssText);
        });
      } catch (error) {
        console.error("Error reading CSS rules:", error);
      }
    });
    return cssTexts;
  }
  /**
   * 获取补丁样式
   */
  getPatchStyles() {
    const patchCSS = `
            /* ---------- css patch ---------- */
            body {
                overflow: auto !important;
            }
            
            @media print {
                .print .markdown-preview-view {
                    height: auto !important;
                }
                
                .md-print-anchor, .blockid {
                    white-space: pre !important;
                    border: none !important;
                    display: inline-block !important;
                    position: absolute !important;
                    width: 1px !important;
                    height: 1px !important;
                    right: 0 !important;
                }
            }
            
            img.__canvas__ {
                width: 100% !important;
                height: 100% !important;
            }
            
            .book-chapter {
                margin-bottom: 2em;
            }
            
            .page-break {
                page-break-after: always;
                break-after: page;
            }
        `;
    return [patchCSS];
  }
  /**
   * 工具方法
   */
  generateDocId(n) {
    return Array.from({ length: n }, () => (16 * Math.random() | 0).toString(16)).join("");
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  waitForDomChange(target, timeout = 2e3, interval = 200) {
    return new Promise((resolve, reject) => {
      let timer;
      const observer = new MutationObserver(() => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          observer.disconnect();
          resolve(true);
        }, interval);
      });
      observer.observe(target, {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
      });
      setTimeout(() => {
        observer.disconnect();
        reject(new Error(`timeout ${timeout}ms`));
      }, timeout);
    });
  }
  /**
   * 生成目录 HTML
   * @param settings 目录设置
   * @param book 书籍信息
   * @returns 目录 HTML 字符串
   */
  generateTOC(settings, book) {
    if (!(settings == null ? void 0 : settings.tocEnabled))
      return "";
    const headings = this.collectHeadings();
    if (headings.length === 0)
      return "";
    let tocHtml = `
            <div class="table-of-contents" style="
                page-break-after: ${settings.tocPageBreak ? "always" : "auto"};
                font-family: ${settings.tocFontFamily || "serif"};
                font-size: ${settings.tocFontSize}px;
                color: ${settings.tocColor || "#000000"};
                margin: 20px 0;
                line-height: ${settings.tocLineHeight};
            ">
                <h1 style="text-align: center; margin-bottom: 30px;">${settings.tocTitle}</h1>
                <div class="toc-content">
        `;
    headings.forEach((heading) => {
      if (heading.level <= settings.tocMaxLevel) {
        const indent = (heading.level - 1) * (settings.tocIndent || settings.tocIndentSize || 20);
        tocHtml += `
                    <div class="toc-item" style="
                        margin-left: ${indent}px;
                        margin-bottom: 8px;
                        display: flex;
                        justify-content: space-between;
                        align-items: baseline;
                    ">
                        <span class="toc-text">${heading.text}</span>
                        <span class="toc-dots" style="
                            flex: 1;
                            border-bottom: 1px dotted #ccc;
                            margin: 0 10px;
                            height: 1px;
                            align-self: center;
                        "></span>
                        <span class="toc-page" data-heading-id="${heading.id}">?</span>
                    </div>
                `;
      }
    });
    tocHtml += `
                </div>
            </div>
        `;
    return tocHtml;
  }
  /**
   * 收集文档中的所有标题
   * @returns 标题数组
   */
  collectHeadings() {
    const headings = [];
    this.docs.forEach((docData) => {
      const { doc } = docData;
      const headingElements = doc.querySelectorAll("h1, h2, h3, h4, h5, h6");
      headingElements.forEach((el, index) => {
        var _a;
        const level = parseInt(el.tagName.substring(1));
        const id = el.id || `heading-${index}`;
        if (!el.id)
          el.id = id;
        headings.push({
          level,
          text: ((_a = el.textContent) == null ? void 0 : _a.trim()) || "",
          id
        });
      });
    });
    return headings;
  }
};

// src/modals/BookSelectionModal.ts
var BookSelectionModal = class extends import_obsidian22.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.selectedBook = null;
    this.books = [];
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u9009\u62E9\u8981\u5BFC\u51FA\u7684\u4E66\u7C4D" });
    await this.loadBooks();
    this.bookListContainer = contentEl.createDiv({ cls: "book-selection-list" });
    this.renderBookList();
    const buttonContainer = contentEl.createDiv({ cls: "book-selection-buttons" });
    new import_obsidian22.ButtonComponent(buttonContainer).setButtonText(i18n.t("CANCEL") || "\u53D6\u6D88").onClick(() => {
      this.close();
    });
    new import_obsidian22.ButtonComponent(buttonContainer).setButtonText("\u5BFC\u51FA\u8BBE\u7F6E").setCta().onClick(() => {
      this.handleExport();
    });
  }
  async loadBooks() {
    try {
      this.books = await this.plugin.bookManager.getAllBooks();
    } catch (error) {
      console.error("\u52A0\u8F7D\u4E66\u7C4D\u5217\u8868\u5931\u8D25:", error);
      new import_obsidian22.Notice("\u52A0\u8F7D\u4E66\u7C4D\u5217\u8868\u5931\u8D25");
      this.books = [];
    }
  }
  renderBookList() {
    this.bookListContainer.empty();
    if (this.books.length === 0) {
      const emptyMessage = this.bookListContainer.createDiv({ cls: "book-selection-empty" });
      emptyMessage.createEl("p", { text: "\u672A\u627E\u5230\u4EFB\u4F55\u4E66\u7C4D" });
      emptyMessage.createEl("p", {
        text: "\u8BF7\u5148\u521B\u5EFA\u4E00\u672C\u4E66\u7C4D\u518D\u8FDB\u884C\u5BFC\u51FA",
        cls: "book-selection-hint"
      });
      return;
    }
    this.books.forEach((book, index) => {
      const bookItem = this.bookListContainer.createDiv({ cls: "book-selection-item" });
      const radioContainer = bookItem.createDiv({ cls: "book-selection-radio" });
      const radio = radioContainer.createEl("input", {
        type: "radio",
        attr: {
          name: "selected-book",
          value: book.basic.uuid
        }
      });
      const bookInfo = bookItem.createDiv({ cls: "book-selection-info" });
      const title = bookInfo.createEl("h3", {
        text: book.basic.title,
        cls: "book-selection-title"
      });
      const details = bookInfo.createDiv({ cls: "book-selection-details" });
      details.createEl("span", {
        text: `${i18n.t("AUTHOR") || "\u4F5C\u8005"}: ${book.basic.author.join(", ")}`,
        cls: "book-selection-author"
      });
      if (book.stats) {
        details.createEl("span", {
          text: `${i18n.t("WORD_COUNT") || "\u5B57\u6570"}: ${book.stats.total_words || 0}`,
          cls: "book-selection-words"
        });
      }
      const createdDate = new Date(book.basic.created_at).toLocaleDateString();
      details.createEl("span", {
        text: `${"\u521B\u5EFA\u65E5\u671F"}: ${createdDate}`,
        cls: "book-selection-date"
      });
      bookItem.addEventListener("click", () => {
        this.bookListContainer.querySelectorAll(".book-selection-item").forEach((item) => {
          item.removeClass("selected");
        });
        this.bookListContainer.querySelectorAll('input[type="radio"]').forEach((input) => {
          input.checked = false;
        });
        bookItem.addClass("selected");
        radio.checked = true;
        this.selectedBook = book;
      });
      if (index === 0) {
        bookItem.addClass("selected");
        radio.checked = true;
        this.selectedBook = book;
      }
    });
  }
  async handleExport() {
    if (!this.selectedBook) {
      new import_obsidian22.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u672C\u4E66\u7C4D");
      return;
    }
    try {
      this.close();
      const bookRenderService = new BookRenderService(this.app);
      const exportModal = new ExportModal(
        this.app,
        this.plugin,
        bookRenderService,
        this.selectedBook
      );
      exportModal.open();
    } catch (error) {
      console.error("\u6253\u5F00\u5BFC\u51FA\u6A21\u6001\u6846\u5931\u8D25:", error);
      new import_obsidian22.Notice("\u6253\u5F00\u5BFC\u51FA\u6A21\u6001\u6846\u5931\u8D25");
    }
  }
  // 移除 addStyles 方法，因为样式已经移到独立的CSS文件中
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/ToolsView.ts
var ToolView = class extends import_obsidian23.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.normalView = null;
    this.focusView = null;
  }
  onload() {
    document.addEventListener("open-donate-modal", () => {
      console.log("Received open-donate-modal event");
      new DonateModal(this.containerEl).open();
    });
  }
  // 视图基础配置
  getViewType() {
    return "book-smith-tool";
  }
  getDisplayText() {
    return i18n.t("WRITING_TOOLBOX");
  }
  getIcon() {
    return "wrench";
  }
  // 生命周期方法
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("book-smith-tools-view");
    this.normalView = container;
    this.createNormalView(container);
  }
  // 视图刷新方法
  refresh() {
    if (this.normalView) {
      this.normalView.empty();
      this.createNormalView(this.normalView);
    }
  }
  // 主视图创建
  createNormalView(container) {
    this.createHeader(container);
    this.createToolGroups(container);
    this.createSettings(container);
  }
  // 头部创建
  createHeader(container) {
    const header = container.createDiv({ cls: "book-smith-panel-header" });
    const titleContainer = header.createDiv({ cls: "book-smith-panel-title" });
    const mainIconSpan = titleContainer.createSpan({ cls: "book-smith-panel-icon" });
    (0, import_obsidian23.setIcon)(mainIconSpan, "archive");
    titleContainer.createSpan({ text: i18n.t("WRITING_TOOLBOX") });
  }
  // 工具组创建
  createToolGroups(container) {
    if (this.plugin.settings.tools.assistant) {
      this.createToolGroup(container, i18n.t("WRITING_ASSISTANT"), [
        {
          icon: "target",
          text: i18n.t("FOCUS_MODE"),
          hasProgress: true,
          onClick: () => this.enterFocusMode()
        },
        {
          icon: "brain",
          text: i18n.t("CREATIVE_INSPIRATION"),
          onClick: () => new InspirationModal(this.containerEl).open()
        },
        {
          icon: "file-text",
          text: i18n.t("CHARACTER_PROFILES"),
          onClick: () => {
            new import_obsidian23.Notice(i18n.t("FEATURE_COMING_SOON", { feature: i18n.t("CHARACTER_PROFILES") }));
          }
        },
        {
          icon: "map",
          text: i18n.t("WORLD_BUILDING"),
          onClick: () => {
            new import_obsidian23.Notice(i18n.t("FEATURE_COMING_SOON", { feature: i18n.t("WORLD_BUILDING") }));
          }
        }
      ]);
    }
    if (this.plugin.settings.tools.export) {
      this.createToolGroup(container, i18n.t("EXPORT_PUBLISH"), [
        {
          icon: "book",
          text: i18n.t("DESIGN_TYPOGRAPHY"),
          onClick: () => this.enterTypographyMode()
        },
        {
          icon: "clock",
          text: i18n.t("MORE_FEATURES"),
          onClick: () => {
            new import_obsidian23.Notice(i18n.t("MORE_FEATURES_MESSAGE"));
          }
        }
      ]);
    }
    if (this.plugin.settings.tools.community) {
      this.createToolGroup(container, i18n.t("WRITING_COMMUNITY"), [
        {
          icon: "users",
          text: i18n.t("CREATIVE_COMMUNITY"),
          extra: "",
          onClick: () => new CommunityModal(this.containerEl).open()
        },
        {
          icon: "message-square",
          text: i18n.t("CONTACT_AUTHOR"),
          onClick: () => new ContactModal(this.containerEl).open()
        },
        {
          icon: "heart",
          text: i18n.t("DONATE_SUPPORT"),
          onClick: () => new DonateModal(this.containerEl).open()
        }
      ]);
    }
  }
  // 工具组创建辅助方法
  createToolGroup(container, title, items) {
    const group = container.createDiv({ cls: "book-smith-tool-group" });
    group.createDiv({ text: title, cls: "book-smith-group-title" });
    items.forEach((item) => {
      const toolItem = this.createToolItem(group, item.icon, item.text);
      if (item.hasProgress) {
        const progressBar = toolItem.createDiv({ cls: "book-smith-progress-bar" });
        progressBar.createDiv({ cls: "book-smith-progress" });
      }
      if (item.extra) {
        toolItem.createSpan({ text: item.extra, cls: "book-smith-tool-item-extra" });
      }
      if (item.onClick) {
        toolItem.addEventListener("click", item.onClick);
      }
    });
  }
  // 单个工具项创建
  createToolItem(container, icon, text) {
    const item = container.createDiv({ cls: "book-smith-tool-item" });
    const iconSpan = item.createSpan({ cls: "book-smith-tool-icon" });
    (0, import_obsidian23.setIcon)(iconSpan, icon);
    item.createSpan({ text });
    return item;
  }
  // 设置面板创建
  createSettings(container) {
    const settingsItem = this.createToolItem(container, "settings", i18n.t("PANEL_SETTINGS"));
    settingsItem.addClass("settings");
    settingsItem.addEventListener("contextmenu", (event) => {
      const menu = new import_obsidian23.Menu();
      this.addToolVisibilityMenuItem(menu, "assistant", "target", i18n.t("WRITING_ASSISTANT"));
      this.addToolVisibilityMenuItem(menu, "export", "download", i18n.t("EXPORT_PUBLISH"));
      menu.showAtMouseEvent(event);
    });
  }
  // 添加工具显隐菜单项
  addToolVisibilityMenuItem(menu, key, icon, text) {
    menu.addItem(
      (item) => item.setTitle(`${this.plugin.settings.tools[key] ? i18n.t("HIDE") : i18n.t("SHOW")}${text}`).setIcon(icon).setChecked(this.plugin.settings.tools[key]).onClick(async () => {
        this.plugin.settings.tools[key] = !this.plugin.settings.tools[key];
        await this.plugin.saveSettings();
        this.refresh();
      })
    );
  }
  // 专注模式相关
  enterFocusMode() {
    if (!this.normalView)
      return;
    this.normalView.empty();
    this.focusView = new FocusToolView(
      this.app,
      this.plugin,
      this.normalView,
      () => {
        var _a;
        (_a = this.focusView) == null ? void 0 : _a.remove();
        this.focusView = null;
        if (this.normalView) {
          this.normalView.empty();
          this.createNormalView(this.normalView);
        }
      }
    );
  }
  // 添加进入排版模式的方法
  enterTypographyMode() {
    new BookSelectionModal(this.app, this.plugin).open();
  }
  // 修改 onClose 方法，确保所有视图都被正确关闭
  async onClose() {
    if (this.focusView) {
      this.focusView.remove();
      this.focusView = null;
    }
  }
};

// src/settings/SettingTab.ts
var import_obsidian26 = require("obsidian");

// src/modals/TemplateEditModal.ts
var import_obsidian24 = require("obsidian");

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  var _a, _b, _c;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    if (offset2 < 0 || offset2 + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset2}:${offset2 + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/modals/TemplateEditModal.ts
var TemplateEditModal = class extends import_obsidian24.Modal {
  constructor(app, plugin, templateKey, onSaved) {
    super(app);
    this.plugin = plugin;
    this.onSaved = onSaved;
    this.templateName = "";
    this.templateDesc = "";
    this.isEdit = !!templateKey;
    this.originalKey = templateKey || "";
    if (this.isEdit) {
      const template = this.plugin.settings.templates.custom[this.originalKey || ""];
      this.templateName = template.name;
      this.templateDesc = template.description;
      this.templateStructure = JSON.parse(JSON.stringify(template.structure));
    } else {
      this.templateStructure = {
        tree: []
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("book-smith-template-modal");
    contentEl.createEl("h2", { text: this.isEdit ? i18n.t("TEMPLATE_EDIT_TITLE") : i18n.t("TEMPLATE_CREATE_TITLE") });
    const formContainer = contentEl.createDiv("book-smith-template-form");
    new import_obsidian24.Setting(formContainer).setName(i18n.t("TEMPLATE_NAME")).addText((text) => text.setPlaceholder(i18n.t("TEMPLATE_NAME_PLACEHOLDER")).setValue(this.templateName).onChange((value) => this.templateName = value));
    new import_obsidian24.Setting(formContainer).setName(i18n.t("TEMPLATE_DESC")).addTextArea((text) => text.setPlaceholder(i18n.t("TEMPLATE_DESC_PLACEHOLDER")).setValue(this.templateDesc).onChange((value) => this.templateDesc = value));
    const structureContainer = contentEl.createDiv("book-smith-template-structure");
    structureContainer.createEl("h3", { text: i18n.t("TEMPLATE_STRUCTURE") });
    new import_obsidian24.Setting(structureContainer).addButton((btn) => btn.setButtonText(i18n.t("ADD_FILE")).onClick(() => {
      const newNode = this.createNewNode("file", i18n.t("NEW_CHAPTER"));
      this.templateStructure.tree.push(newNode);
      this.createNodeSetting(nodeListContainer, newNode, this.templateStructure.tree.length - 1);
    })).addButton((btn) => btn.setButtonText(i18n.t("ADD_FOLDER")).onClick(() => {
      const newNode = this.createNewNode("group", i18n.t("NEW_DIRECTORY"));
      this.templateStructure.tree.push(newNode);
      this.createNodeSetting(nodeListContainer, newNode, this.templateStructure.tree.length - 1);
    }));
    const nodeListContainer = structureContainer.createDiv("book-smith-node-list");
    this.templateStructure.tree.forEach((node, index) => {
      this.createNodeSetting(nodeListContainer, node, index);
    });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    new import_obsidian24.Setting(buttonContainer).addButton((btn) => btn.setButtonText(this.isEdit ? i18n.t("SAVE") : i18n.t("CREATE")).setCta().onClick(async () => {
      const saved = await this.saveTemplate();
      if (saved) {
        this.close();
      }
    })).addButton((btn) => btn.setButtonText(i18n.t("CANCEL")).onClick(() => this.close()));
  }
  createNodeSetting(container, node, index) {
    var _a;
    const nodeDiv = container.createDiv("book-smith-template-node");
    const nodeContent = nodeDiv.createDiv("book-smith-node-content");
    if (node.type === "group") {
      nodeContent.addEventListener("contextmenu", (e) => {
        const menu = new import_obsidian24.Menu();
        menu.addItem((item) => {
          item.setTitle(i18n.t("ADD_FILE")).setIcon("file-plus").onClick(() => {
            const newNode = this.createNewNode("file", i18n.t("NEW_CHAPTER"), node);
            node.children = node.children || [];
            node.children.push(newNode);
            this.refreshStructure(container);
          });
        });
        menu.addItem((item) => {
          item.setTitle(i18n.t("ADD_FOLDER")).setIcon("folder-plus").onClick(() => {
            const newNode = this.createNewNode("group", i18n.t("NEW_DIRECTORY"), node);
            node.children = node.children || [];
            node.children.push(newNode);
            this.refreshStructure(container);
          });
        });
        menu.showAtPosition({ x: e.clientX, y: e.clientY });
        e.preventDefault();
      });
    }
    if (node.type === "group") {
      const toggleBtn = nodeContent.createSpan("book-smith-node-toggle");
      (0, import_obsidian24.setIcon)(toggleBtn, node.is_expanded ? "chevron-down" : "chevron-right");
      toggleBtn.addEventListener("click", () => {
        node.is_expanded = !node.is_expanded;
        this.refreshStructure(container);
      });
    }
    const icon = nodeContent.createSpan("book-smith-node-icon");
    (0, import_obsidian24.setIcon)(icon, node.type === "file" ? "document" : "folder");
    const input = nodeContent.createEl("input", {
      type: "text",
      value: node.title,
      placeholder: "\u8F93\u5165\u540D\u79F0",
      cls: "book-smith-node-input"
    });
    input.addEventListener("change", (e) => {
      const value = e.target.value;
      node.title = value;
      let fullPath = value;
      const parentContainer = container.closest(".book-smith-node-children");
      if (parentContainer) {
        const parentNode = this.findParentNode(this.templateStructure.tree, node.id);
        if (parentNode) {
          fullPath = `${parentNode.path}/${value}`;
        }
      }
      node.path = node.type === "file" ? `${fullPath}.md` : fullPath;
    });
    const deleteBtn = nodeDiv.createSpan("book-smith-node-delete");
    (0, import_obsidian24.setIcon)(deleteBtn, "trash");
    deleteBtn.addEventListener("click", () => {
      var _a2;
      if (node.type === "group" && ((_a2 = node.children) == null ? void 0 : _a2.length)) {
        if (!confirm("\u786E\u5B9A\u8981\u5220\u9664\u6B64\u6587\u4EF6\u5939\u53CA\u5176\u6240\u6709\u5185\u5BB9\u5417\uFF1F")) {
          return;
        }
      }
      const parentContainer = container.closest(".book-smith-node-children");
      if (parentContainer) {
        const parentNode = this.findParentNode(this.templateStructure.tree, node.id);
        if (parentNode && parentNode.children) {
          parentNode.children = parentNode.children.filter((child) => child.id !== node.id);
        }
      } else {
        this.templateStructure.tree = this.templateStructure.tree.filter((n) => n.id !== node.id);
      }
      this.updateNodeOrders();
      this.refreshStructure(container);
    });
    if (node.type === "group") {
      const childrenContainer = container.createDiv({
        cls: `book-smith-node-children ${node.is_expanded ? "is-expanded" : ""}`
      });
      if (((_a = node.children) == null ? void 0 : _a.length) && node.is_expanded) {
        node.children.forEach((child, childIndex) => {
          this.createNodeSetting(childrenContainer, child, childIndex);
        });
      }
    }
  }
  updateNodeOrders() {
    this.templateStructure.tree.forEach((node, index) => {
      node.order = index;
    });
  }
  // 添加创建节点的辅助方法
  getNextNodeNumber(nodes, baseTitle) {
    let maxNum = 0;
    const pattern = new RegExp(`${baseTitle}(\\d+)?$`);
    const checkNode = (node) => {
      if (pattern.test(node.title)) {
        const match = node.title.match(/\d+$/);
        const num = match ? parseInt(match[0]) : 0;
        maxNum = Math.max(maxNum, num);
      }
    };
    nodes.forEach(checkNode);
    return maxNum + 1;
  }
  createNewNode(type, baseTitle, parentNode) {
    const nodes = parentNode ? parentNode.children || [] : this.templateStructure.tree;
    const num = this.getNextNodeNumber(nodes, baseTitle);
    const title = `${baseTitle}${num || ""}`;
    let fullPath = title;
    if (parentNode) {
      fullPath = `${parentNode.path}/${title}`;
    }
    return {
      id: Math.random().toString(36).substring(2, 9),
      title,
      type,
      path: type === "file" ? `${fullPath}.md` : fullPath,
      order: nodes.length,
      default_status: "draft",
      created_at: new Date().toISOString(),
      last_modified: new Date().toISOString(),
      ...type === "group" ? { children: [] } : {}
    };
  }
  refreshStructure(container) {
    var _a;
    const nodeListContainer = (_a = container.closest(".book-smith-template-structure")) == null ? void 0 : _a.querySelector(".book-smith-node-list");
    if (nodeListContainer) {
      nodeListContainer.empty();
      this.templateStructure.tree.forEach((node, index) => {
        this.createNodeSetting(nodeListContainer, node, index);
      });
    }
  }
  // 保存验证和提示
  async saveTemplate() {
    var _a;
    if (!this.templateName.trim()) {
      new import_obsidian24.Notice(i18n.t("TEMPLATE_NAME_REQUIRED"));
      return false;
    }
    if (this.templateStructure.tree.length === 0) {
      new import_obsidian24.Notice(i18n.t("TEMPLATE_NODE_REQUIRED"));
      return false;
    }
    try {
      const key = this.isEdit ? this.originalKey : `${v4_default().slice(0, 8)}`;
      if (!this.isEdit && Object.values(this.plugin.settings.templates.custom).some((t) => t.name === this.templateName)) {
        new import_obsidian24.Notice(i18n.t("TEMPLATE_NAME_EXISTS"));
        return false;
      }
      this.plugin.settings.templates.custom[key] = {
        name: this.templateName,
        description: this.templateDesc,
        structure: this.templateStructure,
        isBuiltin: false
      };
      await this.plugin.saveSettings();
      new import_obsidian24.Notice(i18n.t("TEMPLATE_SAVE_SUCCESS"));
      (_a = this.onSaved) == null ? void 0 : _a.call(this);
      return true;
    } catch (error) {
      console.error("\u4FDD\u5B58\u6A21\u677F\u5931\u8D25:", error);
      new import_obsidian24.Notice(i18n.t("TEMPLATE_SAVE_FAILED"));
      return false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  // 添加查找父节点的辅助方法
  findParentNode(nodes, targetId) {
    var _a, _b;
    for (const node of nodes) {
      if ((_a = node.children) == null ? void 0 : _a.some((child) => child.id === targetId)) {
        return node;
      }
      if ((_b = node.children) == null ? void 0 : _b.length) {
        const found = this.findParentNode(node.children, targetId);
        if (found)
          return found;
      }
    }
    return null;
  }
};

// src/settings/suggest.ts
var import_obsidian25 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/settings/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian25.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            void instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/settings/GenericTextSuggester.ts
var GenericTextSuggester = class extends TextInputSuggest {
  constructor(app, inputEl, items, maxSuggestions = Infinity) {
    super(app, inputEl);
    this.app = app;
    this.inputEl = inputEl;
    this.items = items;
    this.maxSuggestions = maxSuggestions;
  }
  getSuggestions(inputStr) {
    if (!inputStr)
      return this.items.slice(0, this.maxSuggestions);
    const inputLowerCase = inputStr.toLowerCase();
    return this.items.filter((item) => item.toLowerCase().contains(inputLowerCase)).slice(0, this.maxSuggestions);
  }
  selectSuggestion(item, event) {
    this.inputEl.value = item;
    this.inputEl.trigger("input");
    this.close();
  }
  renderSuggestion(value, el) {
    el.setText(value || "");
  }
};

// src/settings/SettingTab.ts
var BookSmithSettingTab = class extends import_obsidian26.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.expandedSections = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  createSection(containerEl, title, renderContent) {
    const section = containerEl.createDiv("settings-section");
    const header = section.createDiv("settings-section-header");
    const toggle = header.createSpan("settings-section-toggle");
    (0, import_obsidian26.setIcon)(toggle, "chevron-right");
    header.createEl("h4", { text: title });
    const content = section.createDiv("settings-section-content");
    renderContent(content);
    header.addEventListener("click", () => {
      const isExpanded = !section.hasClass("is-expanded");
      section.toggleClass("is-expanded", isExpanded);
      (0, import_obsidian26.setIcon)(toggle, isExpanded ? "chevron-down" : "chevron-right");
      if (isExpanded) {
        this.expandedSections.add(title);
      } else {
        this.expandedSections.delete(title);
      }
    });
    if (this.expandedSections.has(title) || !containerEl.querySelector(".settings-section")) {
      section.addClass("is-expanded");
      (0, import_obsidian26.setIcon)(toggle, "chevron-down");
      this.expandedSections.add(title);
    }
    return section;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("book-smith-settings");
    containerEl.createEl("h2", { text: i18n.t("PLUGIN_NAME") });
    this.createSection(containerEl, i18n.t("BASIC_OPTIONS"), (el) => this.renderBasicSettings(el));
    this.createSection(containerEl, i18n.t("TEMPLATE_OPTIONS"), (el) => this.renderTemplateSettings(el));
    this.createSection(containerEl, i18n.t("WRITING_TOOLS_OPTIONS"), (el) => this.renderWritingToolsSettings(el));
  }
  renderBasicSettings(containerEl) {
    new import_obsidian26.Setting(containerEl).setName(i18n.t("DEFAULT_AUTHOR")).setDesc(i18n.t("DEFAULT_AUTHOR_DESC")).addText((text) => text.setPlaceholder(i18n.t("DEFAULT_AUTHOR_PLACEHOLDER")).setValue(this.plugin.settings.defaultAuthor).onChange(async (value) => {
      this.plugin.settings.defaultAuthor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian26.Setting(containerEl).setName(i18n.t("BOOK_STORAGE_PATH")).setDesc(i18n.t("BOOK_STORAGE_DESC")).addText((text) => {
      text.setPlaceholder("books").setValue(this.plugin.settings.defaultBookPath).onChange(async (value) => {
        this.plugin.settings.defaultBookPath = value;
        await this.plugin.saveSettings();
      });
      new GenericTextSuggester(
        this.app,
        text.inputEl,
        this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian26.TFolder && f.path !== "/").map((f) => f.path)
      );
    });
  }
  renderTemplateSettings(containerEl) {
    new import_obsidian26.Setting(containerEl).setName(i18n.t("DEFAULT_TEMPLATE")).setDesc(i18n.t("DEFAULT_TEMPLATE_DESC")).addDropdown((dropdown) => {
      const templates = this.plugin.settings.templates.custom;
      Object.keys(templates).forEach((key) => {
        dropdown.addOption(key, templates[key].name);
      });
      dropdown.setValue(this.plugin.settings.templates.default).onChange(async (value) => {
        this.plugin.settings.templates.default = value;
        await this.plugin.saveSettings();
      });
    });
    const templateList = containerEl.createDiv("template-list");
    templateList.createEl("h4", { text: i18n.t("BOOK_TEMPLATES") });
    Object.entries(this.plugin.settings.templates.custom).filter(([key]) => key !== "default").forEach(([key, template]) => {
      const templateDiv = templateList.createDiv("template-item");
      new import_obsidian26.Setting(templateDiv).setName(template.name).setDesc(template.description).addButton((btn) => btn.setIcon("pencil").setTooltip(i18n.t("EDIT_TEMPLATE")).onClick(() => {
        new TemplateEditModal(this.app, this.plugin, key, () => this.display()).open();
      })).addButton((btn) => btn.setIcon("trash").setTooltip(i18n.t("DELETE_TEMPLATE")).onClick(() => {
        new ConfirmModal(
          this.app,
          i18n.t("DELETE_TEMPLATE"),
          i18n.t("DELETE_TEMPLATE_DESC"),
          async () => {
            if (key === this.plugin.settings.templates.default) {
              this.plugin.settings.templates.default = "default";
            }
            delete this.plugin.settings.templates.custom[key];
            await this.plugin.saveSettings();
            this.display();
          }
        ).open();
      }));
    });
    new import_obsidian26.Setting(containerEl).addButton((btn) => btn.setButtonText(i18n.t("ADD_NEW_TEMPLATE")).setCta().onClick(() => {
      new TemplateEditModal(
        this.app,
        this.plugin,
        void 0,
        () => this.display()
      ).open();
    }));
  }
  renderWritingToolsSettings(containerEl) {
    const focusSection = containerEl.createDiv();
    focusSection.createEl("h4", { text: i18n.t("FOCUS_MODE_OPTIONS") });
    new import_obsidian26.Setting(focusSection).setName(i18n.t("FOCUS_DURATION")).setDesc(i18n.t("FOCUS_DURATION_DESC")).addText((text) => text.setPlaceholder("25").setValue(this.plugin.settings.focus.workDuration.toString()).onChange(async (value) => {
      this.plugin.settings.focus.workDuration = Number(value) || 25;
      await this.plugin.saveSettings();
    }));
    new import_obsidian26.Setting(focusSection).setName(i18n.t("BREAK_DURATION")).setDesc(i18n.t("BREAK_DURATION_DESC")).addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.focus.breakDuration.toString()).onChange(async (value) => {
      this.plugin.settings.focus.breakDuration = Number(value) || 5;
      await this.plugin.saveSettings();
    }));
    new import_obsidian26.Setting(focusSection).setName(i18n.t("WORD_GOAL")).setDesc(i18n.t("WORD_GOAL_DESC")).addText((text) => text.setPlaceholder("500").setValue(this.plugin.settings.focus.wordGoal.toString()).onChange(async (value) => {
      this.plugin.settings.focus.wordGoal = Number(value) || 500;
      await this.plugin.saveSettings();
    }));
  }
};

// src/templates/default.ts
var defaultTemplate = {
  tree: [
    {
      id: "preface",
      title: "\u524D\u8A00",
      type: "file",
      path: "\u524D\u8A00.md",
      order: 0,
      default_status: "draft",
      created_at: new Date().toISOString(),
      last_modified: new Date().toISOString()
    },
    {
      id: "outline",
      title: "\u5927\u7EB2",
      type: "file",
      path: "\u5927\u7EB2.md",
      order: 1,
      default_status: "draft",
      created_at: new Date().toISOString(),
      last_modified: new Date().toISOString()
    },
    {
      id: "volume1",
      title: "\u7B2C\u4E00\u5377",
      type: "group",
      path: "\u7B2C\u4E00\u5377",
      order: 2,
      default_status: "draft",
      is_expanded: true,
      // 默认展开第一卷
      created_at: new Date().toISOString(),
      last_modified: new Date().toISOString(),
      children: [
        {
          id: "chapter1",
          title: "\u7B2C\u4E00\u7AE0",
          type: "file",
          path: "\u7B2C\u4E00\u5377/\u7B2C\u4E00\u7AE0.md",
          order: 0,
          default_status: "draft",
          created_at: new Date().toISOString(),
          last_modified: new Date().toISOString()
        },
        {
          id: "chapter2",
          title: "\u7B2C\u4E8C\u7AE0",
          type: "file",
          path: "\u7B2C\u4E00\u5377/\u7B2C\u4E8C\u7AE0.md",
          order: 1,
          default_status: "draft",
          created_at: new Date().toISOString(),
          last_modified: new Date().toISOString()
        }
      ]
    },
    {
      id: "afterword",
      title: "\u540E\u8BB0",
      type: "file",
      path: "\u540E\u8BB0.md",
      order: 3,
      default_status: "draft",
      created_at: new Date().toISOString(),
      last_modified: new Date().toISOString()
    }
  ]
};

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  defaultAuthor: "Yeban",
  defaultBookPath: "books",
  lastBookId: "",
  templates: {
    default: "default",
    // 修改为使用 standard 作为默认模板
    custom: {
      "default": {
        name: "default",
        description: "\u5305\u542B\u524D\u8A00\u3001\u5927\u7EB2\u3001\u6B63\u6587\u5377\u7AE0\u548C\u540E\u8BB0\u7684\u6807\u51C6\u7ED3\u6784",
        structure: defaultTemplate,
        isBuiltin: true
      }
    }
  },
  tools: {
    assistant: true,
    export: true,
    community: true
  },
  focus: {
    workDuration: 25,
    breakDuration: 5,
    wordGoal: 500,
    stats: { dailyStats: {} }
  }
};

// src/utils/viewUtils.ts
async function activateView(app, viewType, direction) {
  const { workspace } = app;
  let leaf = null;
  const leaves = workspace.getLeavesOfType(viewType);
  if (leaves.length > 0) {
    leaf = leaves[0];
  } else {
    leaf = direction === "left" ? workspace.getLeftLeaf(false) : workspace.getRightLeaf(false);
  }
  if (leaf) {
    await leaf.setViewState({
      type: viewType,
      active: true
    });
    workspace.revealLeaf(leaf);
  }
}

// src/services/BookManager.ts
var import_obsidian27 = require("obsidian");
var BookManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.templateManager = new TemplateManager(settings);
    this.rootPath = this.settings.defaultBookPath;
  }
  async createBook(basicInfo, templateType = "default", targetTotalWords = 0) {
    let bookFolder = null;
    try {
      await this.ensureDirectoryStructure(basicInfo);
      const book = {
        basic: {
          ...basicInfo,
          uuid: v4_default(),
          created_at: new Date().toISOString()
        },
        structure: await this.getTemplateStructure(templateType),
        stats: {
          total_words: 0,
          target_total_words: targetTotalWords,
          progress_by_words: 0,
          progress_by_chapter: 0,
          daily_words: {},
          writing_days: 0,
          average_daily_words: 0,
          last_writing_date: new Date().toISOString(),
          last_modified: new Date().toISOString()
        },
        export: {
          default_format: "pdf",
          template: "default",
          include_cover: true
        }
      };
      const bookFolderPath = `${this.settings.defaultBookPath}/${basicInfo.title}`;
      bookFolder = await this.app.vault.createFolder(bookFolderPath);
      await this.saveBookConfig(bookFolder, book);
      await this.createInitialStructure(bookFolder, book.structure);
      return book;
    } catch (error) {
      if (bookFolder) {
        await this.app.fileManager.trashFile(bookFolder);
      }
      throw error;
    }
  }
  // 确保目录结构存在
  async ensureDirectoryStructure(basicInfo) {
    const existingFolder = this.app.vault.getAbstractFileByPath(
      `${this.rootPath}/${basicInfo.title}`
    );
    if (existingFolder) {
      throw new Error(i18n.t("BOOK_EXISTS"));
    }
    const rootFolder = this.app.vault.getAbstractFileByPath(this.rootPath);
    if (!rootFolder) {
      await this.app.vault.createFolder(this.rootPath);
    }
    if (basicInfo.cover) {
      const coversPath = `${this.rootPath}/covers`;
      const coversFolder = this.app.vault.getAbstractFileByPath(coversPath);
      if (!coversFolder) {
        await this.app.vault.createFolder(coversPath);
      }
    }
  }
  async getAllBooks() {
    const books = [];
    const rootFolder = this.app.vault.getAbstractFileByPath(this.rootPath);
    if (rootFolder instanceof import_obsidian27.TFolder) {
      for (const folder of rootFolder.children) {
        if (folder instanceof import_obsidian27.TFolder) {
          const configPath = `${folder.path}/book-config.json`;
          const configFile = this.app.vault.getAbstractFileByPath(configPath);
          if (configFile) {
            const config = await this.getBookConfig(folder);
            if (config) {
              books.push(config);
            }
          }
        }
      }
    }
    return books.sort(
      (a, b) => new Date(b.basic.created_at).getTime() - new Date(a.basic.created_at).getTime()
    );
  }
  async getBookById(uuid) {
    const books = await this.getAllBooks();
    return books.find((book) => book.basic.uuid === uuid) || null;
  }
  async updateBook(uuid, updates) {
    var _a;
    const book = await this.getBookById(uuid);
    if (!book) {
      throw new Error(i18n.t("BOOK_NOT_FOUND"));
    }
    const oldBookPath = `${this.settings.defaultBookPath}/${book.basic.title}`;
    const folder = this.app.vault.getAbstractFileByPath(oldBookPath);
    if (!(folder instanceof import_obsidian27.TFolder)) {
      throw new Error(i18n.t("BOOK_FOLDER_NOT_FOUND"));
    }
    const updatedBook = {
      ...book,
      ...updates,
      basic: {
        ...book.basic,
        ...updates.basic
      },
      structure: {
        ...book.structure,
        ...updates.structure
      },
      stats: {
        ...book.stats,
        ...updates.stats
      },
      export: {
        ...book.export,
        ...updates.export
      }
    };
    if (((_a = updates.basic) == null ? void 0 : _a.title) && updates.basic.title !== book.basic.title) {
      const newBookPath = `${this.settings.defaultBookPath}/${updates.basic.title}`;
      if (this.app.vault.getAbstractFileByPath(newBookPath)) {
        throw new Error(i18n.t("BOOK_EXISTS"));
      }
      await this.app.vault.rename(folder, newBookPath);
    }
    await this.saveBookConfig(folder, updatedBook);
    return updatedBook;
  }
  async deleteBook(uuid) {
    const book = await this.getBookById(uuid);
    if (!book) {
      throw new Error(i18n.t("BOOK_NOT_FOUND"));
    }
    const bookPath = `${this.settings.defaultBookPath}/${book.basic.title}`;
    const folder = this.app.vault.getAbstractFileByPath(bookPath);
    if (folder) {
      await this.app.vault.trash(folder, true);
    } else {
      throw new Error(i18n.t("BOOK_FOLDER_NOT_FOUND"));
    }
  }
  async getBookConfig(folder) {
    try {
      const configPath = `${folder.path}/book-config.json`;
      const configFile = this.app.vault.getAbstractFileByPath(configPath);
      if (configFile instanceof import_obsidian27.TFile) {
        const content = await this.app.vault.read(configFile);
        return JSON.parse(content);
      }
      return null;
    } catch (error) {
      console.error("\u83B7\u53D6\u4E66\u7C4D\u914D\u7F6E\u65F6\u53D1\u751F\u9519\u8BEF:", error);
      return null;
    }
  }
  async saveBookConfig(folder, book) {
    const configPath = `${folder.path}/book-config.json`;
    try {
      const configFile = this.app.vault.getAbstractFileByPath(configPath);
      const jsonContent = JSON.stringify(book, null, 2);
      if (configFile instanceof import_obsidian27.TFile) {
        await this.app.vault.modify(configFile, jsonContent);
      } else {
        await this.app.vault.create(configPath, jsonContent);
      }
    } catch (error) {
      console.error("\u4FDD\u5B58\u914D\u7F6E\u6587\u4EF6\u65F6\u53D1\u751F\u9519\u8BEF:", error);
      throw new Error(i18n.t("SAVE_CONFIG_FAILED"));
    }
  }
  async getTemplateStructure(templateType) {
    const template = this.templateManager.getTemplate(templateType);
    if (templateType === "default") {
      const localizedTemplate = JSON.parse(JSON.stringify(template));
      const updateNodeTitles = (nodes) => {
        for (const node of nodes) {
          if (node.id === "preface") {
            node.title = i18n.t("PREFACE");
            node.path = `${i18n.t("PREFACE")}.md`;
          } else if (node.id === "outline") {
            node.title = i18n.t("OUTLINE");
            node.path = `${i18n.t("OUTLINE")}.md`;
          } else if (node.id === "volume1") {
            node.title = i18n.t("VOLUME_1");
            node.path = i18n.t("VOLUME_1");
          } else if (node.id === "chapter1") {
            node.title = i18n.t("CHAPTER_1");
            node.path = `${i18n.t("VOLUME_1")}/${i18n.t("CHAPTER_1")}.md`;
          } else if (node.id === "chapter2") {
            node.title = i18n.t("CHAPTER_2");
            node.path = `${i18n.t("VOLUME_1")}/${i18n.t("CHAPTER_2")}.md`;
          } else if (node.id === "afterword") {
            node.title = i18n.t("AFTERWORD");
            node.path = `${i18n.t("AFTERWORD")}.md`;
          }
          if (node.children) {
            updateNodeTitles(node.children);
          }
        }
      };
      updateNodeTitles(localizedTemplate.tree);
      return localizedTemplate;
    }
    return template;
  }
  async createInitialStructure(folder, structure) {
    const createNode = async (node) => {
      if (node.type === "file") {
        const filePath = `${folder.path}/${node.path}`;
        const parentPath = filePath.substring(0, filePath.lastIndexOf("/"));
        const parentFolder = this.app.vault.getAbstractFileByPath(parentPath);
        if (!parentFolder) {
          await this.app.vault.createFolder(parentPath);
        }
        await this.app.vault.create(filePath, "");
      } else if (node.type === "group" && node.children) {
        const groupPath = `${folder.path}/${node.path}`;
        await this.app.vault.createFolder(groupPath);
        for (const child of node.children) {
          await createNode(child);
        }
      }
    };
    for (const node of structure.tree) {
      await createNode(node);
    }
  }
  // 在 BookManager 类中添加这个方法
  async importBookFromFolder(folderName) {
    try {
      const folderPath = `${this.settings.defaultBookPath}/${folderName}`;
      const structure = await this.buildFolderStructure(folderPath, "");
      const newBook = {
        basic: {
          uuid: v4_default(),
          title: folderName,
          author: this.settings.defaultAuthor ? [this.settings.defaultAuthor] : [i18n.t("UNKNOWN_AUTHOR")],
          created_at: new Date().toISOString()
        },
        structure: {
          tree: structure
        },
        stats: {
          total_words: 0,
          target_total_words: 1e5,
          progress_by_words: 0,
          progress_by_chapter: 0,
          daily_words: {},
          writing_days: 0,
          average_daily_words: 0,
          last_writing_date: new Date().toISOString(),
          last_modified: new Date().toISOString()
        },
        export: {
          default_format: "pdf",
          template: "default",
          include_cover: true
        }
      };
      const bookFolder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(bookFolder instanceof import_obsidian27.TFolder)) {
        throw new Error(i18n.t("BOOK_FOLDER_NOT_FOUND"));
      }
      await this.saveBookConfig(bookFolder, newBook);
      return newBook;
    } catch (error) {
      console.error("\u5BFC\u5165\u4E66\u7C4D\u5931\u8D25:", error);
      throw new Error(i18n.t("IMPORT_BOOK_FAILED"));
    }
  }
  // 构建文件夹结构的辅助方法
  async buildFolderStructure(folderPath, parentPath = "") {
    const structure = [];
    let order2 = 0;
    const folderContents = await this.app.vault.adapter.list(folderPath);
    for (const filePath of folderContents.files) {
      if (!filePath.endsWith(".md"))
        continue;
      const fileName = filePath.split("/").pop() || "";
      if (fileName.startsWith("."))
        continue;
      const title = fileName.replace(".md", "");
      const relativePath = parentPath ? `${parentPath}/${fileName}` : fileName;
      structure.push({
        id: v4_default(),
        title,
        type: "file",
        path: relativePath,
        order: order2++,
        default_status: "draft",
        created_at: new Date().toISOString(),
        last_modified: new Date().toISOString()
      });
    }
    for (const subFolderPath of folderContents.folders) {
      const folderName = subFolderPath.split("/").pop() || "";
      if (folderName.startsWith(".") || folderName === "__MACOSX" || folderName === "node_modules")
        continue;
      const relativePath = parentPath ? `${parentPath}/${folderName}` : folderName;
      const children = await this.buildFolderStructure(
        subFolderPath,
        relativePath
      );
      structure.push({
        id: v4_default(),
        title: folderName,
        type: "group",
        path: relativePath,
        order: order2++,
        default_status: "draft",
        created_at: new Date().toISOString(),
        last_modified: new Date().toISOString(),
        children,
        is_expanded: true
      });
    }
    return structure;
  }
};

// src/services/BookStatsManager.ts
var import_obsidian28 = require("obsidian");
var BookStatsManager = class {
  constructor(app, plugin, bookManager) {
    this.app = app;
    this.plugin = plugin;
    this.bookManager = bookManager;
    this.currentBook = null;
    this.statsChangeCallbacks = /* @__PURE__ */ new Set();
  }
  // 统计更新入口
  async updateStatsForFile() {
    if (!this.currentBook)
      return;
    const totalWordCount = await this.calculateTotalWordCount(this.currentBook.structure.tree);
    const stats = await this.updateStats(this.currentBook.stats, totalWordCount);
    this.currentBook.stats = stats;
    await this.bookManager.updateBook(this.currentBook.basic.uuid, this.currentBook);
    this.notifyStatsChange();
  }
  async calculateTotalWordCount(nodes) {
    var _a;
    let totalCount = 0;
    for (const node of nodes) {
      if (node.exclude)
        continue;
      if (node.type === "file") {
        const fullPath = `${this.plugin.settings.defaultBookPath}/${(_a = this.currentBook) == null ? void 0 : _a.basic.title}/${node.path}`;
        const abstractFile = this.app.vault.getAbstractFileByPath(fullPath);
        if (abstractFile instanceof import_obsidian28.TFile) {
          const content = await this.app.vault.read(abstractFile);
          totalCount += this.calculateWordCount(content);
        }
      } else if (node.children) {
        totalCount += await this.calculateTotalWordCount(node.children);
      }
    }
    return totalCount;
  }
  // 添加监听器
  onStatsChange(callback) {
    this.statsChangeCallbacks.add(callback);
    return () => this.statsChangeCallbacks.delete(callback);
  }
  notifyStatsChange() {
    this.statsChangeCallbacks.forEach((callback) => callback());
  }
  calculateWordCount(content) {
    const plainText = content.replace(/[#*`~\[\](){}|_]/g, "").replace(/[^\u4e00-\u9fa5\u3040-\u30ff\u3400-\u4dbf\uAC00-\uD7AF\u1100-\u11FF\u0600-\u06FF\u0590-\u05FF\u0900-\u097F\u0980-\u09FF\u0E00-\u0E7F\u0400-\u04FF\u0500-\u052FЁёa-zA-Z0-9\u00C0-\u00FF\u0100-\u017F\u0180-\u024F\s]/g, " ");
    const cjkWords = (plainText.match(/[\u4e00-\u9fa5\u3400-\u4dbf\uAC00-\uD7AF]/g) || []).length;
    const jpKoWords = (plainText.match(/[\u3040-\u30ff\u1100-\u11FF]/g) || []).length;
    const otherWords = plainText.split(/\s+/).filter((word) => /[a-zA-Z0-9\u00C0-\u00FF\u0100-\u017F\u0180-\u024F\u0400-\u04FF\u0500-\u052FЁё\u0600-\u06FF\u0590-\u05FF\u0900-\u097F\u0980-\u09FF\u0E00-\u0E7F]+/.test(word)).length;
    return cjkWords + jpKoWords + otherWords;
  }
  async updateStats(stats, totalWordCount) {
    const now = new Date();
    const today = now.toISOString().split("T")[0];
    const todayDelta = totalWordCount - stats.total_words;
    const dailyWords = { ...stats.daily_words };
    if (todayDelta !== 0) {
      dailyWords[today] = (dailyWords[today] || 0) + todayDelta;
    }
    const effectiveDays = Object.values(dailyWords).filter((count) => count > 0).length;
    const averageDailyWords = effectiveDays > 0 ? Math.round(totalWordCount / effectiveDays) : 0;
    const progressByWords = stats.target_total_words > 0 ? totalWordCount / stats.target_total_words : 0;
    return {
      ...stats,
      total_words: totalWordCount,
      progress_by_words: progressByWords,
      daily_words: dailyWords,
      writing_days: effectiveDays,
      average_daily_words: averageDailyWords,
      last_writing_date: now.toISOString(),
      last_modified: now.toISOString()
    };
  }
  // 设置当前书籍
  setCurrentBook(book) {
    this.currentBook = book;
  }
  // 重置统计信息
  resetStats(targetWords = 0) {
    const now = new Date().toISOString();
    return {
      total_words: 0,
      target_total_words: targetWords,
      progress_by_words: 0,
      progress_by_chapter: 0,
      daily_words: {},
      writing_days: 0,
      average_daily_words: 0,
      last_writing_date: now,
      last_modified: now
    };
  }
};

// src/services/ImgTemplateManager.ts
var ImgTemplateManager = class {
  constructor(app, themeManager) {
    this.app = app;
    this.themeManager = themeManager;
    this.templates = [];
    this.currentTemplate = null;
    this.initializeTemplates();
  }
  initializeTemplates() {
    this.registerTemplate(new DefaultTemplate());
    this.registerTemplate(new NotesTemplate());
    this.registerTemplate(new BookTemplate());
    this.registerTemplate(new MagazineTemplate());
  }
  registerTemplate(template) {
    this.templates.push(template);
  }
  getVisibleTemplates() {
    return this.templates;
  }
  getTemplate(id) {
    return this.templates.find((t) => t.id === id) || null;
  }
  setCurrentTemplate(id) {
    const template = this.templates.find((t) => t.id === id);
    if (template) {
      this.currentTemplate = template;
    }
  }
  applyTemplate(element, settings) {
    if (!this.currentTemplate) {
      this.currentTemplate = this.templates[0];
    }
    if (this.currentTemplate) {
      this.currentTemplate.render(element, settings);
      if (this.themeManager) {
        this.themeManager.applyTheme(element);
      }
    }
  }
};
var DefaultTemplate = class {
  constructor() {
    this.id = "default";
    this.name = "\u9ED8\u8BA4\u6A21\u677F";
    this.sections = {
      cover: true,
      header: true,
      content: true,
      footer: true
    };
  }
  render(element, settings) {
    element.classList.add("template-default");
    const contentPages = element.querySelector(".typography-content-pages");
    if (contentPages) {
      contentPages.classList.add("default-content-layout");
    }
    const pages = element.querySelectorAll(".page");
    pages.forEach((page) => {
      page.classList.add("default-page-layout");
    });
  }
};
var NotesTemplate = class {
  constructor() {
    this.id = "notes";
    this.name = "\u5907\u5FD8\u5F55";
    this.sections = {
      cover: false,
      header: true,
      content: true,
      footer: false
    };
  }
  render(element, settings) {
    element.classList.add("template-notes");
    const pages = element.querySelectorAll(".page");
    pages.forEach((page, index) => {
      const header = document.createElement("div");
      header.className = "notes-header";
      header.innerHTML = `<div class="notes-title">\u5907\u5FD8\u5F55</div><div class="notes-date">${new Date().toLocaleDateString()}</div>`;
      if (page.firstChild) {
        page.insertBefore(header, page.firstChild);
      } else {
        page.appendChild(header);
      }
      page.classList.add("notes-page-style");
    });
  }
};
var BookTemplate = class {
  constructor() {
    this.id = "book";
    this.name = "\u4E66\u7C4D";
    this.sections = {
      cover: true,
      header: false,
      content: true,
      footer: true
    };
  }
  render(element, settings) {
    element.classList.add("template-book");
    const pages = element.querySelectorAll(".page");
    pages.forEach((page, index) => {
      page.classList.add("book-page-style");
      const footer = document.createElement("div");
      footer.className = "book-footer";
      footer.innerHTML = `<div class="book-page-number">${index + 1}</div>`;
      page.appendChild(footer);
    });
    const coverPage = element.querySelector(".page:first-child");
    if (coverPage) {
      coverPage.classList.add("book-cover");
    }
  }
};
var MagazineTemplate = class {
  constructor() {
    this.id = "magazine";
    this.name = "\u6742\u5FD7";
    this.sections = {
      cover: true,
      header: true,
      content: true,
      footer: true
    };
  }
  render(element, settings) {
    element.classList.add("template-magazine");
    const pages = element.querySelectorAll(".page");
    pages.forEach((page, index) => {
      page.classList.add("magazine-page-style");
      const header = document.createElement("div");
      header.className = "magazine-header";
      header.innerHTML = `<div class="magazine-section">\u4E13\u9898</div>`;
      if (page.firstChild) {
        page.insertBefore(header, page.firstChild);
      } else {
        page.appendChild(header);
      }
      const footer = document.createElement("div");
      footer.className = "magazine-footer";
      footer.innerHTML = `<div class="magazine-page-number">${index + 1}</div>`;
      page.appendChild(footer);
    });
    const coverPage = element.querySelector(".page:first-child");
    if (coverPage) {
      coverPage.classList.add("magazine-cover");
    }
  }
};

// src/services/ThemeManager.ts
var ThemeManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.themes = /* @__PURE__ */ new Map();
    this.currentThemeId = "default";
    this.currentFontSize = 16;
    this.registerTheme(this.createDefaultTheme());
    this.registerTheme(this.createLightTheme());
    this.registerTheme(this.createDarkTheme());
  }
  createDefaultTheme() {
    return {
      id: "default",
      name: "\u9ED8\u8BA4\u4E3B\u9898",
      description: "\u7CFB\u7EDF\u9ED8\u8BA4\u4E3B\u9898",
      isBuiltin: true,
      isVisible: true,
      styles: {
        container: 'background-color: white; color: #333; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;',
        title: {
          h1: "font-size: 2em; margin-bottom: 0.5em; color: #222;",
          h2: "font-size: 1.5em; margin-bottom: 0.5em; color: #333;",
          h3: "font-size: 1.2em; margin-bottom: 0.5em; color: #444;"
        },
        paragraph: "margin-bottom: 1em; line-height: 1.6;",
        quote: "border-left: 4px solid #ddd; padding-left: 1em; color: #666; font-style: italic;",
        list: {
          ul: "list-style-type: disc; padding-left: 2em; margin-bottom: 1em;",
          ol: "list-style-type: decimal; padding-left: 2em; margin-bottom: 1em;",
          li: "margin-bottom: 0.5em;"
        },
        emphasis: {
          strong: "font-weight: bold;",
          em: "font-style: italic;",
          del: "text-decoration: line-through;"
        },
        code: {
          block: "background-color: #f5f5f5; padding: 1em; border-radius: 4px; font-family: monospace; overflow-x: auto;",
          inline: "background-color: #f5f5f5; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace;"
        },
        table: {
          container: "width: 100%; border-collapse: collapse; margin-bottom: 1em;",
          header: "background-color: #f5f5f5; font-weight: bold; text-align: left; padding: 0.5em;",
          cell: "border: 1px solid #ddd; padding: 0.5em;"
        },
        hr: "border: 0; border-top: 1px solid #ddd; margin: 1em 0;",
        image: "max-width: 100%; height: auto;",
        link: "color: #0366d6; text-decoration: none;"
      }
    };
  }
  createLightTheme() {
    return {
      id: "light",
      name: "\u6D45\u8272\u4E3B\u9898",
      description: "\u660E\u4EAE\u6E05\u65B0\u7684\u6D45\u8272\u4E3B\u9898",
      isBuiltin: true,
      isVisible: true,
      styles: {
        container: 'background-color: #f9f9f9; color: #333; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;',
        title: {
          h1: "font-size: 2em; margin-bottom: 0.5em; color: #222; border-bottom: 1px solid #eee; padding-bottom: 0.3em;",
          h2: "font-size: 1.5em; margin-bottom: 0.5em; color: #333; border-bottom: 1px solid #eee; padding-bottom: 0.2em;",
          h3: "font-size: 1.2em; margin-bottom: 0.5em; color: #444;"
        },
        paragraph: "margin-bottom: 1em; line-height: 1.6; color: #444;",
        quote: "border-left: 4px solid #ddd; padding-left: 1em; color: #666; font-style: italic; background-color: #f5f5f5;",
        list: {
          ul: "list-style-type: disc; padding-left: 2em; margin-bottom: 1em;",
          ol: "list-style-type: decimal; padding-left: 2em; margin-bottom: 1em;",
          li: "margin-bottom: 0.5em;"
        },
        emphasis: {
          strong: "font-weight: bold; color: #222;",
          em: "font-style: italic; color: #444;",
          del: "text-decoration: line-through; color: #999;"
        },
        code: {
          block: "background-color: #f0f0f0; padding: 1em; border-radius: 4px; font-family: monospace; overflow-x: auto; border: 1px solid #ddd;",
          inline: "background-color: #f0f0f0; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; border: 1px solid #ddd;"
        },
        table: {
          container: "width: 100%; border-collapse: collapse; margin-bottom: 1em;",
          header: "background-color: #f0f0f0; font-weight: bold; text-align: left; padding: 0.5em; border: 1px solid #ddd;",
          cell: "border: 1px solid #ddd; padding: 0.5em;"
        },
        hr: "border: 0; border-top: 1px solid #ddd; margin: 1em 0;",
        image: "max-width: 100%; height: auto; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);",
        link: "color: #0366d6; text-decoration: none;"
      }
    };
  }
  createDarkTheme() {
    return {
      id: "dark",
      name: "\u6DF1\u8272\u4E3B\u9898",
      description: "\u62A4\u773C\u8212\u9002\u7684\u6DF1\u8272\u4E3B\u9898",
      isBuiltin: true,
      isVisible: true,
      styles: {
        container: 'background-color: #222; color: #eee; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;',
        title: {
          h1: "font-size: 2em; margin-bottom: 0.5em; color: #fff; border-bottom: 1px solid #444; padding-bottom: 0.3em;",
          h2: "font-size: 1.5em; margin-bottom: 0.5em; color: #ddd; border-bottom: 1px solid #444; padding-bottom: 0.2em;",
          h3: "font-size: 1.2em; margin-bottom: 0.5em; color: #ccc;"
        },
        paragraph: "margin-bottom: 1em; line-height: 1.6; color: #bbb;",
        quote: "border-left: 4px solid #444; padding-left: 1em; color: #999; font-style: italic; background-color: #333;",
        list: {
          ul: "list-style-type: disc; padding-left: 2em; margin-bottom: 1em;",
          ol: "list-style-type: decimal; padding-left: 2em; margin-bottom: 1em;",
          li: "margin-bottom: 0.5em;"
        },
        emphasis: {
          strong: "font-weight: bold; color: #fff;",
          em: "font-style: italic; color: #ddd;",
          del: "text-decoration: line-through; color: #666;"
        },
        code: {
          block: "background-color: #333; padding: 1em; border-radius: 4px; font-family: monospace; overflow-x: auto; border: 1px solid #444;",
          inline: "background-color: #333; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; border: 1px solid #444;"
        },
        table: {
          container: "width: 100%; border-collapse: collapse; margin-bottom: 1em;",
          header: "background-color: #333; font-weight: bold; text-align: left; padding: 0.5em; border: 1px solid #444;",
          cell: "border: 1px solid #444; padding: 0.5em;"
        },
        hr: "border: 0; border-top: 1px solid #444; margin: 1em 0;",
        image: "max-width: 100%; height: auto; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);",
        link: "color: #58a6ff; text-decoration: none;"
      }
    };
  }
  registerTheme(theme) {
    this.themes.set(theme.id, theme);
  }
  getTheme(id) {
    return this.themes.get(id);
  }
  getAllThemes() {
    return Array.from(this.themes.values());
  }
  getVisibleThemes() {
    return this.getAllThemes().filter((theme) => theme.isVisible !== false);
  }
  getCurrentTheme() {
    return this.themes.get(this.currentThemeId) || this.themes.get("default");
  }
  setCurrentTheme(id) {
    if (this.themes.has(id)) {
      this.currentThemeId = id;
      return true;
    }
    return false;
  }
  setFontSize(size) {
    this.currentFontSize = size;
  }
  getFontSize() {
    return this.currentFontSize;
  }
  // 应用主题到元素
  // 修改 applyTheme 方法，使用 CSS 类而不是内联样式
  applyTheme(element, themeId) {
    const theme = themeId ? this.getTheme(themeId) : this.getCurrentTheme();
    if (!theme)
      return;
    const themeClasses = Array.from(element.classList).filter((cls) => cls.startsWith("theme-"));
    themeClasses.forEach((cls) => element.classList.remove(cls));
    element.classList.add(`theme-${theme.id}`);
    element.style.fontSize = `${this.currentFontSize}px`;
  }
};

// src/main.ts
var BookSmithPlugin = class extends import_obsidian29.Plugin {
  async onload() {
    await this.loadSettings();
    this.bookManager = new BookManager(this.app, this.settings);
    this.statsManager = new BookStatsManager(this.app, this, this.bookManager);
    this.registerView(
      "book-smith-view",
      (leaf) => new BookSmithView(leaf, this)
    );
    this.registerView("book-smith-tool", (leaf) => new ToolView(leaf, this));
    this.addSettingTab(new BookSmithSettingTab(this.app, this));
    this.addCommand({
      id: "open-book-view",
      name: i18n.t("OPEN_BOOK_PANEL"),
      callback: () => {
        activateView(this.app, "book-smith-view", "left");
      }
    });
    this.addCommand({
      id: "open-tool-view",
      name: i18n.t("OPEN_TOOL_PANEL"),
      callback: () => {
        activateView(this.app, "book-smith-tool", "right");
      }
    });
    this.addCommand({
      id: "open-all-views",
      name: i18n.t("OPEN_ALL_PANELS"),
      callback: () => {
        activateView(this.app, "book-smith-view", "left");
        activateView(this.app, "book-smith-tool", "right");
      }
    });
    this.addRibbonIcon("book-open", i18n.t("OPEN_BOOK_PANEL"), () => {
      activateView(this.app, "book-smith-view", "left");
      activateView(this.app, "book-smith-tool", "right");
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.bookManager = new BookManager(this.app, this.settings);
    this.templateManager = new TemplateManager(this.settings);
    this.themeManager = new ThemeManager(this.app, this.settings);
    this.imgTemplateManager = new ImgTemplateManager(this.app, this.themeManager);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/

/* nosourcemap */